<HTML>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel=stylesheet type="text/css" href="wx.css"><title>wxStreams の概要</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="wxstreamoverview"></A><CENTER>
<A HREF="wx_contents.html"><img align=center src="contents.gif" BORDER=0 ALT="Contents"></A> <A HREF="wx_overviews.html#overviews"><img align=center src="up.gif" BORDER=0 ALT="Up"></A> <A HREF="wx_wxfileoverview.html#wxfileoverview"><img align=center src="back.gif" BORDER=0 ALT="Previous"></A> <A HREF="wx_wxlogoverview.html#wxlogoverview"><img align=center src="forward.gif" BORDER=0 ALT="Next"></A> </CENTER><HR>

<H2>wxStreams の概要</H2>
<P>
クラス: <A HREF="wx_wxstreambase.html#wxstreambase">wxStreamBase</A>, <A HREF="wx_wxstreambuffer.html#wxstreambuffer">wxStreamBuffer</A>, <A HREF="wx_wxinputstream.html#wxinputstream">wxInputStream</A>, <A HREF="wx_wxoutputstream.html#wxoutputstream">wxOutputStream</A>, <A HREF="wx_wxfilterinputstream.html#wxfilterinputstream">wxFilterInputStream</A>, <A HREF="wx_wxfilteroutputstream.html#wxfilteroutputstream">wxFilterOutputStream</A><P>
<B><FONT COLOR="#FF0000">wxStream の目的</FONT></B><P>
標準の C++ ストリームはいくつかのプラットフォームで問題を引き起こすことがあります: 大半はうまく動作しますが、例えばマルチスレッドの場合では多くの問題を抱えています。Borland のいくつかのコンパイラではまったく動作しませんし、Linux で iostream を使用すると異なる Linux ディストリビューション間でバイナリ互換性を保つことは不可能になります。<P>
そのため、wxStreams が wxWidgets に追加されました。これにより、libg++ の特定のバージョンに依存することなく、対応するすべてのプラットフォームで確実にアプリケーションをコンパイルし、実行することができます。<P>
wxStreams は主となるふたつの部分に分けられます:<P>
<OL>

<LI> コアクラス: wxStreamBase, wxStreamBuffer, wxInputStream, wxOutputStream, wxFilterIn/OutputStream
</LI><LI> "IO" クラス: wxSocketIn/OutputStream, wxDataIn/OutputStream, wxFileIn/OutputStream, ...
</LI></OL>
<P>
wxStreamBase はストリームの基底クラスです。このクラスは例えば OnSysRead、OnSysWrite、OnSysSeek、OnSysTell などの API を定義しています。これらのクラスは実際には "IO" クラスで実装されています。wxInputStream と wxOutputStream はこのクラスを継承しています。<P>
wxStreamBuffer は wxStreamBase 用のキャッシュマネージャです: このクラスはストリームに関連付けられたストリームバッファを管理します。ひとつのストリームは複数のストリームバッファを持つことができますが、ストリームは常にひとつの自動初期化済みのストリームバッファを持ちます。<P>
wxInputStream は読み取り専用ストリームの基底クラスです。このクラスでは Read、SeekI (I は Input を表します) と、読み取りや入出力に関するすべての関数を実装しています。wxOutputStream も同じことを行いますが、こちらは書き込み専用のストリーム用です。<P>
wxFilterIn/OutputStream はフィルタリング用の基底クラスです。ストリームのフィルタリングとは、システムコールは行いませんが、渡されたデータをフィルタリングし、他のストリームへ引き渡すストリームを意味します。例えば、wxZLibInputStream はインラインでストリームを展開します。<P>
"IO" クラスはストリームの特定の部分を実装しています。wxStreamBuffer に基づく wxMemoryIn/OutputStream の場合は何も行いません。また、この実装は単純に本当のシステムコール (read(...)、write(...) など) に関連付けられています。<P>
<B><FONT COLOR="#FF0000">一般的な使用方法の例</FONT></B><P>
使用方法は単純です。例として wxFileInputStream のサンプルコードを以下に示します:<P>
<PRE>
 ...
 // コンストラクタではストリームバッファの初期化と
 // ファイル名に関連付けられたファイルディスクリプタのオープンが行われる。
 wxFileInputStream in_stream("the_file_to_be_read");

 // Ok、データを読み込む ... nb_datas はバイト単位で表す。
 in_stream.Read(data, nb_datas);
 if (in_stream.LastError() != wxSTREAM_NOERROR) {
   // おっと、何か良くないことが起こった。
   // 完全な一覧は wxStreamBase のドキュメントを参照のこと。
 }

 // このようにインラインにすることもできる。
 if (in_stream.Read(data, nb_datas).LastError() != wxSTREAM_NOERROR) {
   // 処理を行なう。
 }

 // また、バッファへ実際に書き込んだバイト数を取得することもできる。
 size_t really_read = in_stream.LastRead();

 // Ok、ストリームの先頭へ移動する。SeekI はストリームの先頭から数えた 
 // 最後の位置を返却する。
 off_t old_position = in_stream.SeekI(0, wxFromBeginning);
 
 // 現在位置はどこ?
 off_t position = in_stream.TellI();

 // wxFileInputStream はデストラクタでファイルディスクリプタを閉じる。
</PRE>

</FONT><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body></HTML>
