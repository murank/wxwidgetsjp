<HTML>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel=stylesheet type="text/css" href="wx.css"><title>ビットマップとアイコンの概要</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="wxbitmapoverview"></A><CENTER>
<A HREF="wx_contents.html"><img align=center src="contents.gif" BORDER=0 ALT="Contents"></A> <A HREF="wx_overviews.html#overviews"><img align=center src="up.gif" BORDER=0 ALT="Up"></A> <A HREF="wx_scrollingoverview.html#scrollingoverview"><img align=center src="back.gif" BORDER=0 ALT="Previous"></A> <A HREF="wx_dcoverview.html#dcoverview"><img align=center src="forward.gif" BORDER=0 ALT="Next"></A> </CENTER><HR>

<H2>ビットマップとアイコンの概要</H2>
<P>
クラス: <A HREF="wx_wxbitmap.html#wxbitmap">wxBitmap</A>, <A HREF="wx_wxbitmaphandler.html#wxbitmaphandler">wxBitmapHandler</A>, <A HREF="wx_wxicon.html#wxicon">wxIcon</A>, <A HREF="wx_wxcursor.html#wxcursor">wxCursor</A>.<P>
wxBitmap クラスはモノクロとカラーの両方について、プラットフォームに依存するビットマップの概念をカプセル化するものです。既存のファイルから wxBitmap オブジェクトを作成するのにプラットフォーム独自の関数が提供されていますが、ときにこれは条件付きコンパイルを必要とすることがあります。<P>
動的に作成した、またはファイルから読み込んだビットマップはメモリデバイスコンテキスト (<A HREF="wx_wxmemorydc.html#wxmemorydc">wxMemoryDC</A> のインスタンス) で選択可能です。これにより、<A HREF="wx_wxdc.html#wxdcblit">wxDC::Blit</A> を使用してビットマップをウィンドウやメモリデバイスコンテキストにコピーしたり、描画先として使用したりすることができます。<P>
ビットマップへの描画の例は <A HREF="wx_wxmemorydc.html#wxmemorydc">wxMemoryDC</A> を参照してください。<P>
小さなビットマップやアイコンに使用される XPM について、wxWidgets はすべてのプラットフォームで対応しています。XPM は C のコードであるため、以下のようにして XPM をインラインでインクルードしたり、実行時に読み込むことが可能です。<P>
<PRE>
#include "mondrian.xpm"
</PRE>
Windows では .ico リソースを、それ以外のプラットフォームでは xpm を使用したいと思うことがあるかもしれません。(例えば、Windows の対応している多重解像度のアイコンを有効活用するためにです) <A HREF="wx_gdifunctions.html#wxiconmacro">wxICON</A> マクロを使用すると、適切なプラットフォームでは XPM を、Windows ではアイコンリソースを利用してアイコンを作成することができます。<P>
<PRE>
wxIcon icon(wxICON(mondrian));

// これは以下と同等:

#if defined(__WXGTK__) || defined(__WXMOTIF__)
wxIcon icon(mondrian_xpm);
#endif

#if defined(__WXMSW__)
wxIcon icon("mondrian");
#endif
</PRE>
これと対応するマクロに <A HREF="wx_gdifunctions.html#wxbitmapmacro">wxBITMAP</A> マクロがあり、<A HREF="wx_gdifunctions.html#wxiconmacro">wxICON</A> がアイコンを作成するのと同じ方法でビットマップを作成することができます。このマクロは Windows と OS2 ではリソース内に、それ以外のプラットフォームでは XPM ファイルとしてビットマップが存在するものとして処理を行います。(もちろん、XPM を使用するときはこのマクロを使用する前に対応するファイルをインクルードしておく必要があり、ビットマップの名前は Windows のリソース名の末尾に <TT>_xpm</TT> を付けたものにしてください) 以下に例を示します:<P>
<PRE>
// ビットマップを作成する、簡単で移植性のある方法
wxBitmap bmp(wxBITMAP(bmpname));

// これは以下のコードと大体同じです
#if defined(__WXMSW__) || defined(__WXPM__)
    wxBitmap bmp("bmpname", wxBITMAP_TYPE_RESOURCE);
#else // Unix
    wxBitmap bmp(bmpname_xpm, wxBITMAP_TYPE_XPM);
#endif
</PRE>
常に wxICON マクロと wxBITMAP マクロを使用するべきです。なぜなら、これらのマクロはどのプラットフォームでも動作しますし (上記のコードは wxMac、wxX11、... に対応していません)、<TT>#ifdef</TT> を使用したものより簡潔で明確だからです。もっと良い方法はすべてのプラットフォームで同じ XPM を使用することです。<P>
<A HREF="#supportedbitmapformats">対応しているビットマップファイル形式</A><BR><A HREF="#bitmaphandlers">ビットマップ形式ハンドラ</A><BR>
<P>

<HR>
<A NAME="supportedbitmapformats"></A>
<H3>対応しているビットマップファイル形式</H3>
<P>
各プラットフォームで対応している形式の一覧を以下に示します。対応していない、または部分的にしか実装されていない形式は自動的に <A HREF="wx_wximage.html#wximage">wxImage</A> を使用してデータの読み込みと wxBitmap 形式への変換が行われることに注意してください。wxWidgets で画像を読み込む場合、リソース (XPM ファイルや Windows のリソース) から読み込む場合を除くと、wxImage を利用した方が良いことにも注意してください。また、wxImage 用の画像形式ハンドラは wxBitmap のものより簡単に書くことができます。なぜなら、wxImage はすべてのプラットフォームでただひとつの形式を使用するのに対し、wxBitmap は色深度やプラットフォームに応じて様々な形式でピクセルデータを格納できるためです。<P>
<B><FONT COLOR="#FF0000">wxBitmap</FONT></B><P>
Windows では wxBitmap は以下の形式を読み込むことができます:<P>
<UL>

<LI> Windows ビットマップリソース (wxBITMAP_TYPE_BMP_RESOURCE)
</LI><LI> Windows ビットマップファイル (wxBITMAP_TYPE_BMP)
</LI><LI> XPM データおよび XPM ファイル (wxBITMAP_TYPE_XPM)
</LI><LI> <A HREF="wx_wximage.html#wximage">wxImage</A> クラスの対応するすべての形式
</LI></UL>
<P>
wxGTK では wxBitmap は以下の形式を読み込むことができます:<P>
<UL>

<LI> XPM データおよび XPM ファイル (wxBITMAP_TYPE_XPM)
</LI><LI> <A HREF="wx_wximage.html#wximage">wxImage</A> クラスの対応するすべての形式
</LI></UL>
<P>
wxMotif と wxX11 では wxBitmap は以下の形式を読み込むことができます:<P>
<UL>

<LI> XBM データおよび XBM ファイル (wxBITMAP_TYPE_XBM)
</LI><LI> XPM データおよび XPM ファイル (wxBITMAP_TYPE_XPM)
</LI><LI> <A HREF="wx_wximage.html#wximage">wxImage</A> クラスの対応するすべての形式
</LI></UL>
<P>
<B><FONT COLOR="#FF0000">wxIcon</FONT></B><P>
Windows では wxIcon は以下の形式を読み込むことができます:<P>
<UL>

<LI> Windows アイコンリソース (wxBITMAP_TYPE_ICO_RESOURCE)
</LI><LI> Windows アイコンファイル (wxBITMAP_TYPE_ICO)
</LI><LI> XPM データおよび XPM ファイル (wxBITMAP_TYPE_XPM)
</LI></UL>
<P>
wxGTK では wxIcon は以下の形式を読み込むことができます:<P>
<UL>

<LI> XPM データおよび XPM ファイル (wxBITMAP_TYPE_XPM)
</LI><LI> <A HREF="wx_wximage.html#wximage">wxImage</A> クラスの対応するすべての形式
</LI></UL>
<P>
wxMotif と wxX11 では wxImage は以下の形式を読み込むことができます:<P>
<UL>

<LI> XBM データおよび XBM ファイル (wxBITMAP_TYPE_XBM)
</LI><LI> XPM データおよび XPM ファイル (wxBITMAP_TYPE_XPM)
</LI><LI> <A HREF="wx_wximage.html#wximage">wxImage</A> クラスの対応するすべての形式
</LI></UL>
<P>
<B><FONT COLOR="#FF0000">wxCursor</FONT></B><P>
Windows では wxCursor は以下の形式を読み込むことができます:<P>
<UL>

<LI> Windows カーソルリソース (wxBITMAP_TYPE_CUR_RESOURCE)
</LI><LI> Windows カーソルファイル (wxBITMAP_TYPE_CUR)
</LI><LI> Windows アイコンファイル (wxBITMAP_TYPE_ICO)
</LI><LI> Windows ビットマップファイル (wxBITMAP_TYPE_BMP)
</LI></UL>
<P>
wxGTK では wxCursor は (既存のカーソルに加えて) 以下の形式を読み込むことができます:<P>
<UL>

<LI> なし (既存のカーソルのみ)
</LI></UL>
<P>
wxMotif と wxX11 では wxCursor は以下の形式を読み込むことができます:<P>
<UL>

<LI> XBM データおよび XBM ファイル (wxBITMAP_TYPE_XBM)
</LI></UL>
<P>

<HR>
<A NAME="bitmaphandlers"></A>
<H3>ビットマップ形式ハンドラ</H3>
<P>
拡張性のため、ビットマップ形式の読み書きは wxBitmap クラスで実装されておらず、wxBitmapHandler を継承した多数のハンドラクラスで実装されています。これらのハンドラの静的な一覧が存在し、ファイルの読み書きが要求された時に wxBitmap がこの一覧を調べます。いくつかのハンドラは標準で提供されていますが、特別な要件がある場合に自分で書いたハンドラやサードパーティーのハンドラを使用して wxBitmap クラスを初期化したいと思うかもしれません。<P>
wxBitmap のハンドラを追加する場合、ハンドラクラスを実装しているヘッダファイルをインクルードし、静的関数 <A HREF="wx_wxbitmap.html#wxbitmapaddhandler">wxBitmap::AddHandler</A> を呼ぶ必要があります。<P>
<B>注:</B> ビットマップハンドラはすべてのプラットフォームで実装されているわけでありませんし、新しいものを実装する必要もほとんどないでしょう。なぜなら、前で述べたように wxImage を使用することで大半の形式を読み込むことができるためです。<P>

</FONT><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body></HTML>
