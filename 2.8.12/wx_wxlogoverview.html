<HTML>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel=stylesheet type="text/css" href="wx.css"><title>wxLog クラスの概要</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="wxlogoverview"></A><CENTER>
<A HREF="wx_contents.html"><img align=center src="contents.gif" BORDER=0 ALT="Contents"></A> <A HREF="wx_overviews.html#overviews"><img align=center src="up.gif" BORDER=0 ALT="Up"></A> <A HREF="wx_wxstreamoverview.html#wxstreamoverview"><img align=center src="back.gif" BORDER=0 ALT="Previous"></A> <A HREF="wx_debuggingoverview.html#debuggingoverview"><img align=center src="forward.gif" BORDER=0 ALT="Next"></A> </CENTER><HR>

<H2>wxLog クラスの概要</H2>
<P>
クラス: <A HREF="wx_wxlog.html#wxlog">wxLog</A>,<BR><A HREF="wx_wxlogstderr.html#wxlogstderr">wxLogStderr</A>,<BR><A HREF="wx_wxlogstream.html#wxlogstream">wxLogStream</A>,<BR><A HREF="wx_wxlogtextctrl.html#wxlogtextctrl">wxLogTextCtrl</A>,<BR><A HREF="wx_wxlogwindow.html#wxlogwindow">wxLogWindow</A>,<BR><A HREF="wx_wxloggui.html#wxloggui">wxLogGui</A>,<BR><A HREF="wx_wxlognull.html#wxlognull">wxLogNull</A>,<BR><A HREF="wx_wxlogchain.html#wxlogchain">wxLogChain</A>,<BR><A HREF="wx_wxlogpassthrough.html#wxlogpassthrough">wxLogPassThrough</A>,<BR><A HREF="wx_wxstreamtotextredirector.html#wxstreamtotextredirector">wxStreamToTextRedirector</A><P>
これは wxWidgets の提供するロギングクラス全般の概要です。ここでのロギングという言葉は広い意味を持っており、非対話形式のメッセージに限らず、プログラムの出力すべてを含んでいます。wxWidgets のロギング機能では <I>ログターゲット</I> に対する標準的なインタフェースを定義する基底 <I>wxLog</I> クラスや、いくつかのログクラスの標準的な実装とそれを使用する関数群を提供しています。<P>
まず最初に、<I>wxLog</I> クラス郡を使用するのにその知識は必要とされません。そのため、<I>wxLogXXX()</I> 関数についてのみ、知っておく必要があります。これらの関数はすべて <I>printf()</I> や <I>vprintf()</I> と同じ構文を持ちます。つまり、第一引数にフォーマット文字列を取り、続けて可変引数か可変引数リストのポインタを取ります。以下にすべての関数を示します:<P>
<UL>

<LI><B>wxLogFatalError</B> は <I>wxLogError</I> と似ていますが、(<I>abort()</I> 標準関数を使用して) リターンコード 3 でプログラムを終了させます。他のすべてのロギング関数と異なり、この関数はログターゲットによってオーバーライドすることができません。
</LI><LI><B>wxLogError</B> はエラーメッセージ (ユーザに通知しなければならないメッセージ) 用の関数です。デフォルトの処理ではメッセージボックスをポップアップして通知します。
</LI><LI><B>wxLogWarning</B> は警告メッセージ (通常はユーザに通知されますが、プログラムの動作を妨げないメッセージ） 用の関数です。
</LI><LI><B>wxLogMessage</B> はすべての通常 (通知) メッセージ用の関数です。この関数もデフォルトでメッセージボックスを表示します。 (ただし、この振る舞いは変更可能です。以下を参照してください)
</LI><LI><B>wxLogVerbose</B> は詳細な出力用の関数です。通常は出力されませんが、ユーザがプログラムの進捗状況についてより詳しく知りたい場合に有効化されるかもしれません。 (名前の紛らわしい同じ機能の関数として <B> wxLogInfo</B> があります)
</LI><LI><B>wxLogStatus</B> はステータスメッセージ用の関数で、このメッセージはアクティブまたは第一引数で指定された <A HREF="wx_wxframe.html#wxframe">wxFrame</A> がステータスバーを持つ場合に、ステータスバーへ出力されます。
</LI><LI><B>wxLogSysError</B> は主に wxWidgets 自身で使用されますが、システムコール (API 関数) の失敗後のエラーログを記録するのに便利かもしれません。この関数は指定したメッセージとあわせて、最後のシステムエラーコード  (プラットフォームに応じて <I>errno</I> または <I>::GetLastError()</I> ) とそれに対応するエラーメッセージを出力します。この関数の 2 番目の形式では第一引数として明示的にエラーコードを指定できます。
</LI><LI><B>wxLogDebug</B> は <B>まさに</B> デバッグ出力に適切な関数です。デバッグモードの場合 (プリプロセッサシンボル __WXDEBUG__ が定義されている場合) のみ処理を行い、リリースモードの場合 (それ以外の場合) では空文字列に展開されます。<B>ヒント:</B> Windows でデバッグ出力を確認するためにはデバッガーを使用するか、<A HREF="http://www.sysinternals.com">DbgView</A> のようなサードパーティーのプログラムを使用する必要があります。
</LI><LI><B>wxLogTrace</B> も <B>wxLogDebug</B> と同じようにデバッグビルド時のみ動作します。これを別の関数とした理由は、通常、トレースメッセージを大量に出力するため、同じように大量に出力する他のデバッグ出力と区別することに意味があるはずだからです。くわえて、2 番目の形式では第一引数としてトレースマスクを指定できるため、生成されるメッセージの量をさらに制限することができます。
</LI></UL>
<P>
これらの関数の用途はかなり明確ですが、なぜ C の標準入出力関数や C++ のストリームといった他のロギング機能を使用しないのか疑問に思うかもしれません。簡単に答えれば、それらの関数やストリームは確かに優れた汎用的な仕組みを持っていますが、本当に wxWidgets に適しているとは言えないためです。wxWidgets のログ関数を使用するいくつかの利点は以下の通りです:<P>
<UL>

<LI><B>移植性</B> デバッグ情報や他の情報の出力に <I>printf()</I> や cout/cerr などの C++ ストリームを使用するのはごく普通のことです。ただし、これは Unix では正常に動作しますが、GUI プログラムの標準出力がどこにも割り当てられない Windows では厳密にどこにも出力されません. したがって、<I>wxLogMessage()</I> を <I> printf()</I> の単純な代替として考えてください。<P>
以下のように書くことで <I>wxLogXXX</I> 呼び出しを <I>cout</I> へリダイレクトすることもできます:
<FONT SIZE=2>
<PRE>
  wxLog *logger=new wxLogStream(&amp;cout);
  wxLog::SetActiveTarget(logger);
</PRE>
</FONT><P>
最後に、<A HREF="wx_wxstreamtotextredirector.html#wxstreamtotextredirector">wxStreamToTextRedirector</A> クラスを使用することで <I>cout</I> へ出力した内容を <A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A> にリダイレクトすることもできます。
</LI><LI><B>柔軟性</B> wxLog 関数の出力はその重要度に応じてリダイレクトしたり抑制したりできます。これは従来の関数では不可能、もしくは困難なことです。例えば、すべての通知メッセージをフィルタリングして、エラーメッセージのみ、もしくはエラーメッセージと警告メッセージのみを記録しても構いません。
</LI><LI><B>完全性</B> 通常、処理が失敗した場合にはエラーメッセージが表示されるべきです。非常に単純で、よくあるファイルエラーの場合を考えてみましょう: データをディスク上のファイルに書き込もうとして充分な空き容量がなかったときを想像してください。実際のエラーは wxWidgets コード (<I>wxFile::Write</I>) 内で検知されるため、呼び出し元の関数では失敗の正確な原因を実際に知ることはできず、ディスクへの書き込みに失敗したことしか分かりません。しかし、このような状況で <I>wxLogError()</I> を使用すれば、書き込みに失敗したファイルに関する "高レベル" なメッセージとともに正確なエラーコード (と対応するエラーメッセージ) が表示されます。
</LI></UL>
<P>
メッセージのロギングに通常使用するすべての関数と、それらを使用する理由について列挙したので、これらの動作方法について説明します。<P>
wxWidgets では <I>ログターゲット</I> という考え方があります: これは単純に <A HREF="wx_wxlog.html#wxlog">wxLog</A> を継承したクラスです。そのため、メッセージのロギング時に呼ばれる基底クラスの仮想関数を実装ています。いつでも <I>有効な</I> ログターゲットはひとつだけで、これが <I>wxLogXXX()</I> 関数によって使用されます。ログオブジェクト (つまり、wxLog を継承したクラスのオブジェクト) の通常の使用方法は <I> SetActiveTarget()</I> を使用して有効なターゲットとして設定することで、それ以降に呼び出された <I>wxLogXXX()</I> 関数で自動的に使用されるようになります。<P>
新しいログターゲットクラスを作成する場合、wxLog を継承し、<I>DoLog()</I> と <I>DoLogString()</I> のどちらか (または両方) を実装するだけです。標準的な wxLog メッセージの形式 (先頭に "Error:" か "Warning:" とタイムスタンプが付きます) で充分だが、メッセージを他の場所へ送りたい場合は 2 番目の関数を実装するだけで充分です。最初の関数をオーバーライドすると何でもできますが、異なるメッセージ型を自分で区別する必要があります。<P>
wxLog を継承したクラスがいくつか事前に定義されており、新しいログターゲットクラスを作成する際の参考になると思います。もちろん、そのまま使用することも可能です。以下にその一覧を示します:<P>
<UL>

<LI><B>wxLogStderr</B> このクラスはメッセージを <I>FILE *</I> へ出力します。その名の通り、デフォルトでは stderr へ出力します。
</LI><LI><B>wxLogStream</B> このクラスは wxLogStderr と同じ機能を持ちますが、<I>FILE *</I> と stderr の代わりに <I>ostream</I> と cerr を使用します。
</LI><LI><B>wxLogGui</B> これは wxWidgets アプリケーションの標準ログターゲット (何もしない場合にデフォルトで使用されます) で、指定されたプラットフォームについて、メッセージのすべての型に対してもっとも合理的な処理を行います。
</LI><LI><B>wxLogWindow</B> このログターゲットはアプリケーションの生成するすべてのメッセージを収集する "ログコンソール" を提供するとともに、前に有効だったログターゲットに収集したメッセージを引き渡します。ログウィンドウフレームはメニューを持ち、ログの消去、終了、メッセージの保存を選択することができます。
</LI><LI><B>wxLogNull</B> 最後のログクラスは極めて特殊です: これは何も行いません。このクラスのオブジェクトは <I>wxLogXXX()</I> 関数の出力を (一時的に) 抑制する場合にインスタンス化されます。例として、存在しないファイルを開こうとすると通常はエラーメッセージが表示されますが、何らかの理由でそれを望まない場合、次のようにするだけです:<P>
<FONT SIZE=2><PRE>
  wxFile file;

  // 通常はファイルを開けなかった場合に wxFile.Open() がエラーメッセージを出力するが、そうさせたくない
  {
    wxLogNull logNo;
    if ( !file.Open("bar") )
      ... 自分自身でエラー処理を行なう ...
  } // ~wxLogNull が呼ばれ、古いログ出力先が元に戻される
  
  wxLogMessage("..."); // ok
</PRE>
</FONT></LI></UL>
<P>
ログターゲットは組み合わせて使用することもできます: 例えば、メッセージを他の場所 (例えばログファイルなど) にリダイレクトしつつ、通常通りの方法でも処理したいとします。このために <A HREF="wx_wxlogchain.html#wxlogchain">wxLogChain</A> と <A HREF="wx_wxlogpassthrough.html#wxlogpassthrough">wxLogPassThrough</A> を使用できます。<P>

</FONT><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body></HTML>
