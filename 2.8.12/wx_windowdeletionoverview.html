<HTML>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel=stylesheet type="text/css" href="wx.css"><title>ウィンドウ削除の概要</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="windowdeletionoverview"></A><CENTER>
<A HREF="wx_contents.html"><img align=center src="contents.gif" BORDER=0 ALT="Contents"></A> <A HREF="wx_overviews.html#overviews"><img align=center src="up.gif" BORDER=0 ALT="Up"></A> <A HREF="wx_windowstyles.html#windowstyles"><img align=center src="back.gif" BORDER=0 ALT="Previous"></A> <A HREF="wx_wxdialogoverview.html#wxdialogoverview"><img align=center src="forward.gif" BORDER=0 ALT="Next"></A> </CENTER><HR>

<H2>ウィンドウ削除の概要</H2>
<P>
クラス: <A HREF="wx_wxcloseevent.html#wxcloseevent">wxCloseEvent</A>, <A HREF="wx_wxwindow.html#wxwindow">wxWindow</A><P>
ウィンドウの削除は混乱しやすいテーマなので、この概要ではいつ、どのようにウィンドウを削除するか、もしくはユーザの要求に応じてウィンドウを閉じるかについて、理解の手助けになる情報を提供します。<P>
<B><FONT COLOR="#FF0000">ウィンドウ削除時に発生する一連のイベントにはどのようなものがありますか?</FONT></B><P>
ユーザがフレームやダイアログの閉じるボタンを押下したときや、終了コマンドを実行したときに wxWidgets は <A HREF="wx_wxwindow.html#wxwindowclose">wxWindow::Close</A> を呼び出します。そして、これは EVT_CLOSE イベントを生成します: <A HREF="wx_wxcloseevent.html#wxcloseevent">wxCloseEvent</A> 参照。<P>
適切なイベントハンドラを定義し、ウィンドウを破棄するか決定するのはアプリケーションの責務です。なんらかの理由で強制的にアプリケーションを終了させる場合 (<A HREF="wx_wxcloseevent.html#wxcloseeventcanveto">wxCloseEvent::CanVeto</A> が false を返却する場合)、常にウィンドウを破棄するべきです。それ以外の場合では終了要求を無視するか、安全に終了できるか決定する前にユーザへ確認するという選択肢があります。ウィンドウを破棄しない場合、EVT_CLOSE ハンドラで <A HREF="wx_wxcloseevent.html#wxcloseeventveto">wxCloseEvent::Veto</A> を呼び出し、呼び出し元へそのことを通知するようにしてください。この関数を呼ぶことで呼び出し元へ有用な情報を提供します。<P>
wxCloseEvent ハンドラではウィンドウを破棄するときに <A HREF="wx_wxwindow.html#wxwindowdestroy">wxWindow::Destroy</A> のみを使用するようにし、<B>delete</B> 演算子を使用しないでください。これは、いくつかのウィンドウクラスではすべてのイベントが処理されるまでウィンドウを実際に削除しないためです。このようにしない場合、イベントが存在しないウィンドウに送信される危険性があります。<P>
次の章で補足しますが、Close の呼び出しはウィンドウが破棄されることを保証しません。確実にウィンドウを破棄する場合、<A HREF="wx_wxwindow.html#wxwindowdestroy">wxWindow::Destroy</A> を呼び出してください。<P>
<B><FONT COLOR="#FF0000">どのようにしてアプリケーションからウィンドウを削除できますか?</FONT></B><P>
アプリケーションではフレームワークが行なうように <A HREF="wx_wxwindow.html#wxwindowclose">wxWindow::Close</A> イベントを使用するか、もしくは直接 <A HREF="wx_wxwindow.html#wxwindowdestroy">wxWindow::Destroy</A> を呼び出すことができます。Close() を使用している場合は引数に true を渡すことで、このフレームを確実に破棄したいと考えており、終了要求を拒否できないことをイベントハンドラへ通知できます。<P>
Destroy の代わりに Close を使用する利点は EVT_CLOSE イベントハンドラで任意の後処理を行える点です。例えば、ユーザに作業中のドキュメントを保存するように確認した後でドキュメントを閉じるといったことができます。Close は (false を返却したときに) 終了処理を拒否できるのに対し、Destroy は確実にウィンドウを削除します。<P>
<B><FONT COLOR="#FF0000">デフォルトの振る舞いどのようなものですか?</FONT></B><P>
wxDialog のデフォルトの終了イベントハンドラは wxID_CANCEL イベントを生成する Cancel コマンドを模倣します。このキャンセルイベントのハンドラ自身が <B>Close</B> を呼ぶため、無限ループのチェックが行われます。wxID_CANCEL のデフォルトハンドラは (モードレスの場合に) ダイアログを非表示にするか、(モーダルの場合に) EndModal(wxID_CANCEL) を呼びます。言い換えると、デフォルトではダイアログは <I>破棄されません</I>。(ダイアログはスタック上に作られるかもしれないので、動的に生成されると仮定することはできません)<P>
wxFrame のデフォルトの終了ハンドラは Destroy() を使用してフレームを破棄します。<P>
<B><FONT COLOR="#FF0000">ユーザがメニューから終了を選んだときに何をすべきですか?</FONT></B><P>
フレームの <A HREF="wx_wxwindow.html#wxwindowclose">wxWindow::Close</A> を単純に呼ぶことができます。これにより、フレームを破棄する独自の終了イベントハンドラが実行されます。<P>
このときにアプリケーションを安全に終了できるかどうかを自前の終了イベントハンドラ、もしくは終了メニューコマンドハンドラから確認することができます。例えば、すべてのファイルが保存されているか確認したいと思うかもしれません。保存して終了するか、保存せずに終了するか、終了コマンドを完全にキャンセルするかをユーザが選択できるようにしてください。<P>
<B><FONT COLOR="#FF0000">1.xx の OnClose を 2.0 にアップグレードするには何をすべきですか?</FONT></B><P>
wxWidgets 1.xx では <B>OnClose</B> 関数は実際に 'this' を削除せず、呼び出し元 (<B>Close</B> または wxWidgets フレームワーク) へウィンドウを削除するかどうかを通知していました。<P>
コードをアップグレードするには EVT_CLOSE マクロを使用してフレームやダイアログ内でイベントテーブルのエントリを定義してください。イベントハンドラ関数は以下のようになります:<P>
<FONT SIZE=2><PRE>
  void MyFrame::OnCloseWindow(wxCloseEvent&amp; event)
  {
    if (MyDataHasBeenModified())
    {
      wxMessageDialog* dialog = new wxMessageDialog(this,
        "Save changed data?", "My app", wxYES_NO|wxCANCEL);

      int ans = dialog-&gt;ShowModal();
      dialog-&gt;Destroy();

      switch (ans)
      {
        case wxID_YES:      // 保存し、アプリケーションを終了する
          SaveMyData();
          this-&gt;Destroy();
          break;
        case wxID_NO:       // 保存しない; 破棄してアプリケーションを終了する
          this-&gt;Destroy();
          break;
        case wxID_CANCEL:   // 何もしない - そのため、アプリケーションを終了しない
        default:
          if (!event.CanVeto()) // この削除が拒否可能か確認する

            this-&gt;Destroy();    // 拒否不可の場合、とにかくウィンドウを破棄する
          else
            event.Veto();     // フレームを削除しなかったことを呼び出し元へ通知する
          break;
      }
    }
  }
</PRE>
</FONT><B><FONT COLOR="#FF0000">アプリケーションを正しく終了するにはどうすれば良いですか?</FONT></B><P>
wxWidgets アプリケーションは最後のトップレベルウィンドウ (<A HREF="wx_wxframe.html#wxframe">wxFrame</A> または <A HREF="wx_wxdialog.html#wxdialog">wxDialog</A>) が破棄されたときに自動的に終了します。アプリケーション全体の後処理は <A HREF="wx_wxapp.html#wxapponexit">wxApp::OnExit</A> (これは仮想関数であって、イベントハンドラではありません) に配置してください。<P>
<B><FONT COLOR="#FF0000">子ウィンドウは自動的に削除されますか?</FONT></B><P>
はい、子ウィンドウは親ウィンドウのデストラクタで削除されます。これは子ウィンドウであればフレームやダイアログも含みます。そのため、親ウィンドウの終了ハンドラで明示的に子フレームや子ダイアログを終了させたいと思うかもしれません。<P>
<B><FONT COLOR="#FF0000">他の種類のウィンドウについてはどうでしょう?</FONT></B><P>
これまでは 'マネージド' ウィンドウ、つまりフレームやダイアログについて話してきました。コントロールなど、親を持つウィンドウは直ちに削除され、通常は終了イベントハンドラを持ちません。とはいえ、必要であればそれらを実装することができます。一貫性を保つために、これらの種類のウィンドウを明示的に削除するときは <B>delete</B> 演算子の代わりに引き続き <A HREF="wx_wxwindow.html#wxwindowdestroy">wxWindow::Destroy</A> 関数を使用してください。<P>

</FONT><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body></HTML>
