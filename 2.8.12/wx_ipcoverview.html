<HTML>
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8"><link rel=stylesheet type="text/css" href="wx.css"><title>プロセス間通信の概要</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="ipcoverview"></A><CENTER>
<A HREF="wx_contents.html"><img align=center src="contents.gif" BORDER=0 ALT="Contents"></A> <A HREF="wx_overviews.html#overviews"><img align=center src="up.gif" BORDER=0 ALT="Up"></A> <A HREF="wx_odbcoverview.html#odbcoverview"><img align=center src="back.gif" BORDER=0 ALT="Previous"></A> <A HREF="wx_wxhtml.html#wxhtml"><img align=center src="forward.gif" BORDER=0 ALT="Next"></A> </CENTER><HR>

<H2>プロセス間通信の概要</H2>
<P>
クラス: <A HREF="wx_wxserver.html#wxserver">wxServer</A>, <A HREF="wx_wxddeconnection.html#wxddeconnection">wxConnection</A>, <A HREF="wx_wxclient.html#wxclient">wxClient</A> wxWidgets にはプロセス間通信やネットワークプログラミングを支援する様々なクラスがあります。この章では DDE 風のプロトコルを使用するひとつのクラス群についてのみ説明しますが、その代わりに他の有用なクラスの一覧を以下に示します:<P>
<UL>

<LI> <A HREF="wx_wxsocketevent.html#wxsocketevent">wxSocketEvent</A>、<A HREF="wx_wxsocketbase.html#wxsocketbase">wxSocketBase</A>、<A HREF="wx_wxsocketclient.html#wxsocketclient">wxSocketClient</A>、<A HREF="wx_wxsocketserver.html#wxsocketserver">wxSocketServer</A>: 低レベルのTCP/IP API 用クラスです。
</LI><LI> <A HREF="wx_wxprotocol.html#wxprotocol">wxProtocol</A>、<A HREF="wx_wxurl.html#wxurl">wxURL</A>、<A HREF="wx_wxftp.html#wxftp">wxFTP</A>、<A HREF="wx_wxhttp.html#wxhttp">wxHTTP</A>: よく知られているインターネットプロトコルのプログラミング用クラスです。
</LI></UL>
<P>
wxWidgets の DDE 風プロトコルは Windows DDE に基づく高レベルのプロトコルです。このDDE 風プロトコルには 2 種類の実装があります: ひとつは実際の DDE を使用する方法で、WIndows のみで実行できます。もうひとつは TCP/IP (ソケット) を使用する方法で、ほとんどのプラットフォームで実行できます。クラス名を除いて API と仮想的な振る舞いがすべて同じであるため、ふたつの実装を簡単に切り替えられることに気がつくと思います。<P>
<TT>&lt;wx/ipc.h&gt;</TT> をインクルードすることで IPC クラス用の便利なシノニムを定義できます: DDE ベースの実装とソケットベースの実装のどちらを使用するかによって <TT>wxDDEServer</TT> もしくは <TT>wxTCPServer</TT> のいずれかが <TT>wxServer</TT> として定義されます。同様のことが <TT>wxClient</TT> と <TT>wxConnection</TT> に対しても行われます。<P>
Windows ではデフォルトで DDE 版が使用されます。DDE は同じコンピュータ内でのみ動作します。もし異なるワークステーション間で IPC を使用したい場合、このヘッダファイルをインクルードする前に <TT> wxUSE_DDE_FOR_IPC</TT> を 0 に定義してください。これにより、Windows でも強制的に TCP/IP 版が使用されるようになります。<P>
以降の説明では wx... という名称を使用しますが、同じ wxTCP... クラスと wxDDE... クラスは同様の方法で使用できることを覚えておいてください。<P>
DDE 風 API では中心となるクラスが 3 種類あります:<P>
<OL>

<LI> wxClient. これはクライアントアプリケーションを表しており、クライアントプログラムの中でだけ使用できます。
</LI><LI> wxServer. これはサーバアプリケーションを表しており、サーバプログラムの中でだけ使用できます。
</LI><LI> wxConnection. これはクライアントからサーバへのコネクションを表しています。クライアントとサーバの両方とも、このクラスのインスタンスをコネクションごとにひとつ使用します。ほとんどの DDE トランザクションはこのオブジェクト上で行われます。
</LI></OL>
<P>
通常、アプリケーション間のメッセージは 3 種類の変数で識別されます: コネクションオブジェクト、トピック名、アイテム名です。いくつかのメッセージではデータ文字列が 4 番目の要素になります。コネクション (Windows で言うところの会話 (conversation)) を作成するにはクライアントアプリケーションでサービス名 (サーバを識別します) とトピック名 (接続している間のトピックを識別します) を指定して wxClient::MakeConnection を呼び出します。Unix におけるサービス名はインターネットドメインソケットが通信に使用する整数のポート識別子か、Unix ドメインソケットが作成する有効なファイル名 (このファイルは存在してはならず、後で削除されます) のいずれかになります。<P>
<B>セキュリティ上の注意:</B> インターネットドメインソケットを使用したプロセス間通信は非常に危険です。なぜなら、これらの通信に対するアクセス制御はまったく行われないためです。可能な限り、Unix ドメインソケットを使用してください。<P>
そして、サーバが応答し、接続を拒否または許可します。接続が許可されるとサーバとクライアントの双方で wxConnection が作成され、接続が閉じられるまで維持されます。作成されたコネクションオブジェクトはクライアント・サーバ間でのメッセージの送受信に使用されます。このとき、wxConnection を継承したクラスで仮想関数をオーバーライドすると DDE メッセージを処理することができます。<P>
動作するサーバを作成するには次のようにする必要があります:<P>
<OL>

<LI> wxConnection を継承し、wxConnection のサーバ側へ送信されたメッセージ用のハンドラ (OnExecute、OnRequest、OnPoke など) を用意する。このとき、実際にアプリケーションで必要となるハンドラだけをオーバーライドする必要があります。
</LI><LI> wxServer を継承し、トピック引数に基づいて接続を許可または拒否するために OnAcceptConnection をオーバーライドする。接続を許可する場合、継承したコネクションクラスのインスタンスをこのメンバ関数で作成し、返却する必要があります。
</LI><LI> サーバオブジェクトのインスタンスを作成し、作成したオブジェクトを有効化するためにサービス名を指定して Create を呼び出す。
</LI></OL>
<P>
動作するクライアントを作成するには次のようにする必要があります:<P>
<OL>

<LI> wxConnection を継承し、wxConnection のクライアント側へ送信されたメッセージ用のハンドラ (OnAdvise など) を用意する。このとき、実際にアプリケーションで必要となるハンドラだけをオーバーライドする必要があります。
</LI><LI> wxClient を継承して OnMakeConnection をオーバーライドし、継承したコネクションクラスのインスタンスを作成して返却する。
</LI><LI> クライアントオブジェクトのインスタンスを作成する。
</LI><LI> 適切なときにホスト名 (Unix の場合のみ使用されます。ローカルコンピュータを指定する場合は 'localhost' を使用してください)、サービス名、この接続用のトピック名を指定して <A HREF="wx_wxclient.html#wxclientmakeconnection">wxClient::MakeConnection</A> を呼び出し、新しいコネクションを作成する。接続に成功するとクライアントオブジェクトは継承したコネクションクラスのオブジェクトを作成するために <A HREF="wx_wxddeclient.html#wxddeclientonmakeconnection">OnMakeConnection</A> を呼び出します。
</LI><LI> サーバへメッセージを送信するには wxConnection のメンバ関数を使用してください。
</LI></OL>
<P>
<A HREF="#datatransfer">データの転送</A><BR><A HREF="#ipcexamples">例</A><BR><A HREF="#ddedetails">DDE の詳細</A><BR>
<P>

<HR>
<A NAME="datatransfer"></A>
<H3>データの転送</H3>
<P>
他のアプリケーションへデータを転送するにはいくつかの方法があります。これらは wxConnection の関数です。<P>
<UL>

<LI> <B>Execute:</B> 実行するコマンドを表すデータ文字列を指定してクライアントからサーバを呼び出します。これはサーバが応答するかどうかに応じて成功または失敗します。呼び出しの成否以外に Execute コマンドの結果を得たい場合、明示的に Request を呼ぶ必要があります。
</LI><LI> <B>Request:</B> 指定した項目に関連する特定のデータ文字列をクライアントからサーバへ要求します。サーバが応答しない場合、戻り値は NULL になります。それ以外の場合、戻り値は文字列になります。(実際には接続バッファへのポインタであるため、アプリケーション側で解放しないでください)
</LI><LI> <B>Poke:</B> ある項目に関連するデータ文字列をクライアントからサーバへ直接送信します。これは成功または失敗します。
</LI><LI> <B>Advise:</B> 特定の項目に関連するデータの変更をクライアントへ通知するように要求します。サーバがこれを承諾した場合、サーバは項目とデータとともに OnAdvise メッセージをクライアントへ送信します。
</LI></UL>
<P>
デフォルトのデータ型は wxCF_TEXT (ASCII テキスト) で、デフォルトのデータサイズはヌル終端文字列の文字列長です。また、Windows 独自のデータ型を使用することもできます。<P>

<HR>
<A NAME="ipcexamples"></A>
<H3>例</H3>
<P>
IPC サンプルディレクトリにある <I>server</I> と <I>client</I> のサンプルプログラムを参照してください。サーバを実行し、それからクライアントを実行してください。このサンプルでは Advise ループとともに Execute、Request、Poke コマンドを使用しています: サーバ側のリストボックスを選択すると、選択された項目がクライアント側のリストボックスでハイライトされます。<P>

<HR>
<A NAME="ddedetails"></A>
<H3>DDE の詳細</H3>
<P>
wxClient オブジェクトは DDE 風 (Dynamic Data Exchange) 通信のクライアント・サーバ通信のクライアント部分を初期化します。(Windows と Unix の両方で利用可能です)<P>
適切なサーバと通信するクライアントを作成するには wxConnection と wxClient をそれぞれ継承する必要があります。wxConnection の継承クラスはサーバとの '会話' (conversation) におけるやり取りを受信します。そして wxServer を継承したクラスが必要になります。これにより、接続が確立したときに <A HREF="wx_wxddeclient.html#wxddeclientonmakeconnection">wxClient::OnMakeConnection</A> をオーバーライドした関数が要求されたクラスの wxConnection を返却できるようになります。<P>
以下に例を示します:<P>
<PRE>
class MyConnection: public wxConnection {
 public:
  MyConnection(void)::wxConnection() {}
  ~MyConnection(void) { }
  bool OnAdvise(const wxString&amp; topic, const wxString&amp; item, char *data, int size, wxIPCFormat format)
  { wxMessageBox(topic, data); }
};

class MyClient: public wxClient {
 public:
  MyClient(void) {}
  wxConnectionBase *OnMakeConnection(void) { return new MyConnection; }
};

</PRE>
ここでは <B>MyConnection</B> がサーバから送信された <A HREF="wx_wxddeconnection.html#wxddeconnectiononadvise">OnAdvise</A> メッセージに反応してメッセージボックスを表示します。<P>
クライアントアプリケーションを実行するときには wxClient の継承クラスのインスタンスを作成する必要があります。以下ではコマンドライン引数を使用してホスト名 (サーバを実行しているマシン名)、(サーバプロセスを識別する) サーバ名を引き渡しています。<A HREF="wx_wxddeclient.html#wxddeclientmakeconnection">wxClient::MakeConnection</A> を呼び出すと接続要求が受け付けられた場合に <B>MyConnection</B> のインスタンスが暗黙的に作成されます。そして、クライアントはサーバからの <I>Advise</I> ループを要求します。(Advise ループとはデータが変更されたときにサーバがクライアントを呼び出すところのことです)<P>
<PRE>
  wxString server = "4242";
  wxString hostName;
  wxGetHostName(hostName);

  // 新しいクライアントを作成する
  MyClient *client = new MyClient;
  connection = (MyConnection *)client-&gt;MakeConnection(hostName, server, "IPC TEST");

  if (!connection)
  {
    wxMessageBox("Failed to make connection to server", "Client Demo Error");
    return NULL;
  }
  connection-&gt;StartAdvise("Item");
</PRE>

</FONT><script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body></HTML>
