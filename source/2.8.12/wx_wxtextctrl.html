<HTML>
<head><link rel=stylesheet type="text/css" href="wx.css"><title>wxTextCtrl</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="wxtextctrl"></A><CENTER>
<A HREF="wx_contents.html"><img align=center src="contents.gif" BORDER=0 ALT="Contents"></A> <A HREF="wx_classref.html#classref"><img align=center src="up.gif" BORDER=0 ALT="Up"></A> <A HREF="wx_wxtextattrex.html#wxtextattrex"><img align=center src="back.gif" BORDER=0 ALT="Previous"></A> <A HREF="wx_wxtextdataobject.html#wxtextdataobject"><img align=center src="forward.gif" BORDER=0 ALT="Next"></A> </CENTER><HR>

<H2>wxTextCtrl</H2>
<P>
A text control allows text to be displayed and edited. It may be
single line or multi-line.<P>
<B><FONT COLOR="#FF0000">Derived from</FONT></B><P>
streambuf<BR>

<A HREF="wx_wxcontrol.html#wxcontrol">wxControl</A><BR>

<A HREF="wx_wxwindow.html#wxwindow">wxWindow</A><BR>

<A HREF="wx_wxevthandler.html#wxevthandler">wxEvtHandler</A><BR>

<A HREF="wx_wxobject.html#wxobject">wxObject</A><P>
<B><FONT COLOR="#FF0000">Include files</FONT></B><P>
&lt;wx/textctrl.h&gt;<P>
<B><FONT COLOR="#FF0000">Window styles</FONT></B><P>


<TABLE>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_PROCESS_ENTER</B>
</FONT></TD>

<TD VALIGN=TOP>
The control will generate
the event wxEVT_COMMAND_TEXT_ENTER (otherwise pressing Enter key
is either processed internally by the control or used for navigation between
dialog controls).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_PROCESS_TAB</B>
</FONT></TD>

<TD VALIGN=TOP>
The control will receive
wxEVT_CHAR events for TAB pressed - normally, TAB is used for passing to the
next control in a dialog instead. For the control created with this style,
you can still use Ctrl-Enter to pass to the next control from the keyboard.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_MULTILINE</B>
</FONT></TD>

<TD VALIGN=TOP>
The text control allows multiple lines.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_PASSWORD</B>
</FONT></TD>

<TD VALIGN=TOP>
The text will be echoed as asterisks.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_READONLY</B>
</FONT></TD>

<TD VALIGN=TOP>
The text will not be user-editable.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_RICH</B>
</FONT></TD>

<TD VALIGN=TOP>
Use rich text control under Win32, this
allows to have more than 64KB of text in the control even under Win9x. This
style is ignored under other platforms.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_RICH2</B>
</FONT></TD>

<TD VALIGN=TOP>
Use rich text control version 2.0 or 3.0
under Win32, this style is ignored under other platforms
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_AUTO_URL</B>
</FONT></TD>

<TD VALIGN=TOP>
Highlight the URLs and generate the
wxTextUrlEvents when mouse events occur over them. This style is only supported
for wxTE_RICH Win32 and multi-line wxGTK2 text controls.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_NOHIDESEL</B>
</FONT></TD>

<TD VALIGN=TOP>
By default, the Windows text control
doesn't show the selection when it doesn't have focus - use this style to force
it to always show it. It doesn't do anything under other platforms.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxHSCROLL</B>
</FONT></TD>

<TD VALIGN=TOP>
A horizontal scrollbar will be created and
used, so that text won't be wrapped. No effect under wxGTK1.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_LEFT</B>
</FONT></TD>

<TD VALIGN=TOP>
The text in the control will be left-justified (default).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_CENTRE</B>
</FONT></TD>

<TD VALIGN=TOP>
The text in the control will be centered (currently wxMSW and wxGTK2 only).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_RIGHT</B>
</FONT></TD>

<TD VALIGN=TOP>
The text in the control will be right-justified (currently wxMSW and wxGTK2 only).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_DONTWRAP</B>
</FONT></TD>

<TD VALIGN=TOP>
Same as <TT>wxHSCROLL</TT> style: don't wrap at all, show horizontal scrollbar instead.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_CHARWRAP</B>
</FONT></TD>

<TD VALIGN=TOP>
Wrap the lines too long to be shown entirely at any position (wxUniv and wxGTK2 only).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_WORDWRAP</B>
</FONT></TD>

<TD VALIGN=TOP>
Wrap the lines too long to be shown entirely at word boundaries (wxUniv and wxGTK2 only).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_BESTWRAP</B>
</FONT></TD>

<TD VALIGN=TOP>
Wrap the lines at word boundaries or at any other character if there are words longer than the window width (this is the default).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=198>
<B>wxTE_CAPITALIZE</B>
</FONT></TD>

<TD VALIGN=TOP>
On PocketPC and Smartphone, causes the first letter to be capitalized.
</FONT></TD></TR>


</TABLE>
<P>
See also <A HREF="wx_windowstyles.html#windowstyles">window styles overview</A> and <A HREF="wx_wxtextctrl.html#wxtextctrlctor">wxTextCtrl::wxTextCtrl</A>.<P>
Note that alignment styles (<B>wxTE_LEFT</B>, 
<B>wxTE_CENTRE</B> and <B>wxTE_RIGHT</B>) can be changed
dynamically after control creation on wxMSW and wxGTK. 
<B>wxTE_READONLY</B>, <B>wxTE_PASSWORD</B> and wrapping styles
can be dynamically changed under wxGTK but not wxMSW. The other styles can be
only set during control creation.<P>

<B><FONT COLOR="#FF0000">wxTextCtrl text format</FONT></B><P>
The multiline text controls always store the text as a sequence of lines
separated by <TT>\n</TT> characters, i.e. in the Unix text format even
on non-Unix platforms. This allows the user code to ignore the differences
between the platforms but at a price: the indices in the control such as those
returned by <A HREF="wx_wxtextctrl.html#wxtextctrlgetinsertionpoint">GetInsertionPoint</A> or
<A HREF="wx_wxtextctrl.html#wxtextctrlgetselection">GetSelection</A> can <B>not</B> be used as
indices into the string returned by <A HREF="wx_wxtextctrl.html#wxtextctrlgetvalue">GetValue</A> as
they're going to be slightly off for platforms using
<TT>\r\n</TT> as separator (as Windows does), for example.<P>
Instead, if you need to obtain a substring between the 2 indices obtained
from the control with the help of the functions mentioned above, you should
use <A HREF="wx_wxtextctrl.html#wxtextctrlgetrange">GetRange</A>. And the indices themselves can
only be passed to other methods, for example
<A HREF="wx_wxtextctrl.html#wxtextctrlsetinsertionpoint">SetInsertionPoint</A> or
<A HREF="wx_wxtextctrl.html#wxtextctrlsetselection">SetSelection</A>.<P>
To summarize: never use the indices returned by (multiline) wxTextCtrl as
indices into the string it contains, but only as arguments to be passed back
to the other wxTextCtrl methods.<P>
<B><FONT COLOR="#FF0000">wxTextCtrl styles</FONT></B><P>
Multi-line text controls support the styles, i.e. provide a possibility to set
colours and font for individual characters in it (note that under Windows <TT>
wxTE_RICH</TT> style is required for style support). To use the styles you can
either call <A HREF="wx_wxtextctrl.html#wxtextctrlsetdefaultstyle">SetDefaultStyle</A> before
inserting the text or call <A HREF="wx_wxtextctrl.html#wxtextctrlsetstyle">SetStyle</A> later to
change the style of the text already in the control (the first solution is
much more efficient).<P>
In either case, if the style doesn't specify some of the attributes (for
example you only want to set the text colour but without changing the font nor
the text background), the values of the default style will be used for them.
If there is no default style, the attributes of the text control itself are
used.<P>
So the following code correctly describes what it does: the second call
to <A HREF="wx_wxtextctrl.html#wxtextctrlsetdefaultstyle">SetDefaultStyle</A> doesn't change the
text foreground colour (which stays red) while the last one doesn't change the
background colour (which stays grey):<P>
<FONT SIZE=2><PRE>
    text-&gt;SetDefaultStyle(wxTextAttr(*wxRED));
    text-&gt;AppendText("Red text\n");
    text-&gt;SetDefaultStyle(wxTextAttr(wxNullColour, *wxLIGHT_GREY));
    text-&gt;AppendText("Red on grey text\n");
    text-&gt;SetDefaultStyle(wxTextAttr(*wxBLUE);
    text-&gt;AppendText("Blue on grey text\n");
</PRE>
</FONT><B><FONT COLOR="#FF0000">wxTextCtrl and C++ streams</FONT></B><P>
This class multiply-inherits from <B>streambuf</B> where compilers allow,
allowing code such as the following:<P>
<FONT SIZE=2><PRE>
  wxTextCtrl *control = new wxTextCtrl(...);

  ostream stream(control)

  stream &lt;&lt; 123.456 &lt;&lt; " some text\n";
  stream.flush();
</PRE>
</FONT>If your compiler does not support derivation from <B>streambuf</B> and gives a
compile error, define the symbol <B>NO_TEXT_WINDOW_STREAM</B> in the
wxTextCtrl header file.<P>
Note that independently of this setting you can always use wxTextCtrl itself
in a stream-like manner:<P>
<FONT SIZE=2><PRE>
  wxTextCtrl *control = new wxTextCtrl(...);

  *control &lt;&lt; 123.456 &lt;&lt; " some text\n";
</PRE>
</FONT>always works. However the possibility to create an ostream associated with
wxTextCtrl may be useful if you need to redirect the output of a function
taking an ostream as parameter to a text control.<P>
Another commonly requested need is to redirect <B>std::cout</B> to the text
control. This could be done in the following way:<P>
<FONT SIZE=2><PRE>
  #include &lt;iostream&gt;

  wxTextCtrl *control = new wxTextCtrl(...);

  std::streambuf *sbOld = std::cout.rdbuf();
  std::cout.rdbuf(control);

  // use cout as usual, the output appears in the text control
  ...

  std::cout.rdbuf(sbOld);
</PRE>
</FONT>But wxWidgets provides a convenient class to make it even simpler so instead
you may just do<P>
<FONT SIZE=2><PRE>
  #include &lt;iostream&gt;

  wxTextCtrl *control = new wxTextCtrl(...);

  wxStreamToTextRedirector redirect(control);

  // all output to cout goes into the text control until the exit from current
  // scope
</PRE>
</FONT>See <A HREF="wx_wxstreamtotextredirector.html#wxstreamtotextredirector">wxStreamToTextRedirector</A> for more
details.<P>
<B><FONT COLOR="#FF0000">Constants</FONT></B><P>
The values below are the possible return codes of the
<A HREF="wx_wxtextctrl.html#wxtextctrlhittest">HitTest</A> method:<P>
<FONT SIZE=2>
<PRE>
// the point asked is ...
enum wxTextCtrlHitTestResult
{
    wxTE_HT_UNKNOWN = -2,   // this means HitTest() is simply not implemented
    wxTE_HT_BEFORE,         // either to the left or upper
    wxTE_HT_ON_TEXT,        // directly on
    wxTE_HT_BELOW,          // below [the last line]
    wxTE_HT_BEYOND          // after [the end of line]
};
// ... the character returned
</PRE>
</FONT><P>

<B><FONT COLOR="#FF0000">Event handling</FONT></B><P>
The following commands are processed by default event handlers in wxTextCtrl: wxID_CUT, wxID_COPY,
wxID_PASTE, wxID_UNDO, wxID_REDO. The associated UI update events are also processed
automatically, when the control has the focus.<P>
To process input from a text control, use these event handler macros to direct input to member
functions that take a <A HREF="wx_wxcommandevent.html#wxcommandevent">wxCommandEvent</A> argument.<P>

<TABLE>


<TR><TD VALIGN=TOP WIDTH=277>
<B>EVT_TEXT(id, func)</B>
</FONT></TD>

<TD VALIGN=TOP>
Respond to a wxEVT_COMMAND_TEXT_UPDATED event,
generated when the text changes. Notice that this event will be sent
when the text controls contents changes - whether this is due to user input or
comes from the program itself (for example, if SetValue() is called); see ChangeValue() for
a function which does not send this event.
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=277>
<B>EVT_TEXT_ENTER(id, func)</B>
</FONT></TD>

<TD VALIGN=TOP>
Respond to a wxEVT_COMMAND_TEXT_ENTER event,
generated when enter is pressed in a text control (which must have
wxTE_PROCESS_ENTER style for this event to be generated).
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=277>
<B>EVT_TEXT_URL(id, func)</B>
</FONT></TD>

<TD VALIGN=TOP>
A mouse event occurred over an URL
in the text control (wxMSW and wxGTK2 only)
</FONT></TD></TR>


<TR><TD VALIGN=TOP WIDTH=277>
<B>EVT_TEXT_MAXLEN(id, func)</B>
</FONT></TD>

<TD VALIGN=TOP>
User tried to enter more text
into the control than the limit set by
<A HREF="wx_wxtextctrl.html#wxtextctrlsetmaxlength">SetMaxLength</A>.
</FONT></TD></TR>


</TABLE>
<B><FONT COLOR="#FF0000">Members</FONT></B><P>

<A HREF="#wxtextctrlctor">wxTextCtrl::wxTextCtrl</A><BR>
<A HREF="#wxtextctrldtor">wxTextCtrl::~wxTextCtrl</A><BR>
<A HREF="#wxtextctrlappendtext">wxTextCtrl::AppendText</A><BR>
<A HREF="#wxtextctrlcancopy">wxTextCtrl::CanCopy</A><BR>
<A HREF="#wxtextctrlcancut">wxTextCtrl::CanCut</A><BR>
<A HREF="#wxtextctrlcanpaste">wxTextCtrl::CanPaste</A><BR>
<A HREF="#wxtextctrlcanredo">wxTextCtrl::CanRedo</A><BR>
<A HREF="#wxtextctrlcanundo">wxTextCtrl::CanUndo</A><BR>
<A HREF="#wxtextctrlclear">wxTextCtrl::Clear</A><BR>
<A HREF="#wxtextctrlcopy">wxTextCtrl::Copy</A><BR>
<A HREF="#wxtextctrlcreate">wxTextCtrl::Create</A><BR>
<A HREF="#wxtextctrlcut">wxTextCtrl::Cut</A><BR>
<A HREF="#wxtextctrldiscardedits">wxTextCtrl::DiscardEdits</A><BR>
<A HREF="#wxtextctrlemulatekeypress">wxTextCtrl::EmulateKeyPress</A><BR>
<A HREF="#wxtextctrlgetdefaultstyle">wxTextCtrl::GetDefaultStyle</A><BR>
<A HREF="#wxtextctrlgetinsertionpoint">wxTextCtrl::GetInsertionPoint</A><BR>
<A HREF="#wxtextctrlgetlastposition">wxTextCtrl::GetLastPosition</A><BR>
<A HREF="#wxtextctrlgetlinelength">wxTextCtrl::GetLineLength</A><BR>
<A HREF="#wxtextctrlgetlinetext">wxTextCtrl::GetLineText</A><BR>
<A HREF="#wxtextctrlgetnumberoflines">wxTextCtrl::GetNumberOfLines</A><BR>
<A HREF="#wxtextctrlgetrange">wxTextCtrl::GetRange</A><BR>
<A HREF="#wxtextctrlgetselection">wxTextCtrl::GetSelection</A><BR>
<A HREF="#wxtextctrlgetstringselection">wxTextCtrl::GetStringSelection</A><BR>
<A HREF="#wxtextctrlgetstyle">wxTextCtrl::GetStyle</A><BR>
<A HREF="#wxtextctrlgetvalue">wxTextCtrl::GetValue</A><BR>
<A HREF="#wxtextctrlhittest">wxTextCtrl::HitTest</A><BR>
<A HREF="#wxtextctrliseditable">wxTextCtrl::IsEditable</A><BR>
<A HREF="#wxtextctrlisempty">wxTextCtrl::IsEmpty</A><BR>
<A HREF="#wxtextctrlismodified">wxTextCtrl::IsModified</A><BR>
<A HREF="#wxtextctrlismultiline">wxTextCtrl::IsMultiLine</A><BR>
<A HREF="#wxtextctrlissingleline">wxTextCtrl::IsSingleLine</A><BR>
<A HREF="#wxtextctrlloadfile">wxTextCtrl::LoadFile</A><BR>
<A HREF="#wxtextctrlmarkdirty">wxTextCtrl::MarkDirty</A><BR>
<A HREF="#wxtextctrlondropfiles">wxTextCtrl::OnDropFiles</A><BR>
<A HREF="#wxtextctrlpaste">wxTextCtrl::Paste</A><BR>
<A HREF="#wxtextctrlpositiontoxy">wxTextCtrl::PositionToXY</A><BR>
<A HREF="#wxtextctrlredo">wxTextCtrl::Redo</A><BR>
<A HREF="#wxtextctrlremove">wxTextCtrl::Remove</A><BR>
<A HREF="#wxtextctrlreplace">wxTextCtrl::Replace</A><BR>
<A HREF="#wxtextctrlsavefile">wxTextCtrl::SaveFile</A><BR>
<A HREF="#wxtextctrlsetdefaultstyle">wxTextCtrl::SetDefaultStyle</A><BR>
<A HREF="#wxtextctrlseteditable">wxTextCtrl::SetEditable</A><BR>
<A HREF="#wxtextctrlsetinsertionpoint">wxTextCtrl::SetInsertionPoint</A><BR>
<A HREF="#wxtextctrlsetinsertionpointend">wxTextCtrl::SetInsertionPointEnd</A><BR>
<A HREF="#wxtextctrlsetmaxlength">wxTextCtrl::SetMaxLength</A><BR>
<A HREF="#wxtextctrlsetmodified">wxTextCtrl::SetModified</A><BR>
<A HREF="#wxtextctrlsetselection">wxTextCtrl::SetSelection</A><BR>
<A HREF="#wxtextctrlsetstyle">wxTextCtrl::SetStyle</A><BR>
<A HREF="#wxtextctrlsetvalue">wxTextCtrl::SetValue</A><BR>
<A HREF="#wxtextctrlchangevalue">wxTextCtrl::ChangeValue</A><BR>
<A HREF="#wxtextctrlshowposition">wxTextCtrl::ShowPosition</A><BR>
<A HREF="#wxtextctrlundo">wxTextCtrl::Undo</A><BR>
<A HREF="#wxtextctrlwritetext">wxTextCtrl::WriteText</A><BR>
<A HREF="#wxtextctrlxytoposition">wxTextCtrl::XYToPosition</A><BR>
<A HREF="#wxtextctrlinsert">wxTextCtrl::operator &lt;&lt;</A><BR>
<P>

<HR>
<A NAME="wxtextctrlctor"></A>
<H3>wxTextCtrl::wxTextCtrl</H3>
<P>
<B></B> <B>wxTextCtrl</B>()<P>
Default constructor.<P>
<B></B> <B>wxTextCtrl</B>(<B><A HREF="wx_wxwindow.html#wxwindow">wxWindow</A>* </B></B><I>parent</I>, <B>wxWindowID</B><I> id</I>,
<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I>value = ""</I>, <B>const <A HREF="wx_wxpoint.html#wxpoint">wxPoint</A>& </B></B><I>pos = wxDefaultPosition</I>, <B>const <A HREF="wx_wxsize.html#wxsize">wxSize</A>& </B></B><I>size = wxDefaultSize</I>,
<B>long</B><I> style = 0</I>, <B>const <A HREF="wx_wxvalidator.html#wxvalidator">wxValidator</A>& </B></B><I>validator = wxDefaultValidator</I>, <B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I>name = wxTextCtrlNameStr</I>)<P>
Constructor, creating and showing a text control.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>parent</I><UL><UL>
Parent window. Should not be NULL.</UL></UL>
<P>
<I>id</I><UL><UL>
Control identifier. A value of -1 denotes a default value.</UL></UL>
<P>
<I>value</I><UL><UL>
Default text value.</UL></UL>
<P>
<I>pos</I><UL><UL>
Text control position.</UL></UL>
<P>
<I>size</I><UL><UL>
Text control size.</UL></UL>
<P>
<I>style</I><UL><UL>
Window style. See <A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A>.</UL></UL>
<P>
<I>validator</I><UL><UL>
Window validator.</UL></UL>
<P>
<I>name</I><UL><UL>
Window name.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
The horizontal scrollbar (<B>wxHSCROLL</B> style flag) will only be created
for multi-line text controls.
Without a horizontal scrollbar, text lines that don't fit in the control's
size will be wrapped (but no newline character is inserted). Single line
controls don't have a horizontal scrollbar, the text is automatically scrolled
so that the <A HREF="wx_wxtextctrl.html#wxtextctrlgetinsertionpoint">insertion point</A> is always
visible.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlcreate">wxTextCtrl::Create</A>, <A HREF="wx_wxvalidator.html#wxvalidator">wxValidator</A><P>


<HR>
<A NAME="wxtextctrldtor"></A>
<H3>wxTextCtrl::~wxTextCtrl</H3>
<P>
<B></B> <B>~wxTextCtrl</B>()<P>
Destructor, destroying the text control.<P>


<HR>
<A NAME="wxtextctrlappendtext"></A>
<H3>wxTextCtrl::AppendText</H3>
<P>
<B>void</B> <B>AppendText</B>(<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I> text</I>)<P>
Appends the text to the end of the text control.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>text</I><UL><UL>
Text to write to the text control.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
After the text is appended, the insertion point will be at the end of the text control. If this behaviour is not desired,
the programmer should use <A HREF="wx_wxtextctrl.html#wxtextctrlgetinsertionpoint">GetInsertionPoint</A> and <A HREF="wx_wxtextctrl.html#wxtextctrlsetinsertionpoint">SetInsertionPoint</A>.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlwritetext">wxTextCtrl::WriteText</A><P>


<HR>
<A NAME="wxtextctrlcancopy"></A>
<H3>wxTextCtrl::CanCopy</H3>
<P>
<B>virtual bool</B> <B>CanCopy</B>()<P>
Returns <TT>true</TT> if the selection can be copied to the clipboard.<P>


<HR>
<A NAME="wxtextctrlcancut"></A>
<H3>wxTextCtrl::CanCut</H3>
<P>
<B>virtual bool</B> <B>CanCut</B>()<P>
Returns <TT>true</TT> if the selection can be cut to the clipboard.<P>


<HR>
<A NAME="wxtextctrlcanpaste"></A>
<H3>wxTextCtrl::CanPaste</H3>
<P>
<B>virtual bool</B> <B>CanPaste</B>()<P>
Returns <TT>true</TT> if the contents of the clipboard can be pasted into the
text control. On some platforms (Motif, GTK) this is an approximation
and returns <TT>true</TT> if the control is editable, <TT>false</TT> otherwise.<P>


<HR>
<A NAME="wxtextctrlcanredo"></A>
<H3>wxTextCtrl::CanRedo</H3>
<P>
<B>virtual bool</B> <B>CanRedo</B>()<P>
Returns <TT>true</TT> if there is a redo facility available and the last operation
can be redone.<P>


<HR>
<A NAME="wxtextctrlcanundo"></A>
<H3>wxTextCtrl::CanUndo</H3>
<P>
<B>virtual bool</B> <B>CanUndo</B>()<P>
Returns <TT>true</TT> if there is an undo facility available and the last operation
can be undone.<P>


<HR>
<A NAME="wxtextctrlclear"></A>
<H3>wxTextCtrl::Clear</H3>
<P>
<B>virtual void</B> <B>Clear</B>()<P>
Clears the text in the control.<P>
Note that this function will generate a <TT>wxEVT_COMMAND_TEXT_UPDATED</TT>
event.<P>


<HR>
<A NAME="wxtextctrlcopy"></A>
<H3>wxTextCtrl::Copy</H3>
<P>
<B>virtual void</B> <B>Copy</B>()<P>
Copies the selected text to the clipboard under Motif and MS Windows.<P>


<HR>
<A NAME="wxtextctrlcreate"></A>
<H3>wxTextCtrl::Create</H3>
<P>
<B>bool</B> <B>Create</B>(<B><A HREF="wx_wxwindow.html#wxwindow">wxWindow</A>* </B></B><I>parent</I>, <B>wxWindowID</B><I> id</I>,
<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I>value = ""</I>, <B>const <A HREF="wx_wxpoint.html#wxpoint">wxPoint</A>& </B></B><I>pos = wxDefaultPosition</I>, <B>const <A HREF="wx_wxsize.html#wxsize">wxSize</A>& </B></B><I>size = wxDefaultSize</I>,
<B>long</B><I> style = 0</I>, <B>const <A HREF="wx_wxvalidator.html#wxvalidator">wxValidator</A>& </B></B><I>validator = wxDefaultValidator</I>, <B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I>name = wxTextCtrlNameStr</I>)<P>
Creates the text control for two-step construction. Derived classes
should call or replace this function. See <A HREF="wx_wxtextctrl.html#wxtextctrlctor">wxTextCtrl::wxTextCtrl</A>
for further details.<P>


<HR>
<A NAME="wxtextctrlcut"></A>
<H3>wxTextCtrl::Cut</H3>
<P>
<B>virtual void</B> <B>Cut</B>()<P>
Copies the selected text to the clipboard and removes the selection.<P>


<HR>
<A NAME="wxtextctrldiscardedits"></A>
<H3>wxTextCtrl::DiscardEdits</H3>
<P>
<B>void</B> <B>DiscardEdits</B>()<P>
Resets the internal 'modified' flag as if the current edits had been saved.<P>


<HR>
<A NAME="wxtextctrlemulatekeypress"></A>
<H3>wxTextCtrl::EmulateKeyPress</H3>
<P>
<B>bool</B> <B>EmulateKeyPress</B>(<B>const <A HREF="wx_wxkeyevent.html#wxkeyevent">wxKeyEvent</A>& </B></B><I>event</I>)<P>
This functions inserts into the control the character which would have been
inserted if the given key event had occurred in the text control. The
<I>event</I> object should be the same as the one passed to <TT>EVT_KEY_DOWN</TT>
handler previously by wxWidgets.<P>
Please note that this function doesn't currently work correctly for all keys
under any platform but MSW.<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
<TT>true</TT> if the event resulted in a change to the control, <TT>false</TT>
otherwise.<P>


<HR>
<A NAME="wxtextctrlgetdefaultstyle"></A>
<H3>wxTextCtrl::GetDefaultStyle</H3>
<P>
<B>const <A HREF="wx_wxtextattr.html#wxtextattr">wxTextAttr</A>& </B> </B> <B>GetDefaultStyle</B>() <B>const</B><P>
Returns the style currently used for the new text.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlsetdefaultstyle">SetDefaultStyle</A><P>


<HR>
<A NAME="wxtextctrlgetinsertionpoint"></A>
<H3>wxTextCtrl::GetInsertionPoint</H3>
<P>
<B>virtual long</B> <B>GetInsertionPoint</B>() <B>const</B><P>
Returns the insertion point. This is defined as the zero based index of the
character position to the right of the insertion point. For example, if
the insertion point is at the end of the text control, it is equal to
both <A HREF="wx_wxtextctrl.html#wxtextctrlgetvalue">GetValue()</A>.Length() and
<A HREF="wx_wxtextctrl.html#wxtextctrlgetlastposition">GetLastPosition()</A>.<P>
The following code snippet safely returns the character at the insertion
point or the zero character if the point is at the end of the control.<P>
<FONT SIZE=2><PRE>
  char GetCurrentChar(wxTextCtrl *tc) {
    if (tc-&gt;GetInsertionPoint() == tc-&gt;GetLastPosition())
      return '\0';
    return tc-&gt;GetValue[tc-&gt;GetInsertionPoint()];
  }
</PRE>
</FONT>

<HR>
<A NAME="wxtextctrlgetlastposition"></A>
<H3>wxTextCtrl::GetLastPosition</H3>
<P>
<B>virtual wxTextPos</B> <B>GetLastPosition</B>() <B>const</B><P>
Returns the zero based index of the last position in the text control,
which is equal to the number of characters in the control.<P>


<HR>
<A NAME="wxtextctrlgetlinelength"></A>
<H3>wxTextCtrl::GetLineLength</H3>
<P>
<B>int</B> <B>GetLineLength</B>(<B>long</B><I> lineNo</I>) <B>const</B><P>
Gets the length of the specified line, not including any trailing newline
character(s).<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>lineNo</I><UL><UL>
Line number (starting from zero).</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
The length of the line, or -1 if <I>lineNo</I> was invalid.<P>


<HR>
<A NAME="wxtextctrlgetlinetext"></A>
<H3>wxTextCtrl::GetLineText</H3>
<P>
<B><A HREF="wx_wxstring.html#wxstring">wxString</A></B> </B> <B>GetLineText</B>(<B>long</B><I> lineNo</I>) <B>const</B><P>
Returns the contents of a given line in the text control, not including
any trailing newline character(s).<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>lineNo</I><UL><UL>
The line number, starting from zero.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
The contents of the line.<P>


<HR>
<A NAME="wxtextctrlgetnumberoflines"></A>
<H3>wxTextCtrl::GetNumberOfLines</H3>
<P>
<B>int</B> <B>GetNumberOfLines</B>() <B>const</B><P>
Returns the number of lines in the text control buffer.<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
Note that even empty text controls have one line (where the insertion point
is), so GetNumberOfLines() never returns 0.<P>
For wxGTK using GTK+ 1.2.x and earlier, the number of lines in a multi-line
text control is calculated by actually counting newline characters in the
buffer, i.e. this function returns the number of logical lines and doesn't
depend on whether any of them are wrapped. For all the other platforms, the
number of physical lines in the control is returned.<P>
Also note that you may wish to avoid using functions that work with line
numbers if you are working with controls that contain large amounts of text as
this function has O(N) complexity for N being the number of lines.<P>


<HR>
<A NAME="wxtextctrlgetrange"></A>
<H3>wxTextCtrl::GetRange</H3>
<P>
<B>virtual <A HREF="wx_wxstring.html#wxstring">wxString</A></B> </B> <B>GetRange</B>(<B>long</B><I> from</I>, <B>long</B><I> to</I>) <B>const</B><P>
Returns the string containing the text starting in the positions <I>from</I> and
up to <I>to</I> in the control. The positions must have been returned by another
wxTextCtrl method.<P>
Please note that the positions in a multiline wxTextCtrl do <B>not</B>
correspond to the indices in the string returned by
<A HREF="wx_wxtextctrl.html#wxtextctrlgetvalue">GetValue</A> because of the different new line
representations (<TT>CR</TT> or <TT>CR LF</TT>) and so this method should be used to
obtain the correct results instead of extracting parts of the entire value. It
may also be more efficient, especially if the control contains a lot of data.<P>


<HR>
<A NAME="wxtextctrlgetselection"></A>
<H3>wxTextCtrl::GetSelection</H3>
<P>
<B>virtual void</B> <B>GetSelection</B>(<B>long*</B><I> from</I>, <B>long*</B><I> to</I>) <B>const</B><P>
Gets the current selection span. If the returned values are equal, there was
no selection.<P>
Please note that the indices returned may be used with the other wxTextctrl
methods but don't necessarily represent the correct indices into the string
returned by <A HREF="wx_wxtextctrl.html#wxtextctrlgetvalue">GetValue()</A> for multiline controls
under Windows (at least,) you should use
<A HREF="wx_wxtextctrl.html#wxtextctrlgetstringselection">GetStringSelection()</A> to get the selected
text.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>from</I><UL><UL>
The returned first position.</UL></UL>
<P>
<I>to</I><UL><UL>
The returned last position.</UL></UL>
<P>
<B><FONT COLOR="#0000C8">wxPython note:</FONT></B> The wxPython version of this method returns a tuple
consisting of the from and to values.<P>
<B><FONT COLOR="#0000C8">wxPerl note:</FONT></B> In wxPerl this method takes no parameter and returns a
2-element list <TT>( from, to )</TT>.<P>


<HR>
<A NAME="wxtextctrlgetstringselection"></A>
<H3>wxTextCtrl::GetStringSelection</H3>
<P>
<B>virtual <A HREF="wx_wxstring.html#wxstring">wxString</A></B> </B> <B>GetStringSelection</B>()<P>
Gets the text currently selected in the control. If there is no selection, the
returned string is empty.<P>


<HR>
<A NAME="wxtextctrlgetstyle"></A>
<H3>wxTextCtrl::GetStyle</H3>
<P>
<B>bool</B> <B>GetStyle</B>(<B>long </B><I>position</I>, <B><A HREF="wx_wxtextattr.html#wxtextattr">wxTextAttr</A>& </B></B><I>style</I>)<P>
Returns the style at this position in the text control. Not all platforms
support this function.<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
<TT>true</TT> on success, <TT>false</TT> if an error occurred - it may also mean that
the styles are not supported under this platform.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlsetstyle">wxTextCtrl::SetStyle</A>, <A HREF="wx_wxtextattr.html#wxtextattr">wxTextAttr</A><P>


<HR>
<A NAME="wxtextctrlgetvalue"></A>
<H3>wxTextCtrl::GetValue</H3>
<P>
<B><A HREF="wx_wxstring.html#wxstring">wxString</A></B> </B> <B>GetValue</B>() <B>const</B><P>
Gets the contents of the control. Notice that for a multiline text control,
the lines will be separated by (Unix-style) \n characters, even
under Windows where they are separated by a \r\n
sequence in the native control.<P>


<HR>
<A NAME="wxtextctrlhittest"></A>
<H3>wxTextCtrl::HitTest</H3>
<P>
<B>wxTextCtrlHitTestResult</B> <B>HitTest</B>(<B>const <A HREF="wx_wxpoint.html#wxpoint">wxPoint</A>& </B></B><I>pt</I>, <B>wxTextCoord </B><I>*col</I>, <B>wxTextCoord </B><I>*row</I>) <B>const</B><P>
This function finds the character at the specified position expressed in
pixels. If the return code is not <TT>wxTE_HT_UNKNOWN</TT> the row and column
of the character closest to this position are returned in the <I>col</I> and
<I>row</I> parameters (unless the pointers are <TT>NULL</TT> which is allowed).<P>
Please note that this function is currently only implemented in wxUniv,
wxMSW and wxGTK2 ports.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlpositiontoxy">PositionToXY</A>, <A HREF="wx_wxtextctrl.html#wxtextctrlxytoposition">XYToPosition</A><P>
<B><FONT COLOR="#0000C8">wxPerl note:</FONT></B> In wxPerl this function takes only the position argument and
returns a 3-element list <TT>(result, col, row)</TT>.<P>


<HR>
<A NAME="wxtextctrliseditable"></A>
<H3>wxTextCtrl::IsEditable</H3>
<P>
<B>bool</B> <B>IsEditable</B>() <B>const</B><P>
Returns <TT>true</TT> if the controls contents may be edited by user (note that it
always can be changed by the program), i.e. if the control hasn't been put in
read-only mode by a previous call to
<A HREF="wx_wxtextctrl.html#wxtextctrlseteditable">SetEditable</A>.<P>


<HR>
<A NAME="wxtextctrlisempty"></A>
<H3>wxTextCtrl::IsEmpty</H3>
<P>
<B>bool</B> <B>IsEmpty</B>() <B>const</B><P>
Returns <TT>true</TT> if the control is currently empty. This is the same as 
<TT>GetValue().empty()</TT> but can be much more efficient for the multiline
controls containing big amounts of text.<P>
This function is new since wxWidgets version 2.7.1<P>


<HR>
<A NAME="wxtextctrlismodified"></A>
<H3>wxTextCtrl::IsModified</H3>
<P>
<B>bool</B> <B>IsModified</B>() <B>const</B><P>
Returns <TT>true</TT> if the text has been modified by user. Note that calling
<A HREF="wx_wxtextctrl.html#wxtextctrlsetvalue">SetValue</A> doesn't make the control modified.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlmarkdirty">MarkDirty</A><P>


<HR>
<A NAME="wxtextctrlismultiline"></A>
<H3>wxTextCtrl::IsMultiLine</H3>
<P>
<B>bool</B> <B>IsMultiLine</B>() <B>const</B><P>
Returns <TT>true</TT> if this is a multi line edit control and <TT>false</TT>
otherwise.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlissingleline">IsSingleLine</A><P>


<HR>
<A NAME="wxtextctrlissingleline"></A>
<H3>wxTextCtrl::IsSingleLine</H3>
<P>
<B>bool</B> <B>IsSingleLine</B>() <B>const</B><P>
Returns <TT>true</TT> if this is a single line edit control and <TT>false</TT>
otherwise.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlissingleline">IsMultiLine</A><P>


<HR>
<A NAME="wxtextctrlloadfile"></A>
<H3>wxTextCtrl::LoadFile</H3>
<P>
<B>bool</B> <B>LoadFile</B>(<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I> filename</I>, <B>int </B><I>fileType = wxTEXT_TYPE_ANY</I>)<P>
Loads and displays the named file, if it exists.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>filename</I><UL><UL>
The filename of the file to load.</UL></UL>
<P>
<I>fileType</I><UL><UL>
The type of file to load. This is currently ignored in wxTextCtrl.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
<TT>true</TT> if successful, <TT>false</TT> otherwise.<P>


<HR>
<A NAME="wxtextctrlmarkdirty"></A>
<H3>wxTextCtrl::MarkDirty</H3>
<P>
<B>void</B> <B>MarkDirty</B>()<P>
Mark text as modified (dirty).<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlismodified">IsModified</A><P>


<HR>
<A NAME="wxtextctrlondropfiles"></A>
<H3>wxTextCtrl::OnDropFiles</H3>
<P>
<B>void</B> <B>OnDropFiles</B>(<B><A HREF="wx_wxdropfilesevent.html#wxdropfilesevent">wxDropFilesEvent</A>& </B></B><I>event</I>)<P>
This event handler function implements default drag and drop behaviour, which
is to load the first dropped file into the control.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>event</I><UL><UL>
The drop files event.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
This is not implemented on non-Windows platforms.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxdropfilesevent.html#wxdropfilesevent">wxDropFilesEvent</A><P>


<HR>
<A NAME="wxtextctrlpaste"></A>
<H3>wxTextCtrl::Paste</H3>
<P>
<B>virtual void</B> <B>Paste</B>()<P>
Pastes text from the clipboard to the text item.<P>


<HR>
<A NAME="wxtextctrlpositiontoxy"></A>
<H3>wxTextCtrl::PositionToXY</H3>
<P>
<B>bool</B> <B>PositionToXY</B>(<B>long </B><I>pos</I>, <B>long *</B><I>x</I>, <B>long *</B><I>y</I>) <B>const</B><P>
Converts given position to a zero-based column, line number pair.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>pos</I><UL><UL>
Position.</UL></UL>
<P>
<I>x</I><UL><UL>
Receives zero based column number.</UL></UL>
<P>
<I>y</I><UL><UL>
Receives zero based line number.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
<TT>true</TT> on success, <TT>false</TT> on failure (most likely due to a too large position
parameter).<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlxytoposition">wxTextCtrl::XYToPosition</A><P>
<B><FONT COLOR="#0000C8">wxPython note:</FONT></B> In Python, PositionToXY() returns a tuple containing the x and
y values, so (x,y) = PositionToXY() is equivalent to the call described
above.<P>
<B><FONT COLOR="#0000C8">wxPerl note:</FONT></B> In wxPerl this method only takes the <TT>pos</TT> parameter, and
returns a 2-element list <TT>( x, y )</TT>.<P>


<HR>
<A NAME="wxtextctrlredo"></A>
<H3>wxTextCtrl::Redo</H3>
<P>
<B>virtual void</B> <B>Redo</B>()<P>
If there is a redo facility and the last operation can be redone, redoes the last operation. Does nothing
if there is no redo facility.<P>


<HR>
<A NAME="wxtextctrlremove"></A>
<H3>wxTextCtrl::Remove</H3>
<P>
<B>virtual void</B> <B>Remove</B>(<B>long</B><I> from</I>, <B>long</B><I> to</I>)<P>
Removes the text starting at the first given position up to (but not including)
the character at the last position.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>from</I><UL><UL>
The first position.</UL></UL>
<P>
<I>to</I><UL><UL>
The last position.</UL></UL>
<P>


<HR>
<A NAME="wxtextctrlreplace"></A>
<H3>wxTextCtrl::Replace</H3>
<P>
<B>virtual void</B> <B>Replace</B>(<B>long</B><I> from</I>, <B>long</B><I> to</I>, <B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I>value</I>)<P>
Replaces the text starting at the first position up to (but not including)
the character at the last position with the given text.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>from</I><UL><UL>
The first position.</UL></UL>
<P>
<I>to</I><UL><UL>
The last position.</UL></UL>
<P>
<I>value</I><UL><UL>
The value to replace the existing text with.</UL></UL>
<P>


<HR>
<A NAME="wxtextctrlsavefile"></A>
<H3>wxTextCtrl::SaveFile</H3>
<P>
<B>bool</B> <B>SaveFile</B>(<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I> filename</I>, <B>int </B><I>fileType = wxTEXT_TYPE_ANY</I>)<P>
Saves the contents of the control in a text file.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>filename</I><UL><UL>
The name of the file in which to save the text.</UL></UL>
<P>
<I>fileType</I><UL><UL>
The type of file to save. This is currently ignored in wxTextCtrl.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
<TT>true</TT> if the operation was successful, <TT>false</TT> otherwise.<P>


<HR>
<A NAME="wxtextctrlsetdefaultstyle"></A>
<H3>wxTextCtrl::SetDefaultStyle</H3>
<P>
<B>bool</B> <B>SetDefaultStyle</B>(<B>const <A HREF="wx_wxtextattr.html#wxtextattr">wxTextAttr</A>& </B></B><I>style</I>)<P>
Changes the default style to use for the new text which is going to be added
to the control using <A HREF="wx_wxtextctrl.html#wxtextctrlwritetext">WriteText</A> or
<A HREF="wx_wxtextctrl.html#wxtextctrlappendtext">AppendText</A>.<P>
If either of the font, foreground, or background colour is not set in
<I>style</I>, the values of the previous default style are used for them. If
the previous default style didn't set them neither, the global font or colours
of the text control itself are used as fall back.<P>
However if the <I>style</I> parameter is the default wxTextAttr, then the
default style is just reset (instead of being combined with the new style which
wouldn't change it at all).<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>style</I><UL><UL>
The style for the new text.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
<TT>true</TT> on success, <TT>false</TT> if an error occurred - may also mean that
the styles are not supported under this platform.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlgetdefaultstyle">GetDefaultStyle</A><P>


<HR>
<A NAME="wxtextctrlseteditable"></A>
<H3>wxTextCtrl::SetEditable</H3>
<P>
<B>virtual void</B> <B>SetEditable</B>(<B>const bool</B><I> editable</I>)<P>
Makes the text item editable or read-only, overriding the <B>wxTE_READONLY</B> flag.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>editable</I><UL><UL>
If <TT>true</TT>, the control is editable. If <TT>false</TT>, the control is read-only.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrliseditable">IsEditable</A><P>


<HR>
<A NAME="wxtextctrlsetinsertionpoint"></A>
<H3>wxTextCtrl::SetInsertionPoint</H3>
<P>
<B>virtual void</B> <B>SetInsertionPoint</B>(<B>long</B><I> pos</I>)<P>
Sets the insertion point at the given position.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>pos</I><UL><UL>
Position to set.</UL></UL>
<P>


<HR>
<A NAME="wxtextctrlsetinsertionpointend"></A>
<H3>wxTextCtrl::SetInsertionPointEnd</H3>
<P>
<B>virtual void</B> <B>SetInsertionPointEnd</B>()<P>
Sets the insertion point at the end of the text control. This is equivalent
to <A HREF="wx_wxtextctrl.html#wxtextctrlsetinsertionpoint">SetInsertionPoint</A>(<A HREF="wx_wxtextctrl.html#wxtextctrlgetlastposition">GetLastPosition</A>()).<P>


<HR>
<A NAME="wxtextctrlsetmaxlength"></A>
<H3>wxTextCtrl::SetMaxLength</H3>
<P>
<B>virtual void</B> <B>SetMaxLength</B>(<B>unsigned long </B><I>len</I>)<P>
This function sets the maximum number of characters the user can enter into the
control. In other words, it allows to limit the text value length to <I>len</I>
not counting the terminating <TT>NUL</TT> character.<P>
If <I>len</I> is 0, the previously set max length limit, if any, is discarded
and the user may enter as much text as the underlying native text control
widget supports (typically at least 32Kb).<P>
If the user tries to enter more characters into the text control when it
already is filled up to the maximal length, a
<TT>wxEVT_COMMAND_TEXT_MAXLEN</TT> event is sent to notify the program about it
(giving it the possibility to show an explanatory message, for example) and the
extra input is discarded.<P>
Note that under GTK+, this function may only be used with single line text controls.<P>
<B><FONT COLOR="#FF0000">Compatibility</FONT></B><P>
Only implemented in wxMSW/wxGTK starting with wxWidgets 2.3.2.<P>


<HR>
<A NAME="wxtextctrlsetmodified"></A>
<H3>wxTextCtrl::SetModified</H3>
<P>
<B>void</B> <B>SetModified</B>(<B>bool </B><I>modified</I>)<P>
Marks the control as being modified by the user or not.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlmarkdirty">MarkDirty</A>, <A HREF="wx_wxtextctrl.html#wxtextctrldiscardedits">DiscardEdits</A><P>


<HR>
<A NAME="wxtextctrlsetselection"></A>
<H3>wxTextCtrl::SetSelection</H3>
<P>
<B>virtual void</B> <B>SetSelection</B>(<B>long</B><I> from</I>, <B>long</B><I> to</I>)<P>
Selects the text starting at the first position up to (but not including) the
character at the last position. If both parameters are equal to -1 all text
in the control is selected.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>from</I><UL><UL>
The first position.</UL></UL>
<P>
<I>to</I><UL><UL>
The last position.</UL></UL>
<P>


<HR>
<A NAME="wxtextctrlsetstyle"></A>
<H3>wxTextCtrl::SetStyle</H3>
<P>
<B>bool</B> <B>SetStyle</B>(<B>long </B><I>start</I>, <B>long </B><I>end</I>, <B>const <A HREF="wx_wxtextattr.html#wxtextattr">wxTextAttr</A>& </B></B><I>style</I>)<P>
Changes the style of the given range. If any attribute within <I>style</I> is
not set, the corresponding attribute from <A HREF="wx_wxtextctrl.html#wxtextctrlgetdefaultstyle">GetDefaultStyle()</A> is used.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>start</I><UL><UL>
The start of the range to change.</UL></UL>
<P>
<I>end</I><UL><UL>
The end of the range to change.</UL></UL>
<P>
<I>style</I><UL><UL>
The new style for the range.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
<TT>true</TT> on success, <TT>false</TT> if an error occurred - it may also mean that
the styles are not supported under this platform.<P>
<B><FONT COLOR="#FF0000">See also</FONT></B><P>
<A HREF="wx_wxtextctrl.html#wxtextctrlgetstyle">wxTextCtrl::GetStyle</A>, <A HREF="wx_wxtextattr.html#wxtextattr">wxTextAttr</A><P>


<HR>
<A NAME="wxtextctrlsetvalue"></A>
<H3>wxTextCtrl::SetValue</H3>
<P>
<B>virtual void</B> <B>SetValue</B>(<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I> value</I>)<P>
Sets the text value and marks the control as not-modified (which means that
<A HREF="wx_wxtextctrl.html#wxtextctrlismodified">IsModified</A> would return <TT>false</TT> immediately
after the call to SetValue).<P>
Note that this function will generate a <TT>wxEVT_COMMAND_TEXT_UPDATED</TT>
event.<P>
This function is deprecated and should not be used in new code. Please use the
<A HREF="wx_wxtextctrl.html#wxtextctrlchangevalue">ChangeValue</A> function instead.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>value</I><UL><UL>
The new value to set. It may contain newline characters if the text control is multi-line.</UL></UL>
<P>


<HR>
<A NAME="wxtextctrlchangevalue"></A>
<H3>wxTextCtrl::ChangeValue</H3>
<P>
<B>virtual void</B> <B>ChangeValue</B>(<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I> value</I>)<P>
Sets the text value and marks the control as not-modified (which means that
<A HREF="wx_wxtextctrl.html#wxtextctrlismodified">IsModified</A> would return <TT>false</TT> immediately
after the call to SetValue).<P>
Note that this function will <EM>not</EM> generate the <TT>wxEVT_COMMAND_TEXT_UPDATED</TT> 
event.
This is the only difference with <A HREF="wx_wxtextctrl.html#wxtextctrlsetvalue">SetValue</A>.
See <A HREF="wx_eventhandlingoverview.html#progevent">this topic</A> for more information.<P>
This function is new since wxWidgets version 2.7.1<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>value</I><UL><UL>
The new value to set. It may contain newline characters if the text control is multi-line.</UL></UL>
<P>


<HR>
<A NAME="wxtextctrlshowposition"></A>
<H3>wxTextCtrl::ShowPosition</H3>
<P>
<B>void</B> <B>ShowPosition</B>(<B>long</B><I> pos</I>)<P>
Makes the line containing the given position visible.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>pos</I><UL><UL>
The position that should be visible.</UL></UL>
<P>


<HR>
<A NAME="wxtextctrlundo"></A>
<H3>wxTextCtrl::Undo</H3>
<P>
<B>virtual void</B> <B>Undo</B>()<P>
If there is an undo facility and the last operation can be undone, undoes the last operation. Does nothing
if there is no undo facility.<P>


<HR>
<A NAME="wxtextctrlwritetext"></A>
<H3>wxTextCtrl::WriteText</H3>
<P>
<B>void</B> <B>WriteText</B>(<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I> text</I>)<P>
Writes the text into the text control at the current insertion position.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>text</I><UL><UL>
Text to write to the text control.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Remarks</FONT></B><P>
Newlines in the text string
are the only control characters allowed, and they will cause appropriate
line breaks.  See <A HREF="wx_wxtextctrl.html#wxtextctrlinsert">wxTextCtrl::&lt;&lt;</A> and <A HREF="wx_wxtextctrl.html#wxtextctrlappendtext">wxTextCtrl::AppendText</A> for more convenient ways of writing to the window.<P>
After the write operation, the insertion point will be at the end of the inserted text, so subsequent write operations will be appended. To append text after the user may have interacted with the control, call <A HREF="wx_wxtextctrl.html#wxtextctrlsetinsertionpointend">wxTextCtrl::SetInsertionPointEnd</A> before writing.<P>


<HR>
<A NAME="wxtextctrlxytoposition"></A>
<H3>wxTextCtrl::XYToPosition</H3>
<P>
<B>long</B> <B>XYToPosition</B>(<B>long</B><I> x</I>, <B>long</B><I> y</I>)<P>
Converts the given zero based column and line number to a position.<P>
<B><FONT COLOR="#FF0000">Parameters</FONT></B><P>
<I>x</I><UL><UL>
The column number.</UL></UL>
<P>
<I>y</I><UL><UL>
The line number.</UL></UL>
<P>
<B><FONT COLOR="#FF0000">Return value</FONT></B><P>
The position value, or -1 if <TT>x</TT> or <TT>y</TT> was invalid.<P>


<HR>
<A NAME="wxtextctrlinsert"></A>
<H3>wxTextCtrl::operator &lt;&lt;</H3>
<P>
<B><A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A>&</B> </B> <B>operator &lt;&lt;</B>(<B>const <A HREF="wx_wxstring.html#wxstring">wxString</A>& </B></B><I>s</I>)<P>
<B><A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A>&</B> </B> <B>operator &lt;&lt;</B>(<B>int</B><I> i</I>)<P>
<B><A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A>&</B> </B> <B>operator &lt;&lt;</B>(<B>long</B><I> i</I>)<P>
<B><A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A>&</B> </B> <B>operator &lt;&lt;</B>(<B>float</B><I> f</I>)<P>
<B><A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A>&</B> </B> <B>operator &lt;&lt;</B>(<B>double</B><I> d</I>)<P>
<B><A HREF="wx_wxtextctrl.html#wxtextctrl">wxTextCtrl</A>&</B> </B> <B>operator &lt;&lt;</B>(<B>char</B><I> c</I>)<P>
Operator definitions for appending to a text control, for example:<P>
<PRE>
  wxTextCtrl *wnd = new wxTextCtrl(my_frame);

  (*wnd) &lt;&lt; "Welcome to text control number " &lt;&lt; 1 &lt;&lt; ".\n";
</PRE>

</FONT></BODY></HTML>
