<HTML>
<head><link rel=stylesheet type="text/css" href="wx.css"><title>Architecture dependency</title></head>

<BODY BGCOLOR=#FFFFFF>
<A NAME="architecturedependency"></A><CENTER>
<A HREF="wx_contents.html"><img align=center src="contents.gif" BORDER=0 ALT="Contents"></A> <A HREF="wx_multiplat.html#multiplat"><img align=center src="up.gif" BORDER=0 ALT="Up"></A> <A HREF="wx_allocatingobjects.html#allocatingobjects"><img align=center src="back.gif" BORDER=0 ALT="Previous"></A> <A HREF="wx_conditionalcompilation.html#conditionalcompilation"><img align=center src="forward.gif" BORDER=0 ALT="Next"></A> </CENTER><HR>

<H2>Architecture dependency</H2>
<P>
A problem which sometimes arises from writing multi-platform programs is that
the basic C types are not defined the same on all platforms. This holds true
for both the length in bits of the standard types (such as int and long) as 
well as their byte order, which might be little endian (typically
on Intel computers) or big endian (typically on some Unix workstations). wxWidgets
defines types and macros that make it easy to write architecture independent
code. The types are:<P>
wxInt32, wxInt16, wxInt8, wxUint32, wxUint16 = wxWord, wxUint8 = wxByte<P>
where wxInt32 stands for a 32-bit signed integer type etc. You can also check
which architecture the program is compiled on using the wxBYTE_ORDER define
which is either wxBIG_ENDIAN or wxLITTLE_ENDIAN (in the future maybe wxPDP_ENDIAN
as well).<P>
The macros handling bit-swapping with respect to the applications endianness
are described in the <A HREF="wx_byteordermacros.html#byteordermacros">Byte order macros</A> section.<P>

</FONT></BODY></HTML>
