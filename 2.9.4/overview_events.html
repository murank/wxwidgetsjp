<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>wxWidgets: wxWidgets: イベントとイベント処理</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery-1.3.2.min.js"></script>

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr>
  
  <td id="projectlogo"><a href="http://www.wxwidgets.org/" target="_new"><img alt="Logo" src="logo.png"/></a></td>
  
  <td style="padding: 0.5em; text-align: right;">
   <span id="projectnumber">Version: 2.9.4</span>
  </td>
  
 </tr>
 </tbody>
</table>
</div><!-- Generated by Doxygen 1.7.4 -->


<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li class="current"><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>カテゴリ</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li><a href="dirs.html"><span>ディレクトリ</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">ドキュメント</a>      </li>
      <li class="navelem"><a class="el" href="page_topics.html">トピックスの概要</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">イベントとイベント処理 </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>関連クラス: <a class="el" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a>, <a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a>, <a class="el" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a></p>
<ul>
<li><a class="el" href="overview_events.html#overview_events_introduction">イントロダクション</a> </li>
<li><a class="el" href="overview_events.html#overview_events_eventhandling">イベント処理</a> </li>
<li><a class="el" href="overview_events.html#overview_events_processing">イベント処理の仕組み</a> </li>
<li><a class="el" href="overview_events.html#overview_events_custom">カスタムイベントの概要</a> </li>
<li><a class="el" href="overview_events.html#overview_events_misc">雑多な覚書</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="overview_events_introduction"></a>
イントロダクション</h2>
<p>他のすべての GUI フレームワークのように、wxWidgets アプリケーションはイベントベースで処理の制御を行います: 一般的に、プログラムの処理の大半はユーザの生成するイベントに応じて行われます。これらのイベントは (キーボード、マウス、ジョイスティックなどの) 入力装置を利用して直接発生させるか、より一般的には、それらの入力イベントをより高レベルのイベントへ合成する標準コントロールを利用して発生させることができます: 例えば、<a class="el" href="classwx_button.html" title="ボタンはテキストを含んだコントロールであり、もっとも一般的な GUI 要素のひとつです。">wxButton</a> はコントロール上でユーザが左マウスボタンを押下し、 (<code>Esc</code> を押下することなく) 離したときにクリックイベントを生成します。<a class="el" href="classwx_timer_event.html" title="wxTimerEvent はタイマーイベントのイベントハンドラへ引き渡されるオブジェクトです。 (wxTimer::SetOwner 参照) ">wxTimerEvent</a> や <a class="el" href="classwx_socket_event.html" title="このイベントクラスはソケットイベントに関する情報を含んでいます。">wxSocketEvent</a> など、ユーザの操作に直接対応しないイベントも存在します。</p>
<p>しかし、すべての場合において、wxWidgets ではそれらのイベントを同じ形式で表現しており、イベントの派生元によらず、同一の方法で処理することができます。また、通常、イベントは wxWidgets 自身によって生成されますが、あなたがこれを行うことも可能です。これはカスタムイベントを使用する場合に特に有用です。 (<a class="el" href="overview_events.html#overview_events_custom">カスタムイベントの概要</a> 参照) </p>
<p>より正確には、イベントは以下の内容で表現されます:</p>
<ul>
<li><em>イベント型</em> : イベントの型を一意に識別するための wxEventType 型の値です。例えば、ボタンクリック、リストボックスの選択、キー押下はすべて別々のイベント型のイベントを生成します。</li>
<li><em>イベントクラス</em> : 各イベントは自分自身に関連する情報を持っており、これは <a class="el" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a> の継承クラスで表現されます。同じイベントクラスを別のイベント型に使用することができます。例えば、ボタンのクリックイベントとリストボックスの選択イベントは両方とも <a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> クラスを使用しています (し、他のすべての単純なコントロールイベントも同じものを使用しています) が、キー押下イベントはイベントに関連する情報が異なるため、<a class="el" href="classwx_key_event.html" title="このイベントクラスはキーの押下イベントや解放イベントに関する情報を含んでいます。">wxKeyEvent</a> を使用しています。</li>
<li><em>Event 発生元</em> : <a class="el" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a> はイベントを生成したオブジェクトや、生成元がウィンドウの場合はその識別子 (<a class="el" href="overview_events.html#overview_events_winid">ウィンドウ識別子</a> 参照) を格納しています。複数のオブジェクトが同じ型のイベントを生成すること (例えば、一般的なウィンドウは複数のボタンを持ちますが、それらはすべて同じボタンクリックイベントを生成します) はよくあるため、イベントの生成元オブジェクトやその識別子を確認することで生成元を区別することができます。</li>
</ul>
<h2><a class="anchor" id="overview_events_eventhandling"></a>
イベント処理</h2>
<p>wxWIdgets でイベントを処理する方法として、主に 2 種類の方法があります。ひとつは <em>イベントテーブル</em> マクロを使用する方法で、静的 (コンパイル時) にのみ、イベントとそのハンドラをバインドすることができます。もう一方は <a class="el" href="classwx_evt_handler.html#a84b1e446053bda8f76f13336839e8b64" title="指定された関数、ファンクタ、メンバ関数をイベントへ動的にバインドします。">wxEvtHandler::Bind&lt;&gt;()</a> を使用する方法で、動的に (実行時に条件に基づいて) ハンドラをバインドしたり解除したりできます。また、以下のものをイベントへ直接バインドすることができます: </p>
<ul>
<li>別のオブジェクトのハンドラ関数。 </li>
<li>静的関数やグローバル関数のような普通の関数。 </li>
<li>boost::function&lt;&gt; のような任意のファンクタ。</li>
</ul>
<p>静的なイベントテーブルではそれが定義されたオブジェクトのイベントしか処理できないため、柔軟性は Bind&lt;&gt;() の方がイベントテーブルよりも上です。一方で、イベントテーブルの方が簡潔であり、すべてのイベントハンドラを一箇所に集約することができます。より適切と思ういずれかの方法を選択することもできますし、(おそらく混乱を招く、悪い考えでしょうが) 異なるクラスや同じクラス内で自由に両方の方法を組み合わせることもできます。</p>
<p>既存の wxWidgets のチュートリアルや議論の大半ではイベントテーブルを使用していることにも注意してください。これは歴史的に、wxWidgets で動的イベント処理が可能になる前から、それらの文書が存在するためです。ただし、これはイベントテーブルが適切な方法であることを意味しているわけではまったくありません: ある側面においては動的なイベント処理の方が優れており、wxWidgets を使い始める際には動的にイベント処理を行なうことを強く検討するべきです。一方で、単に多くのサンプルでイベントテーブルを見かけるからという理由だけであっても、イベントテーブルについて学ぶ必要性は依然として残っています。</p>
<p>そのため、イベントテーブルと動的イベントハンドラのいずれかを選択する前に、それぞれの方法についてより詳しく議論しておきましょう。次の章ではイベントテーブルを用いたイベント処理の導入部分を説明します。Bind&lt;&gt;() についての議論は <a class="el" href="overview_events.html#overview_events_bind">動的イベント処理</a> を参照してください。</p>
<h3><a class="anchor" id="overview_events_eventtables"></a>
イベントテーブルによるイベント処理</h3>
<p><em>イベントテーブル</em> を使うためには、まずイベントを処理するクラスを決定する必要があります。wxWidgets が唯一要求することとして、イベントを処理するクラスは <a class="el" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a> を継承していなければなりません。したがって、<a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> はこのクラスを継承していることを考慮すると、ウィンドウを表すクラスはどれもイベントを処理することができるということです。メニューコマンドといった単純なイベントは普通、メニューを保持するトップレベルウィンドウで処理されます。そのため、いくつかのイベントは <a class="el" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a> を継承した <code>MyFrame</code> で処理する必要があるはずです。</p>
<p>最初に、ひとつ以上の <em>イベントハンドラ</em> を定義してください。これらのイベントハンドラは単純なメンバ関数であり、wxEvent を継承したクラスのオブジェクトへの参照を引数に取り、戻り値はありません。(情報を返却する場合は引数のオブジェクトを経由して行います。これが引数を const にしていない理由です) また、以下のマクロを</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__events.html#gab6eca03fad44ec10b75d3cb82e9219e3" title="静的イベントテーブルを宣言するために、クラス宣言の中でこのマクロを使用してください。">wxDECLARE_EVENT_TABLE</a>()
</pre></div><p>クラス宣言内のどこかに挿入する必要があります。どこに挿入しても構いませんが、慣習的にクラス宣言の最後に配置します。これはこのマクロがアクセス制御を内部的に変更してしまうからで、宣言の後ろに何もなければ一番安全だからです。完全なクラス宣言は以下のようになります:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyFrame : <span class="keyword">public</span> <a class="code" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a>
{
<span class="keyword">public</span>:
    MyFrame(...) : <a class="code" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a>(...) { }

    ...

protected:
    <span class="keywordtype">int</span> m_whatever;

<span class="keyword">private</span>:
    <span class="comment">// 通常、イベントハンドラはクラス外から呼ばれることはないため、</span>
    <span class="comment">// 普通は private にします。特に、これらを public に</span>
    <span class="comment">// する必要はありません。</span>
    <span class="keywordtype">void</span> OnExit(<a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a>&amp; event);
    <span class="keywordtype">void</span> OnButton1(<a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a>&amp; event);
    <span class="keywordtype">void</span> OnSize(<a class="code" href="classwx_size_event.html" title="リサイズイベントは wxWindow のサイズ変更イベントに関する情報を保持します。">wxSizeEvent</a>&amp; event);

    <span class="comment">// イベントハンドラは OnSomething() という名前にするのが一般的ですが、</span>
    <span class="comment">// そうしなければならないわけではありません； これもイベントハンドラです:</span>
    <span class="keywordtype">void</span> DoTest(<a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a>&amp; event);

    <a class="code" href="group__group__funcmacro__events.html#gab6eca03fad44ec10b75d3cb82e9219e3" title="静的イベントテーブルを宣言するために、クラス宣言の中でこのマクロを使用してください。">wxDECLARE_EVENT_TABLE</a>()
};
</pre></div><p>次に、イベントテーブルを定義する必要があります。これは必ずソースファイル内に配置しなければなりません。イベントテーブルはイベントとメンバ関数のマッピングを wxWidgets へ知らせるものであり、以下のようになります:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__events.html#ga736930efaab4d7e445e9e8e520c7b74d" title="静的イベントハンドラの列挙を開始するために、ソースファイル内でこのマクロを使用してください。">wxBEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a>)
    EVT_MENU(<a class="code" href="defs_8h.html#ac66d0a09761e7d86b2ac0b2e0c6a8cbba37f548d1211c664ede962e943baad4e5">wxID_EXIT</a>, MyFrame::OnExit)
    EVT_MENU(DO_TEST, MyFrame::DoTest)
    EVT_SIZE(MyFrame::OnSize)
    EVT_BUTTON(BUTTON1, MyFrame::OnButton1)
<a class="code" href="group__group__funcmacro__events.html#ga383fad2a46e1d6c220fbe03ecfbc9c17" title="静的イベントハンドラの列挙を終了するために、ソースファイル内でこのマクロを使用してください。">wxEND_EVENT_TABLE</a>()
</pre></div><p>イベント処理に使用したいメンバ関数はイベントテーブル内に記載する必要があることに注意してください; MyFrame クラス内で定義するだけでは  <em>不十分</em> です。</p>
<p>この定義を詳しく見ていきましょう: 最初の行は MyFrame クラスのイベントテーブルを定義しようとしており、基底クラスが <a class="el" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a> であることを意味しています。そのため、デフォルトでは MyFrame で処理されなかったイベントは <a class="el" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a> で処理されます。次の 4 行は個々のイベントにおけるイベントハンドラへのバインディングを定義しています: 最初のふたつはマクロの第 1 引数で指定された識別子を持つ項目のメニューコマンドを、ふたつの異なるメンバ関数にマッピングしています。次の行の <code>EVT_SIZE</code> はフレームのサイズを変更すると OnSize() を呼び出すことを意味しています。このマクロはウィンドウ識別子を必要としません。なぜなら、通常は現在のウィンドウのリサイズイベントにのみ関心があるはずだからです。</p>
<p><code>EVT_BUTTON</code> マクロはイベントの発生元がウィンドウクラスである必要がないことを表しています。イベントテーブルの検索はウィンドウ階層をたどりながら行われるため、イベントの発生元がフレーム内のパネルにあるボタンである場合でも動作します。 (しかし、これが可能なのはコマンドイベントのみです。そのため、同じ方法で子コントロールでのマウス移動イベントを親ウィンドウで捕まえることはできません。なぜなら <a class="el" href="classwx_mouse_event.html" title="このイベントクラスはマウスによって生成されるイベントに関する情報を含んでいます: これにはマウスボタンの押下、解放イベント、およびマウスの移動イベントが含まれます。">wxMouseEvent</a> は <a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> を継承していないためです。マウスイベントで同じことを実現する方法は以下を参照してください) この場合、まずボタンのイベントテーブルが検索され、続いて、その親パネル、フレームの順に検索されます。</p>
<p>最後に、イベントハンドラを実装する必要があります。以前述べたように、すべてのイベントハンドラは wxEvent を継承した引数を取りますが、その引数のクラスはイベントの型と発生元ウィンドウのクラスに応じて異なります。リサイズイベントでは <a class="el" href="classwx_size_event.html" title="リサイズイベントは wxWindow のサイズ変更イベントに関する情報を保持します。">wxSizeEvent</a> が使用されます。メニューコマンドと (ボタン押下といった) 大半のコマンドコントロールでは <a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> が使用されます。より複雑なコントロールのときには、コントロール独自の追加情報を提供する、wxCommandEvent を継承したより具体的なイベントクラスを使用できます。例えば、<a class="el" href="classwx_tree_ctrl.html" title="ツリーコントロールでは情報を (項目を展開すると追加の項目が現れる) 階層として表します。">wxTreeCtrl</a> ウィンドウから送られるイベントでは <a class="el" href="classwx_tree_event.html" title="ツリーイベントは wxTreeCtrl オブジェクトに関連するイベントの情報を保持します。">wxTreeEvent</a> が使用できます。</p>
<p>ありえそうな一番単純な例では、イベントハンドラは <code>event</code> 引数をまったく使用しないかもしれません。以下に例を示します。</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrame::OnExit(<a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a>&amp; WXUNUSED(event))
{
    <span class="comment">// ユーザがメニューから "Exit" を選択したときには終了する必要がある。</span>
    Close(<span class="keyword">true</span>);
}
</pre></div><p>他の場合では、以下のように <code>event</code> 引数の持つ情報が必要になるかもしれません:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrame::OnSize(<a class="code" href="classwx_size_event.html" title="リサイズイベントは wxWindow のサイズ変更イベントに関する情報を保持します。">wxSizeEvent</a>&amp; event)
{
    <a class="code" href="classwx_size.html" title="wxSize は図形操作のための有用なデータ構造です。">wxSize</a> size = <span class="keyword">event</span>.GetSize();

    ... 新しいサイズを使用してフレームを更新する ...
}
</pre></div><p>イベントテーブルマクロと、それに付随する wxEvent の継承クラスについては、イベントを生成する各コントロールの説明で詳しく説明しています。</p>
<h3><a class="anchor" id="overview_events_bind"></a>
動的イベント処理</h3>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="overview_cpp_rtti_disabled.html">C++ RTTI を使用しない場合の注意点</a></dd></dl>
<p>この方法ではイベント処理のやり方が大きく異なります。構文を見ることから始めましょう: 最初の明らかな違いは <a class="el" href="group__group__funcmacro__events.html#gab6eca03fad44ec10b75d3cb82e9219e3" title="静的イベントテーブルを宣言するために、クラス宣言の中でこのマクロを使用してください。">wxDECLARE_EVENT_TABLE()</a> や <a class="el" href="group__group__funcmacro__events.html#ga736930efaab4d7e445e9e8e520c7b74d" title="静的イベントハンドラの列挙を開始するために、ソースファイル内でこのマクロを使用してください。">wxBEGIN_EVENT_TABLE()</a>、およびそれらに関連するマクロを使用する必要がない点です。代わりに、コードの任意の場所で以下のように Bind&lt;&gt;() を呼び出します。 (通常はイベントを処理するクラスの定義内に配置し、イベントテーブルの場合のようにグローバルスコープ内には配置しません) </p>
<div class="fragment"><pre class="fragment">MyFrame::MyFrame(...)
{
      Bind(<a class="code" href="group__group__funcmacro__events.html#ga5705afbf2885acba094565982b5f6407">wxEVT_COMMAND_MENU_SELECTED</a>, &amp;MyFrame::OnExit, <span class="keyword">this</span>, wxID_EXIT);
}
</pre></div><p>ここでは <code>this</code> ポインタを指定する必要があることに注意してください。</p>
<p>さて、意味論的な違いについて説明しましょう: </p>
<ul>
<li>
<p class="startli">イベントハンドラは任意のタイミングでバインドできます。例えば、先に何かの初期化処理を行い、それが成功したときにのみ、イベントハンドラをバインドすることも可能です。こうすることで、イベントハンドラ内でオブジェクトが正常に初期化されているか確認する必要がなくなります。Bind&lt;&gt;() を使用することで、初期化が正常に行われなかった場合は単純にイベントハンドラが呼び出されないだけになります。 </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">この延長として、Unbind&lt;&gt;() を使ってイベントハンドラのバインディングを任意のタイミングで解除することもできます。 (また、あとから再バインドするかもしれません) もちろん、イベントハンドラの有効無効を表す内部フラグを用いることで、古典的な静的イベントハンドラ (つまり、イベントテーブル) でもこの振る舞いを模倣することは可能です。しかし、動的にバインドされるイベントハンドラを使用する方がコードも少なく、処理内容も明確になります。 </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">大事なことを一つ言い残しましたが、バインド対象についても柔軟性が向上しており、イベントを以下のものにバインドできます: </p>
<ul>
<li>別のオブジェクトの関数。 </li>
<li>静的関数やグローバル関数のような普通の関数。 </li>
<li>boost::function&lt;&gt; のような任意のファンクタ。</li>
</ul>
<p>これはイベントテーブルでは実現不可能です。なぜなら、イベントのディスパッチ先としてこれらのハンドラを指定することができないためです。そのため、イベントはそれを生成したオブジェクトに対して送信される必要があります。Bind&lt;&gt;() ではこれらのイベントハンドラを指定できるため、そのようなことはありません。一例として、よく質問される子フレーム内にマウスがあるときのマウス移動イベントの受信方法を挙げましょう。これは単純な方法では実現できません: </p>
<ul>
<li>
<p class="startli">フレームのイベントテーブル内に <code>EVT_LEAVE_WINDOW(MyFrame::OnMouseLeave)</code> を書いても効果がありません。なぜなら、マウス移動 (フレームへの出入りも含みます) イベントは (少なくともデフォルトでは) 親ウィンドウへ伝播しないためです。 </p>
<p class="endli"></p>
</li>
<li>
同じ内容を子イベントテーブルへ配置した場合、実行時にクラッシュするでしょう。なぜなら、異なる型のオブジェクトに対して MyFrame メンバ関数を呼びだそうとするためです。ここでは子コントロールのポインタしか使用できないからだということは簡単に分かってもらえると思います。しかし、当然のことながら、フレームのポインタの代わりに子ウィンドウのポインタに対してフレームのメンバ関数を呼ぶと悲惨なことになります。  </li>
</ul>
<p>しかし、次のように書くと </p>
<div class="fragment"><pre class="fragment">            MyFrame::MyFrame(...)
            {
              m_child-&gt;Bind(<a class="code" href="group__group__funcmacro__events.html#ga51a2a26e560dade6d24f3f464a24fd73">wxEVT_LEAVE_WINDOW</a>, &amp;MyFrame::OnMouseLeave, <span class="keyword">this</span>);
            }
</pre></div><p> 期待した通りに動作します。イベントハンドラへ渡された <code>event</code> 引数の <a class="el" href="classwx_event.html#abdc74e95c8c2f32f2cc2bd84b88985ee" title="イベントに関連付けられているオブジェクト (通常はウィンドウです) がある場合、それを返却します。">wxEvent::GetEventObject()</a> 関数によって、イベントを生成したオブジェクトを取得できます。 (このオブジェクトはフレームではありません)  </p>
<p class="endli"></p>
</li>
<li>
最後のポイントは前述のポイントの帰結です: Bind() の柔軟性が向上したため、うっかり他クラスのメンバ関数を使用してしまうことが不可能になり、安全性も向上しました。Bind() を使用すると、実行時にクラッシュするかわりにコンパイルエラーが発生するようになります。  </li>
</ul>
<p>Bind() のふたつのオーバーロードを用いて、異なるイベントハンドラを使用する例を見てみましょう: 最初のオーバーロードはメンバ関数用で、もう一方は任意のファンクタ (単純な関数を含む、呼び出し可能なオブジェクト) 用です。</p>
<p>イベントを生成したオブジェクトに加えて、完全に別のオブジェクトのメンバ関数をイベントハンドラとして使用できます。</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyFrameHandler::OnFrameExit( <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> &amp; )
{
    <span class="comment">// 何か有用なことを行う。</span>
}

MyFrameHandler myFrameHandler;

MyFrame::MyFrame()
{
      Bind( <a class="code" href="group__group__funcmacro__events.html#ga5705afbf2885acba094565982b5f6407">wxEVT_COMMAND_MENU_SELECTED</a>, &amp;MyFrameHandler::OnFrameExit,
              &amp;myFrameHandler, wxID_EXIT );
}
</pre></div><p><code>MyFrameHandler</code> は <a class="el" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a> を継承している必要がないことに注意してください。ただし、<code>myFrameHandler</code> の寿命を <code>MyFrame</code> よりも長くなるようにするか、もしくは少なくとも破棄される前にバインディングを解除する必要があることを覚えておいてください。</p>
<p>イベントハンドラとして普通の関数や静的メンバ関数を使用する場合、以下のように書いてください:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> HandleExit( <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> &amp; )
{
    <span class="comment">// 何か有用なことを行う</span>
}

MyFrame::MyFrame()
{
    Bind( <a class="code" href="group__group__funcmacro__events.html#ga5705afbf2885acba094565982b5f6407">wxEVT_COMMAND_MENU_SELECTED</a>, &amp;HandleExit, wxID_EXIT );
}
</pre></div><p>そして、最後に任意のファンクタをバインドし、イベントハンドラとして使用することができます:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>MyFunctor
{
    <span class="keywordtype">void</span> operator()( <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> &amp; )
    {
        <span class="comment">// 何か有用なことを行う</span>
    }
};

MyFunctor myFunctor;

MyFrame::MyFrame()
{
    Bind( <a class="code" href="group__group__funcmacro__events.html#ga5705afbf2885acba094565982b5f6407">wxEVT_COMMAND_MENU_SELECTED</a>, &amp;myFunctor, wxID_EXIT );
}
</pre></div><p>ファンクタの一般的な例は boost::function&lt;&gt; です:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">using namespace </span>boost;

<span class="keywordtype">void</span> MyHandler::OnExit( <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> &amp; )
{
    <span class="comment">// 何か有用なことを行う</span>
}

MyHandler myHandler;

MyFrame::MyFrame()
{
    function&lt; void ( wxCommandEvent &amp; ) &gt; exitHandler( bind( &amp;MyHandler::OnExit, &amp;myHandler, _1 ));

    Bind( <a class="code" href="group__group__funcmacro__events.html#ga5705afbf2885acba094565982b5f6407">wxEVT_COMMAND_MENU_SELECTED</a>, exitHandler, wxID_EXIT );
}
</pre></div><p>boost::bind&lt;&gt;() のおかげで、シグネチャが完全に一致しないメンバ関数でも使用することができます:</p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> MyHandler::OnExit( <span class="keywordtype">int</span> exitCode, <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> &amp;, <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> goodByeMessage )
{
    <span class="comment">// 何か有用なことを行う</span>
}

MyHandler myHandler;

MyFrame::MyFrame()
{
    function&lt; void ( wxCommandEvent &amp; ) &gt; exitHandler(
            bind( &amp;MyHandler::OnExit, &amp;myHandler, EXIT_FAILURE, _1, <span class="stringliteral">"Bye"</span> ));

    Bind( <a class="code" href="group__group__funcmacro__events.html#ga5705afbf2885acba094565982b5f6407">wxEVT_COMMAND_MENU_SELECTED</a>, exitHandler, wxID_EXIT );
}
</pre></div><p>まとめると、Bind&lt;&gt;() を使用すると若干コードが増えますが、静的イベントテーブルよりも柔軟性があります。そのため、この追加の効果が必要なときはためらわずに使用してください。一方で、追加の柔軟性が必要とされないような単純な状況では、イベントテーブルもまだ充分に役立ちます。</p>
<h2><a class="anchor" id="overview_events_processing"></a>
イベント処理の仕組み</h2>
<p>前の章ではイベントハンドラの定義方法について説明しましたが、wxWidgets がどのようにイベントハンドラを探すのかについてはまだ述べていません。この章ではそのアルゴリズムについて詳しく説明します。おそらく、この章を読みながら <a class="el" href="page_samples.html#page_samples_event">イベントサンプル</a> を実行し、コードや (イベント処理順序を確認するために) ボタンをクリックした時の出力を見たくなると思います。</p>
<p>ウィンドウからイベントを受信したとき、wxWidgets はイベントを生成したウィンドウに属する最初のイベントハンドラオブジェクトの <a class="el" href="classwx_evt_handler.html#a65968dd27f3aac7718f2dd6b2ddd5a08" title="イベントテーブルを検索し、0 個以上の適切なイベントハンドラ関数を呼び出してイベントを処理します。">wxEvtHandler::ProcessEvent</a> を呼び出します。通常、ProcessEvent() によるイベントテーブルの検索順は以下のように行われ、イベントハンドラが見つかると処理を終了します。 (ただし、イベントハンドラで <a class="el" href="classwx_event.html#a98eb20b76106f9a933c2eb3ee119f66c" title="この関数はイベントハンドラの中で使用し、現在のイベントハンドラの処理が終わった後にさらにイベントハンドラを呼び出すかどうかを制御します。">wxEvent::Skip()</a> を呼ぶとイベントが処理されていないものとして扱われ、引き続き検索が行われます): </p>
<ol>
<li value="0">
<p class="startli">他の処理を行う前に <a class="el" href="classwx_app_console.html#ada7ab606e014a10d46e4b3c6f602e20c" title="wxEventFilter をオーバーライドした関数。">wxApp::FilterEvent()</a> を呼び出します。-1 (デフォルト) 以外の値を返却した場合、ただちにイベント処理を終了します。 </p>
<p class="endli"></p>
</li>
<li value="1">
<p class="startli">イベントハンドラが <a class="el" href="classwx_evt_handler.html#a7388ae19c8657e5656471b658c320036" title="イベントハンドラを有効化、無効化します。">wxEvtHandler::SetEvtHandlerEnabled()</a> によって無効化されている場合、次の 3 ステップはスキップし、(5) から処理を継続します。 </p>
<p class="endli"></p>
</li>
<li value="2">
<p class="startli">オブジェクトが <a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> で、かつ、関連するバリデータを持っている場合、<a class="el" href="classwx_validator.html" title="wxValidator はコントロールクラスとアプリケーションデータを仲介する、バリデータクラスファミリーの基底クラスです。">wxValidator</a> でイベントを処理します。 </p>
<p class="endli"></p>
</li>
<li value="3">
<p class="startli">動的イベントハンドラ (つまり、Bind&lt;&gt;() でバインドしたイベントハンドラ) の一覧を調べます。これは静的イベントハンドラをチェックする前に行われることに注意してください。そのため、動的イベントハンドラと静的イベントハンドラの両方がイベントに合致した場合、動的イベントハンドラで <a class="el" href="classwx_event.html#a98eb20b76106f9a933c2eb3ee119f66c" title="この関数はイベントハンドラの中で使用し、現在のイベントハンドラの処理が終わった後にさらにイベントハンドラを呼び出すかどうかを制御します。">wxEvent::Skip()</a> を呼ばない限りは静的イベントハンドラが呼ばれることはありません。 </p>
<p class="endli"></p>
</li>
<li value="4">
<p class="startli">このクラスと基底クラスで (イベントテーブルマクロによって) 定義されたすべてのイベントハンドラを含むイベントテーブルを調べます。これは基底クラスで定義されたイベントハンドラがこのステップで実行されうることを意味します。 </p>
<p class="endli"></p>
</li>
<li value="5">
<p class="startli">イベントハンドラの連鎖内において、次のイベントハンドラが存在する場合、次のイベントハンドラへイベントを引き渡します。つまり、そのイベントハンドラに対してステップ (1) から (4) を行います。普通は次のイベントハンドラが存在しないため、次のステップを行いますが、次のイベントハンドラを定義する方法は <a class="el" href="overview_events.html#overview_events_nexthandler">イベントハンドラの連鎖</a> を参照してください。 </p>
<p class="endli"></p>
</li>
<li value="6">
<p class="startli">オブジェクトが <a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> で、かつ、イベントが伝播するように設定されている (デフォルトでは wxCommandEvent を継承したイベントのみ、伝播するよう設定されています) 場合、親ウィンドウに対してステップ (1) から (ステップ (7) を除いて) 再度処理を行います。このオブジェクトがウィンドウでないが次のイベントハンドラが存在する場合、親コントロールがウィンドウであれば親コントロールにイベントを引き渡します。これにより、ウィンドウ上に (おそらく複数の) 非ウィンドウイベントハンドラが配置されているような一般的な場合において、イベントが最終的に親ウィンドウまで確実に到達するようになります。 </p>
<p class="endli"></p>
</li>
<li value="7">
最後に、つまり、イベントがまだ処理されていないときに、(<a class="el" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a> を継承している) <a class="el" href="classwx_app.html" title="wxUSE_GUI=1 のとき、wxApp はアプリケーション自身を表します。">wxApp</a> オブジェクト自身でイベントが処理されます。  </li>
</ol>
<p><em>ステップ 6 に注意してください。</em> wxWidgets のイベント処理システムの持つこの強力な機能はしばしば見落とされたり、人を混乱させたりします。ウィンドウ階層内におけるイベント伝播についての詳細は次の章で述べます。</p>
<p>また、wxWidgets ドキュメント/フレームワークのウィンドウ部分、つまり、<a class="el" href="classwx_doc_parent_frame.html" title="wxDocParentFrame クラスはドキュメント/ビューフレームワークを使用するアプリケーションにデフォルトのトップレベルフレームを提供します。">wxDocParentFrame</a>、<a class="el" href="classwx_doc_child_frame.html" title="wxDocChildFrame クラスは分割ウィンドウ上に表示されるドキュメントにデフォルトフレームを提供します。">wxDocChildFrame</a> と、その MDI 版である <a class="el" href="classwx_doc_m_d_i_parent_frame.html" title="wxDocMDIParentFrame クラスはドキュメント/ビューフレームワークを使用するアプリケーションにデフォルトのトップレベルフレームを提供します。">wxDocMDIParentFrame</a>、<a class="el" href="classwx_doc_m_d_i_child_frame.html" title="wxDocMDIChildFrame クラスは分割ウィンドウ上に表示されるドキュメントにデフォルトフレームを提供します。">wxDocMDIChildFrame</a> でのイベント処理には追加のステップが存在することにも注意してください。親フレームクラスでは上記のステップ (2) において、受信したイベントをまず  <a class="el" href="classwx_doc_manager.html" title="wxDocManager クラスは wxWidgets のサポートしているドキュメント/ビューフレームワークの一部で、wxView、wxDocument、wxDocTemplate と一緒に使用します。">wxDocManager</a> オブジェクトに送信するように変わります。そして、このオブジェクトが現在のビューに対してイベントを送信し、ビュー自身が関連するドキュメントにまずイベントを処理させます。子フレームクラスはイベントを関連するビューへ直接送信し、このビューがさらに関連するドキュメントへイベントを転送します。ドキュメント/ビューフレームワークでの正確なイベント処理順を覚えなくてもいいようにする、もっとも単純で推奨する解決方法は、ビュークラスでのみイベントを処理し、ドキュメントやドキュメントマネージャでは処理しないことです。</p>
<h3><a class="anchor" id="overview_events_propagation"></a>
上位階層へのイベント伝播方法</h3>
<p>以前述べたように、<a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> を継承したクラスのイベントは、ウィンドウ自身で処理されなかった場合にデフォルトで親ウィンドウまで伝播します。しかし、コマンドイベントがデフォルトで伝播するとはいえ、他のイベントも伝播させることは可能です。なぜなら、イベント処理コードでは<a class="el" href="classwx_event.html#ad265ef226445cb6b72a2697dd9d3b406" title="イベントを伝播させる必要があるかどうかを確認します。">wxEvent::ShouldPropagate()</a> を用いてイベントを伝播させるかどうかを確認するためです。イベントの伝播回数を制限することも可能ですし、処理されるまで (もしくはトップレベルの親ウィンドウに到達するまで) 伝播させることも可能です。</p>
<p>最後に、他にも複雑な仕組みがあります (実際には、これは wxWidgets プログラマの生活を非常にシンプルにしてくれるものです): コマンドイベントが親ウィンドウへ伝播するとき、親ダイアログまで到達した時点で伝播が終了します。これはつまり、モーダルダイアログを表示しているときにダイアログコントロールから意図しないイベントを受け取ることがないことを意味します。 (それらのイベントは処理されないままになるでしょう) しかし、通常のイベントはフレームを超えて伝播します。このようにした理由は、普通のアプリケーションでは数個のフレームしか存在せず、プログラマはそれらの親子関係のことをよく理解している一方で、複雑なプログラムで表示されるすべてのダイアログを追跡することは、不可能でないにしても非常に難しいためです。 (いくつかのダイアログは wxWidgets によって自動的に生成されることを思い出してください) なんらかの理由で別の振る舞いをさせる必要がある場合、明示的に <code>SetExtraStyle(wxWS_EX_BLOCK_EVENTS)</code> を使用することでイベントが指定されたウィンドウ外へ伝播するのを止めたり、ダイアログ (デフォルトでこのフラグが設定されています) のフラグを解除したりできます。</p>
<p>(リサイズ、移動、描画、マウスイベント、キーボードイベントといった) ウィンドウに関係する一般的なイベントはウィンドウに対してのみ送られます。(ボタンクリック、メニュー選択、ツリーの展開といった) 高水準で、ウィンドウ自身が生成するイベントはコマンドイベントと呼ばれ、そのイベントを処理対象とする場合に親コントロールに対して送られます。より正確に言うと、前に述べたように <a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> を継承して  <b>いない</b> イベントクラス (<a class="el" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a> の継承マップ参照) はどれも伝播 <b>しません</b>。</p>
<p>例えばダイアログ内のネイティブコントロールへ送信される (そのコントロール自身では使用しない) キーイベントなど、特定のシステムイベントを親ウィンドウで取得したいと思うことがあるかもしれません。この場合、すべてのイベント (もしくはその中の特定のイベント) を親ウィンドウへ渡すようにイベントハンドラの ProcessEvent() をオーバーライドする必要があります。</p>
<h3><a class="anchor" id="overview_events_nexthandler"></a>
イベントハンドラの連鎖</h3>
<p>イベント伝播アルゴリズムのステップ 4 では、イベントハンドラの連鎖内における次のイベントハンドラを確認します。この連鎖は <a class="el" href="classwx_evt_handler.html#a68e2ef2d2b7d68c4c9c18ca92933031b" title="次のイベントハンドラへのポインタを設定します。">wxEvtHandler::SetNextHandler()</a> を使用して形づくられます: </p>
<div class="image">
<img src="overview_events_chain.png" alt="overview_events_chain.png"/>
</div>
<p> (図を参照すると分かるように、<code>A-&gt;ProcessEvent</code> でイベントが処理されないと <code>B-&gt;ProcessEvent</code> が呼び出され、これが繰り返されます。) </p>
<p>加えて <a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> の場合、<a class="el" href="classwx_window.html#a398c11ab9af7956067a964f560d1978c" title="このイベントハンドラをウィンドウのイベントスタック上に追加します。">wxWindow::PushEventHandler()</a> を使用してスタック (<a class="el" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a> の双方向リンクリストで実装されます) を構築することができます: </p>
<div class="image">
<img src="overview_events_winstack.png" alt="overview_events_winstack.png"/>
</div>
<p> (図を見ると分かるように、<code>W-&gt;ProcessEvent</code> が呼ばれるとすぐに <code>A-&gt;ProcessEvent</code> を呼び出します; もし <code>A</code> でも <code>B</code> でもイベントを処理しなかった場合、<a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> 自身が使用されます。つまり、登録されたすべてのイベントハンドラを調べた後に<a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> の動的イベントハンドラと静的イベントテーブルを調べます。</p>
<p>デフォルトでは連鎖は空、つまり、次のイベントハンドラは存在しません。</p>
<h2><a class="anchor" id="overview_events_custom"></a>
カスタムイベントの概要</h2>
<h3><a class="anchor" id="overview_events_custom_general"></a>
一般的なアプローチ</h3>
<p>各イベントはイベント型によって一意に定義されるため、カスタムインベントは新しいイベント型を定義するところから始まります。これは <a class="el" href="group__group__funcmacro__events.html#ga09ec1d095bee3085c1cb31459b46bc00" title="特定のイベントクラスに関連する新しいイベント型を定義します。">wxDEFINE_EVENT()</a> マクロによって行います。イベント型は変数なので、必要であれば <a class="el" href="group__group__funcmacro__events.html#ga767b12d37f7370bc5f6b3d62340f3ef8" title="カスタムイベント型を宣言します。">wxDECLARE_EVENT()</a> を使用して宣言することもできます。</p>
<p>次に行なうことは、このイベント型用のカスタムイベントクラスを定義する必要があるかどうか、もしくは既存のクラス、通常は (追加の情報を持たない) <a class="el" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a> か （いくつかの追加フィールドを持ち、デフォルトで伝播する) <a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> のどちらかを再利用できるかどうかを決定することです。両方の戦略について、以下で詳細に述べています。コードの書き方とカスタムイベント型の動作例として <a class="el" href="page_samples.html#page_samples_event">イベントサンプル</a> も参照してください。</p>
<p>最後に、カスタムイベントを生成し、送信する必要があります。生成はカスタムイベントのインスタンス化と内部変数の初期化と同じくらい単純です。特定のイベントハンドラへイベントを送信する方法は 2 種類あります: <a class="el" href="classwx_evt_handler.html#a0737c6d2cbcd5ded4b1ecdd53ed0def3" title="あとで処理されるイベントを送信します。">wxEvtHandler::AddPendingEvent</a> を使用する方法と <a class="el" href="classwx_evt_handler.html#acffd03bf407a856166ea71ef0318b59a" title="あとで処理するためにイベントをキューに追加します。">wxEvtHandler::QueueEvent</a> を使用する方法です。基本的に、スレッド間通信を行なう場合は後者を選択する必要があります; メインスレッドのみを使用する場合は前者も安全に使用することができます。最後に、前述の <a class="el" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a> の関数に関連する、ふたつのグローバルラッパー関数があります: それは <a class="el" href="group__group__funcmacro__events.html#ga0cf60a1ad3a5f1e659f7ae591570f58d" title="GUI アプリケーションにおいて、この関数は wxEvtHandler::AddPendingEvent() を使用して特定の送信先オブジェクトへイベントを送信します。">wxPostEvent()</a> と <a class="el" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="特定のオブジェクトで処理するためにイベントをキューへ追加します。">wxQueueEvent()</a> です。</p>
<h3><a class="anchor" id="overview_events_custom_existing"></a>
既存のイベントクラスの使用</h3>
<p>新しいイベント型で <a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> を使用したいだけの場合、新しいイベントクラスを自分自身で定義する必要はなく、以下の汎用イベントテーブルマクロのひとつを使用してください。</p>
<p>例:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// このマクロは一般的にヘッダファイル内で使用します: これは MY_EVENT イベント型を定義するだけです</span>
<a class="code" href="group__group__funcmacro__events.html#ga767b12d37f7370bc5f6b3d62340f3ef8" title="カスタムイベント型を宣言します。">wxDECLARE_EVENT</a>(MY_EVENT, <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a>);

<span class="comment">// これは定義なのでヘッダ内で使用することはできません</span>
<a class="code" href="group__group__funcmacro__events.html#ga09ec1d095bee3085c1cb31459b46bc00" title="特定のイベントクラスに関連する新しいイベント型を定義します。">wxDEFINE_EVENT</a>(MY_EVENT, <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a>);

<span class="comment">// イベントテーブルによるイベント処理のコード例</span>
<a class="code" href="group__group__funcmacro__events.html#ga736930efaab4d7e445e9e8e520c7b74d" title="静的イベントハンドラの列挙を開始するために、ソースファイル内でこのマクロを使用してください。">wxBEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a>)
    EVT_MENU    (wxID_EXIT, MyFrame::OnExit)
    ...
    EVT_COMMAND (ID_MY_WINDOW, MY_EVENT, MyFrame::OnMyEvent)
<a class="code" href="group__group__funcmacro__events.html#ga383fad2a46e1d6c220fbe03ecfbc9c17" title="静的イベントハンドラの列挙を終了するために、ソースファイル内でこのマクロを使用してください。">wxEND_EVENT_TABLE</a>()

<span class="keywordtype">void</span> MyFrame::OnMyEvent(<a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a>&amp; event)
{
    <span class="comment">// 処理を行なう</span>
    <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> text = <span class="keyword">event</span>.GetString();
}

<span class="comment">// Bind&lt;&gt;() によるイベント処理のコード例:</span>
MyFrame::MyFrame()
{
    Bind(MY_EVENT, &amp;MyFrame::OnMyEvent, <span class="keyword">this</span>, ID_MY_WINDOW);
}

<span class="comment">// イベントを生成するコードの例</span>
<span class="keywordtype">void</span> MyWindow::SendEvent()
{
    <a class="code" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> event(MY_EVENT, GetId());
    <span class="keyword">event</span>.SetEventObject(<span class="keyword">this</span>);

    <span class="comment">// 何か値を設定する</span>
    <span class="keyword">event</span>.SetString(<span class="stringliteral">"Hello"</span>);

    <span class="comment">// 送信する</span>
    ProcessWindowEvent(event);
}
</pre></div><h3><a class="anchor" id="overview_events_custom_ownclass"></a>
独自のイベントクラスの定義</h3>
<p>(より複雑なデータをある場所から別の場所へ送るといった) 特定の状況下では独自のイベントクラスを定義する必要があります。イベントクラスの定義とは別に、独自のイベントテーブルマクロも定義する必要があります。</p>
<p>例を以下に示します:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// 新しいイベントクラスを定義する</span>
<span class="keyword">class </span>MyPlotEvent: <span class="keyword">public</span> <a class="code" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a>
{
<span class="keyword">public</span>:
    MyPlotEvent(<a class="code" href="group__group__funcmacro__events.html#ga6a7fd172612c0d6d9029bfa3aa91aca0" title="イベントの型を一意に識別する値。">wxEventType</a> eventType, <span class="keywordtype">int</span> winid, <span class="keyword">const</span> <a class="code" href="classwx_point.html" title="wxPoint は図形操作のための有用なデータ構造です。">wxPoint</a>&amp; pos)
        : <a class="code" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a>(winid, eventType),
          m_pos(pos)
    {
    }

    <span class="comment">// アクセサ</span>
    <a class="code" href="classwx_point.html" title="wxPoint は図形操作のための有用なデータ構造です。">wxPoint</a> GetPoint()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_pos; }

    <span class="comment">// 基底クラスの純粋仮想関数を実装する</span>
    <span class="keyword">virtual</span> <a class="code" href="classwx_event.html" title="wxEvent はコールバック関数かメンバ関数に渡されるイベントの情報を格納した構造体です。">wxEvent</a> *<a class="code" href="classwx_event.html#a26878097a702e8d0368da150125d4158" title="イベントのコピーを返却します。">Clone</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">new</span> MyPlotEvent(*<span class="keyword">this</span>); }

<span class="keyword">private</span>:
    <span class="keyword">const</span> <a class="code" href="classwx_point.html" title="wxPoint は図形操作のための有用なデータ構造です。">wxPoint</a> m_pos;
};

<span class="comment">// 上記のクラスに関連する MY_PLOT_CLICKED イベント型をひとつだけ定義しますが、</span>
<span class="comment">// 通常は複数のイベント型を持つようになるでしょう。例えば、</span>
<span class="comment">// MY_PLOT_ZOOMED や MY_PLOT_PANNED などです。</span>
<span class="comment">// そのような場合はこれと似たような行をここに追加するだけです。</span>
<a class="code" href="group__group__funcmacro__events.html#ga09ec1d095bee3085c1cb31459b46bc00" title="特定のイベントクラスに関連する新しいイベント型を定義します。">wxDEFINE_EVENT</a>(MY_PLOT_CLICKED, MyPlotEvent);


<span class="comment">// 古いコンパイラをサポートしたい場合、いくつかの醜いマクロを使用する必要があります:</span>
<span class="keyword">typedef</span> void (<a class="code" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a>::*MyPlotEventFunction)(MyPlotEvent&amp;);
<span class="preprocessor">#define MyPlotEventHandler(func) wxEVENT_HANDLER_CAST(MyPlotEventFunction, func)</span>
<span class="preprocessor"></span>
<span class="comment">// ほどほどにモダンなコンパイラのみでビルドする場合、</span>
<span class="comment">// 代わりに以下のようにするだけです:</span>
<span class="preprocessor">#define MyPlotEventHandler(func) (&amp;func)</span>
<span class="preprocessor"></span>
<span class="comment">// 最後に、新しいイベント型のイベントテーブルエントリを作成するマクロを</span>
<span class="comment">// 定義します</span>
<span class="comment">//</span>
<span class="comment">// Bind&lt;&gt;() のみを使用する場合はこうする必要がまったくないことと、</span>
<span class="comment">// 本当に古いコンパイラを使うのでなければ MyPlotEventHandler(func) の代わりに &amp;func とすることができることを</span>
<span class="comment">// 覚えておいてください</span>
<span class="preprocessor">#define MY_EVT_PLOT_CLICK(id, func) \</span>
<span class="preprocessor">    wx__DECLARE_EVT1(MY_PLOT_CLICKED, id, MyPlotEventHandler(func))</span>
<span class="preprocessor"></span>

<span class="comment">// イベント処理のサンプルコード (これらの関数のひとつを使用することになるでしょう。</span>
<span class="comment">// もちろん、両方使うことはありません):</span>
<a class="code" href="group__group__funcmacro__events.html#ga736930efaab4d7e445e9e8e520c7b74d" title="静的イベントハンドラの列挙を開始するために、ソースファイル内でこのマクロを使用してください。">wxBEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a>)
    EVT_PLOT(ID_MY_WINDOW, MyFrame::OnPlot)
<a class="code" href="group__group__funcmacro__events.html#ga383fad2a46e1d6c220fbe03ecfbc9c17" title="静的イベントハンドラの列挙を終了するために、ソースファイル内でこのマクロを使用してください。">wxEND_EVENT_TABLE</a>()

MyFrame::MyFrame()
{
    Bind(MY_PLOT_CLICKED, &amp;MyFrame::OnPlot, <span class="keyword">this</span>, ID_MY_WINDOW);
}

<span class="keywordtype">void</span> MyFrame::OnPlot(MyPlotEvent&amp; event)
{
    ...<span class="keyword">event</span>.GetPoint() を使用して処理を行なう...
}


<span class="comment">// イベントを生成するコードの例:</span>
<span class="keywordtype">void</span> MyWindow::SendEvent()
{
    MyPlotEvent event(MY_PLOT_CLICKED, GetId(), <a class="code" href="classwx_point.html" title="wxPoint は図形操作のための有用なデータ構造です。">wxPoint</a>(...));
    <span class="keyword">event</span>.SetEventObject(<span class="keyword">this</span>);
    ProcessWindowEvent(event);
}
</pre></div><h2><a class="anchor" id="overview_events_misc"></a>
雑多な覚書</h2>
<h3><a class="anchor" id="overview_events_virtual"></a>
イベントハンドラ vs 仮想関数</h3>
<p>wxWidgets の行うイベント処理の仕組みは通常の C++ の仮想関数にとても近いことに着目してください: 両方とも、継承クラスでイベント処理関数を定義することで基底クラスの振る舞いを置き換えることを可能にします。</p>
<p>しかし、継承クラスから基底クラスで実装されたデフォルトの振る舞いを呼び出すときに、このふたつの仕組みの間には重要な違いがあります。仮想関数では基底クラスの関数を直接呼び出す必要があり、継承クラスのイベントハンドラの最初 (イベントの事後処理を行なう場合) か最後 (イベントの事前処理を行なう場合) で呼ぶことができます。イベントハンドラでは選択肢は事前処理だけで、デフォルトの振る舞いを呼び出すためには <a class="el" href="classwx_event.html#a98eb20b76106f9a933c2eb3ee119f66c" title="この関数はイベントハンドラの中で使用し、現在のイベントハンドラの処理が終わった後にさらにイベントハンドラを呼び出すかどうかを制御します。">wxEvent::Skip()</a> を呼ぶ必要があり、基底クラスのイベントハンドラを直接呼び出しては <em>いけません</em> 。実際には、デフォルトの振る舞いは使用しているツールキットや OS によってプラットフォーム依存のコード内に実装されることが多いため、おそらく基底クラスにはイベントハンドラが存在しないでしょう。たとえ wxWidgets の階層に存在したとしても、イベントハンドラは wxWidgets API の一部ではないため、直接呼ぶべきではありません。</p>
<h3><a class="anchor" id="overview_events_prog"></a>
ユーザ生成イベント vs プログラム生成イベント</h3>
<p>一般的に wxEvents はユーザ操作 (<a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> のリサイズなど) と関数呼び出し (<a class="el" href="classwx_window.html#a180312d5ad4a4a5ad805b8d52d67a74e" title="ピクセル単位でウィンドウサイズを設定します。">wxWindow::SetSize</a> など) のどちらからでも発生しますが、wxCommandEvent を継承したイベントはユーザが操作した場合のみ、wxWidgets コントロールから送信されます。このルールの <b>例外</b> は以下のとおりです:</p>
<ul>
<li><a class="el" href="classwx_book_ctrl_base.html#ab47f8935c3705a452fce7d292d8181dd" title="新しいページを追加します。">wxNotebook::AddPage</a>: イベントを送信しない代替方法を持たない </li>
<li><a class="el" href="classwx_book_ctrl_base.html#a8b5b18fbf0281e99d227e574b5ffc1ac" title="タブを循環させます。">wxNotebook::AdvanceSelection</a>: イベントを送信しない代替方法を持たない </li>
<li><a class="el" href="classwx_book_ctrl_base.html#a7cbc19f60daf15af7019de20561b29f4" title="指定されたページと、それに関連するウィンドウを削除します。">wxNotebook::DeletePage</a>: イベントを送信しない代替方法を持たない </li>
<li><a class="el" href="classwx_notebook.html#a140d1743bc93c3aff36fe2c9f1cb2bc8" title="指定されたページを選択し、以前選択していたページを返却します。">wxNotebook::SetSelection</a>: <a class="el" href="classwx_notebook.html#a140d1743bc93c3aff36fe2c9f1cb2bc8" title="指定されたページを選択し、以前選択していたページを返却します。">wxNotebook::SetSelection</a> は非推奨のため、代わりに <a class="el" href="classwx_notebook.html#a82c7c7a09de4f4ec17c92af0753235d6" title="指定されたページを変更し、以前選択していたページを返却します。">wxNotebook::ChangeSelection</a> を使用してください。 </li>
<li><a class="el" href="classwx_tree_ctrl.html#a53a2292e2b7b6c13ba3e2d542d8bc1d2" title="指定された項目を削除します。">wxTreeCtrl::Delete</a>: イベントを送信しない代替方法を持たない </li>
<li><a class="el" href="classwx_tree_ctrl.html#a76de2019d0fcc73f4c302dff5d392c66" title="コントロール内のすべての項目を削除します。">wxTreeCtrl::DeleteAllItems</a>: イベントを送信しない代替方法を持たない </li>
<li><a class="el" href="classwx_tree_ctrl.html#a08d88a76e02f59001766bc90e20016b7" title="指定された項目のラベル編集を開始します。">wxTreeCtrl::EditLabel</a>: イベントを送信しない代替方法を持たない </li>
<li><a class="el" href="classwx_text_ctrl.html" title="テキストの表示と編集が可能なテキストコントロール。">wxTextCtrl</a> のすべての関数</li>
</ul>
<p><a class="el" href="classwx_text_entry.html#a90f876b2dd83ba5c97ba0c193b386e9f" title="テキストコントロールの新しい値を設定します。">wxTextCtrl::SetValue</a> の代わりに <a class="el" href="classwx_text_entry.html#a8c52ab71f51c8f80556c2c8e763cbca1" title="テキストコントロールの新しい値を設定します。">wxTextCtrl::ChangeValue</a> を使用できますが、<a class="el" href="classwx_text_entry.html#a1fb3ac76d270b2c64cff595497815f8d" title="最初の位置から最後の位置まで (ただし、含みません) のテキストを置き換えます。">wxTextCtrl::Replace</a> や <a class="el" href="classwx_text_entry.html#aa1b9419f95878c44234ff812b528c17b" title="テキストコントロールの現在の挿入位置へテキストを書き込みます。">wxTextCtrl::WriteText</a> といった他の関数にはイベントを送信せずに同じことを行う関数はありません。</p>
<h3><a class="anchor" id="overview_events_pluggable"></a>
動的イベントハンドラ</h3>
<p><em>TODO: おそらく非推奨であり、Bind() がより良い方法を提供しています。</em></p>
<p>実際のところ、ウィンドウクラスを継承して新しいクラスを作成したくない場合は、必ずしもそうする必要はありません。代わりに <a class="el" href="classwx_evt_handler.html" title="ウィンドウから送信されるベントを処理可能なクラス。">wxEvtHandler</a> を継承した新しいクラスを作成して適切なイベントテーブルを定義し、<a class="el" href="classwx_window.html#af6c84b7679183b377ba27a52a2f708b4" title="このウィンドウのイベントハンドラを設定します。">wxWindow::SetEventHandler</a> (か、より望ましくは <a class="el" href="classwx_window.html#a398c11ab9af7956067a964f560d1978c" title="このイベントハンドラをウィンドウのイベントスタック上に追加します。">wxWindow::PushEventHandler</a>) を呼び出してこのイベントテーブルを使用するようにできます。この方法を使うことで、たくさんの継承クラスを作成しなくてすむとともに、同じイベントハンドラクラスのインスタンスを異なるウィジェットクラスのインスタンスから利用することができます。 (ただし、異なるオブジェクトを同じイベントハンドラオブジェクトとして複数回使用するべきではありません) </p>
<p>もし手動でウィンドウのイベントハンドラを呼ぶ必要がある場合、GetEventHandler 関数でウィンドウのイベントハンドラを取得し、そのメンバ関数を呼び出してください。SetEventHandler や PushEventHandler を使用してイベント処理をリダイレクトしていない場合、デフォルトでは GetEventHandler はウィンドウ自身を返却します。</p>
<p>PushEventHandler の使用法のひとつは、一時的または永続的に GUI の振る舞いを変更することです。例えば、ダイアログの外見を変更するためのダイアログエディタをアプリケーション内で起動したいと思うかもしれません。その場合、既存のダイアログの振る舞いを元に戻す前にすべての入力を取得し、"その場で" 編集することができます。そのため、アプリケーションの振る舞いをカスタマイズするために新しいクラスを継承していたとしても、あなたのユーティリティから自由に振る舞いを変更することができます。これはオンラインチュートリアルでも有用なテクニックです。レッスンから外れることなく、ユーザに一連のステップを実行させることができます。ここでは、ボタンやウィンドウから送られてくるイベントを検証し、それが適用可能なものである場合に元のイベントハンドラへ渡す、ということを行えます。他のイベントハンドラとは異なる範囲のイベントを独立して処理するようなイベントハンドラを作成する場合に PushEventHandler/PopEventHandler を使用してください。</p>
<h3><a class="anchor" id="overview_events_winid"></a>
ウィンドウ識別子</h3>
<p>ウィンドウ識別子とは、イベントシステムにおいてウィンドウを一意に識別するための整数値です。 (とはいえ、他の用途に使用することもできます)  実際には、特定のコンテキスト (フレームやその子コントロール) 内で一意であれば、アプリケーション全体で一意である必要はありません。例えば、同じダイアログ内で複数回使うのでなければ、いくつものダイアログで <code>wxID_OK</code> 識別子を使用しても構いません。</p>
<p>ウィンドウのコンストラクタに <code>wxID_ANY</code> を渡した場合、wxWidgets が自動的に識別子を生成します。コントロールの生成するイベントを処理しない場合や、イベントを一箇所で処理する場合 (このときはイベントテーブルに <code>wxID_ANY</code> を指定するか、同じように <a class="el" href="classwx_evt_handler.html#a84b1e446053bda8f76f13336839e8b64" title="指定された関数、ファンクタ、メンバ関数をイベントへ動的にバインドします。">wxEvtHandler::Bind</a> を呼ぶ必要があります) など、コントロールの正確な識別子が必要でないときにこれは役立ちます。自動生成される識別子は常に負の値のため、必ず正の値でなければならないユーザ定義の識別子と衝突することはありません。</p>
<p>使用可能な標準識別子のリストは <a class="el" href="page_stdevtid.html">標準イベント識別子</a> を参照してください。新たな識別子を定義する場合、wxID_HIGHEST 以上の値を使用することで安全に値を決定することができます。もしくは wxID_LOWEST 以下の識別子を使用することもできます。最後に、<a class="el" href="group__group__funcmacro__misc.html#gaef162e1ba5d17a839b2f7912424bc822">wxNewId()</a> を使用して動的に識別子を割り当てることもできます。もしアプリケーション内で一貫して <a class="el" href="group__group__funcmacro__misc.html#gaef162e1ba5d17a839b2f7912424bc822">wxNewId()</a> を使用するようにすれば、偶発的な識別子の衝突を避けることが可能です。</p>
<h3><a class="anchor" id="overview_events_custom_generic"></a>
汎用的なイベントテーブルマクロ</h3>
<table  class="doctable" border="1" cellspacing="0" cellpadding="3">
<tr>
<td>EVT_CUSTOM(event, id, func)  </td><td>(wxEVT_SIZE といった) イベント識別子、ウィンドウ識別子、呼び出すメンバ関数を指定してカスタムイベントのエントリをイベントテーブルへ追加することができます。 </td></tr>
<tr>
<td>EVT_CUSTOM_RANGE(event, id1, id2, func)  </td><td>EVT_CUSTOM と同じですが、ウィンドウ識別子を範囲で指定できます。 </td></tr>
<tr>
<td>EVT_COMMAND(id, event, func)  </td><td>EVT_CUSTOM と同じですが、<a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> を引数に取るメンバ関数を指定します。 </td></tr>
<tr>
<td>EVT_COMMAND_RANGE(id1, id2, event, func)  </td><td>EVT_CUSTOM_RANGE と同じですが、<a class="el" href="classwx_command_event.html" title="このイベントクラスは様々な単純コントロールから送信されるコマンドイベントに関する情報を含んでいます。">wxCommandEvent</a> を引数に取るメンバ関数を指定します。 </td></tr>
<tr>
<td>EVT_NOTIFY(event, id, func)  </td><td>EVT_CUSTOM と同じですが、<a class="el" href="classwx_notify_event.html" title="このクラスはイベントハンドラ自身では使用されませんが、(wxBookCtrlEvent などの) 他のイベントクラスの基底クラスです。 ">wxNotifyEvent</a> を引数に取るメンバ関数を指定します。 </td></tr>
<tr>
<td>EVT_NOTIFY_RANGE(event, id1, id2, func)  </td><td>EVT_CUSTOM_RANGE と同じですが、<a class="el" href="classwx_notify_event.html" title="このクラスはイベントハンドラ自身では使用されませんが、(wxBookCtrlEvent などの) 他のイベントクラスの基底クラスです。 ">wxNotifyEvent</a> を引数に取るメンバ関数を指定します。 </td></tr>
</table>
<h3><a class="anchor" id="overview_events_list"></a>
wxWidgets のイベント一覧</h3>
<p>イベントクラスの完全な一覧は <a class="el" href="group__group__class__events.html">イベントクラスグループ</a> を参照してください。 </p>
</div></div><!-- window showing the filter options -->

<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div><!-- iframe showing the search results (closed by default) -->


<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/>
<address class="footer">
	<small>
		
		Page generated on Mon Jul 9 2012 15:04:15 by  <!--[Doxygen 1.7.6+] $generatedby -->
		<a href="http://www.doxygen.org/index.html" target="_new">Doxygen</a> 1.7.4
	
	</small>
</address>


<script src="wxwidgets.js" type="text/javascript"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body>
</html>
