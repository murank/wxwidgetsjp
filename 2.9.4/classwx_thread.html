<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>wxWidgets: wxWidgets: wxThread Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery-1.3.2.min.js"></script>

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr>
  
  <td id="projectlogo"><a href="http://www.wxwidgets.org/" target="_new"><img alt="Logo" src="logo.png"/></a></td>
  
  <td style="padding: 0.5em; text-align: right;">
   <span id="projectnumber">Version: 2.9.4</span>
  </td>
  
 </tr>
 </tbody>
</table>
</div><!-- Generated by Doxygen 1.7.4 -->


<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>カテゴリ</span></a></li>
      <li class="current"><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li><a href="dirs.html"><span>ディレクトリ</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> |
<a href="#pub-methods">Public Member Functions</a> |
<a href="#pub-static-methods">Static Public Member Functions</a> |
<a href="#pro-methods">Protected Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">wxThread Class Reference<div class="ingroups"><a class="el" href="group__group__class__threading.html">Threading</a></div></div>  </div>
</div>
<div class="contents"><!-- doxytag: class="wxThread" -->

<p><code>#include &lt;/home/zeitlin/src/wx/github/interface/wx/thread.h&gt;</code></p>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>A thread is basically a path of execution through a program.  </p>
<p>Threads are sometimes called <em>light-weight</em> processes, but the fundamental difference between threads and processes is that memory spaces of different processes are separated while all threads share the same address space.</p>
<p>While it makes it much easier to share common data between several threads, it also makes it much easier to shoot oneself in the foot, so careful use of synchronization objects such as mutexes (see <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>) or critical sections (see <a class="el" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a>) is recommended. In addition, don't create global thread objects because they allocate memory in their constructor, which will cause problems for the memory checking system.</p>
<h2><a class="anchor" id="thread_types"></a>

Types of wxThreads</h2>
<p>There are two types of threads in wxWidgets: <em>detached</em> and <em>joinable</em>, modeled after the POSIX thread API. This is different from the Win32 API where all threads are joinable.</p>
<p>By default wxThreads in wxWidgets use the <b>detached</b> behaviour. Detached threads delete themselves once they have completed, either by themselves when they complete processing or through a call to <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a>, and thus <b>must</b> be created on the heap (through the new operator, for example).</p>
<p>Typically you'll want to store the instances of the detached wxThreads you allocate, so that you can call functions on them. Because of their nature however you'll need to always use a critical section when accessing them:</p>
<div class="fragment"><pre class="fragment">    <span class="comment">// declare a new type of event, to be used by our MyThread class:</span>
    <a class="code" href="group__group__funcmacro__events.html#ga767b12d37f7370bc5f6b3d62340f3ef8" title="カスタムイベント型を宣言します。">wxDECLARE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>);
    <a class="code" href="group__group__funcmacro__events.html#ga767b12d37f7370bc5f6b3d62340f3ef8" title="カスタムイベント型を宣言します。">wxDECLARE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_UPDATE, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>);
    <span class="keyword">class </span>MyFrame;

    <span class="keyword">class </span>MyThread : <span class="keyword">public</span> <a class="code" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a>
    {
    <span class="keyword">public</span>:
        MyThread(MyFrame *handler)
            : <a class="code" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a>(<a class="code" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0acd9af5dbbc12a95684ab6e7be16e30c9" title="Detached thread.">wxTHREAD_DETACHED</a>)
            { m_pHandler = handler }
        ~MyThread();

    <span class="keyword">protected</span>:
        <span class="keyword">virtual</span> <a class="code" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">ExitCode</a> <a class="code" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry</a>();
        MyFrame *m_pHandler;
    };

    <span class="keyword">class </span>MyFrame : <span class="keyword">public</span> <a class="code" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a>
    {
    <span class="keyword">public</span>:
        ...
        ~MyFrame()
        {
            <span class="comment">// it's better to do any thread cleanup in the OnClose()</span>
            <span class="comment">// event handler, rather than in the destructor.</span>
            <span class="comment">// This is because the event loop for a top-level window is not</span>
            <span class="comment">// active anymore when its destructor is called and if the thread</span>
            <span class="comment">// sends events when ending, they won't be processed unless</span>
            <span class="comment">// you ended the thread from OnClose.</span>
            <span class="comment">// See @ref overview_windowdeletion for more info.</span>
        }
        ...
        <span class="keywordtype">void</span> DoStartThread();
        <span class="keywordtype">void</span> DoPauseThread();

        <span class="comment">// a resume routine would be nearly identic to DoPauseThread()</span>
        <span class="keywordtype">void</span> DoResumeThread() { ... }

        <span class="keywordtype">void</span> OnThreadUpdate(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;);
        <span class="keywordtype">void</span> OnThreadCompletion(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;);
        <span class="keywordtype">void</span> OnClose(<a class="code" href="classwx_close_event.html" title="This event class contains information about window and session close events.">wxCloseEvent</a>&amp;);

    <span class="keyword">protected</span>:
        MyThread *m_pThread;
        <a class="code" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a> m_pThreadCS;    <span class="comment">// protects the m_pThread pointer</span>

        <a class="code" href="group__group__funcmacro__events.html#gab6eca03fad44ec10b75d3cb82e9219e3" title="静的イベントテーブルを宣言するために、クラス宣言の中でこのマクロを使用してください。">wxDECLARE_EVENT_TABLE</a>();
    };

    <a class="code" href="group__group__funcmacro__events.html#ga736930efaab4d7e445e9e8e520c7b74d" title="静的イベントハンドラの列挙を開始するために、ソースファイル内でこのマクロを使用してください。">wxBEGIN_EVENT_TABLE</a>(MyFrame, <a class="code" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a>)
        EVT_CLOSE(MyFrame::OnClose)
        EVT_MENU(Minimal_Start,  MyFrame::DoStartThread)
        EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_MYTHREAD_UPDATE, MyFrame::OnThreadUpdate)
        EVT_COMMAND(wxID_ANY, wxEVT_COMMAND_MYTHREAD_COMPLETED, MyFrame::OnThreadCompletion)
    <a class="code" href="group__group__funcmacro__events.html#ga383fad2a46e1d6c220fbe03ecfbc9c17" title="静的イベントハンドラの列挙を終了するために、ソースファイル内でこのマクロを使用してください。">wxEND_EVENT_TABLE</a>()

    <a class="code" href="group__group__funcmacro__events.html#ga09ec1d095bee3085c1cb31459b46bc00" title="特定のイベントクラスに関連する新しいイベント型を定義します。">wxDEFINE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>)
    <a class="code" href="group__group__funcmacro__events.html#ga09ec1d095bee3085c1cb31459b46bc00" title="特定のイベントクラスに関連する新しいイベント型を定義します。">wxDEFINE_EVENT</a>(wxEVT_COMMAND_MYTHREAD_UPDATE, <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>)

    <span class="keywordtype">void</span> MyFrame::DoStartThread()
    {
        m_pThread = <span class="keyword">new</span> MyThread(<span class="keyword">this</span>);

        <span class="keywordflow">if</span> ( m_pThread-&gt;Create() != <a class="code" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
        {
            <a class="code" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't create the thread!"</span>);
            <span class="keyword">delete</span> m_pThread;
            m_pThread = NULL;
        }
        <span class="keywordflow">else</span>
        {
            <span class="keywordflow">if</span> (m_pThread-&gt;Run() != <a class="code" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
            {
                <a class="code" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't create the thread!"</span>);
                <span class="keyword">delete</span> m_pThread;
                m_pThread = NULL;
            }

            <span class="comment">// after the call to wxThread::Run(), the m_pThread pointer is "unsafe":</span>
            <span class="comment">// at any moment the thread may cease to exist (because it completes its work).</span>
            <span class="comment">// To avoid dangling pointers OnThreadExit() will set m_pThread</span>
            <span class="comment">// to NULL when the thread dies.</span>
        }
    }

    <a class="code" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">wxThread::ExitCode</a> <a class="code" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">MyThread::Entry</a>()
    {
        <span class="keywordflow">while</span> (!<a class="code" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy</a>())
        {
            <span class="comment">// ... do a bit of work...</span>

            <a class="code" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="特定のオブジェクトで処理するためにイベントをキューへ追加します。">wxQueueEvent</a>(m_pHandler, <span class="keyword">new</span> <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>(wxEVT_COMMAND_MYTHREAD_UPDATE));
        }

        <span class="comment">// signal the event handler that this thread is going to be destroyed</span>
        <span class="comment">// NOTE: here we assume that using the m_pHandler pointer is safe,</span>
        <span class="comment">//       (in this case this is assured by the MyFrame destructor)</span>
        <a class="code" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="特定のオブジェクトで処理するためにイベントをキューへ追加します。">wxQueueEvent</a>(m_pHandler, <span class="keyword">new</span> <a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>(wxEVT_COMMAND_MYTHREAD_COMPLETED));

        <span class="keywordflow">return</span> (<a class="code" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028" title="The return type for the thread functions.">wxThread::ExitCode</a>)0;     <span class="comment">// success</span>
    }

    MyThread::~MyThread()
    {
        <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pHandler-&gt;m_pThreadCS);

        <span class="comment">// the thread is being destroyed; make sure not to leave dangling pointers around</span>
        m_pHandler-&gt;m_pThread = NULL;
    }

    <span class="keywordtype">void</span> MyFrame::OnThreadCompletion(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;)
    {
        <a class="code" href="classwx_message_output_debug.html" title="Output messages to the system debug output channel.">wxMessageOutputDebug</a>().<a class="code" href="classwx_message_output.html#a233e76ce6c1b569f16b42b49151ab979" title="Output a message.">Printf</a>(<span class="stringliteral">"MYFRAME: MyThread exited!\n"</span>);
    }

    <span class="keywordtype">void</span> MyFrame::OnThreadUpdate(<a class="code" href="classwx_thread_event.html" title="This class adds some simple functionality to wxEvent to facilitate inter-thread communication.">wxThreadEvent</a>&amp;)
    {
        <a class="code" href="classwx_message_output_debug.html" title="Output messages to the system debug output channel.">wxMessageOutputDebug</a>().<a class="code" href="classwx_message_output.html#a233e76ce6c1b569f16b42b49151ab979" title="Output a message.">Printf</a>(<span class="stringliteral">"MYFRAME: MyThread update...\n"</span>);
    }

    <span class="keywordtype">void</span> MyFrame::DoPauseThread()
    {
        <span class="comment">// anytime we access the m_pThread pointer we must ensure that it won't</span>
        <span class="comment">// be modified in the meanwhile; since only a single thread may be</span>
        <span class="comment">// inside a given critical section at a given time, the following code</span>
        <span class="comment">// is safe:</span>
        <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);

        <span class="keywordflow">if</span> (m_pThread)         <span class="comment">// does the thread still exist?</span>
        {
            <span class="comment">// without a critical section, once reached this point it may happen</span>
            <span class="comment">// that the OS scheduler gives control to the MyThread::Entry() function,</span>
            <span class="comment">// which in turn may return (because it completes its work) making</span>
            <span class="comment">// invalid the m_pThread pointer</span>

            <span class="keywordflow">if</span> (m_pThread-&gt;Pause() != <a class="code" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
                <a class="code" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't pause the thread!"</span>);
        }
    }

    <span class="keywordtype">void</span> MyFrame::OnClose(<a class="code" href="classwx_close_event.html" title="This event class contains information about window and session close events.">wxCloseEvent</a>&amp;)
    {
        {
            <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);

            <span class="keywordflow">if</span> (m_pThread)         <span class="comment">// does the thread still exist?</span>
            {
                <a class="code" href="classwx_message_output_debug.html" title="Output messages to the system debug output channel.">wxMessageOutputDebug</a>().<a class="code" href="classwx_message_output.html#a233e76ce6c1b569f16b42b49151ab979" title="Output a message.">Printf</a>(<span class="stringliteral">"MYFRAME: deleting thread"</span>);

                <span class="keywordflow">if</span> (m_pThread-&gt;Delete() != <a class="code" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2ad1525fe128b4989cb43a7e8112ac1b13" title="No error.">wxTHREAD_NO_ERROR</a> )
                    <a class="code" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="The functions to use for error messages, i.e.">wxLogError</a>(<span class="stringliteral">"Can't delete the thread!"</span>);
            }
        }       <span class="comment">// exit from the critical section to give the thread</span>
                <span class="comment">// the possibility to enter its destructor</span>
                <span class="comment">// (which is guarded with m_pThreadCS critical section!)</span>

        <span class="keywordflow">while</span> (1)
        {
            { <span class="comment">// was the ~MyThread() function executed?</span>
                <a class="code" href="classwx_critical_section_locker.html" title="This is a small helper class to be used with wxCriticalSection objects.">wxCriticalSectionLocker</a> enter(m_pThreadCS);
                <span class="keywordflow">if</span> (!m_pThread) <span class="keywordflow">break</span>;
            }

            <span class="comment">// wait for thread completion</span>
            <a class="code" href="classwx_thread.html#a7077fa46ffef0fd1d023628776598335" title="Return the thread object for the calling thread.">wxThread::This</a>()-&gt;<a class="code" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep</a>(1);
        }

        Destroy();
    }
</pre></div><p>For a more detailed and comprehensive example, see <a class="el" href="page_samples.html#page_samples_thread">Thread Sample</a>. For a simpler way to share data and synchronization objects between the main and the secondary thread see <a class="el" href="classwx_thread_helper.html" title="The wxThreadHelper class is a mix-in class that manages a single background thread, either detached or joinable (see wxThread for the differences).">wxThreadHelper</a>.</p>
<p>Conversely, <b>joinable</b> threads do not delete themselves when they are done processing and as such are safe to create on the stack. Joinable threads also provide the ability for one to get value it returned from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> through <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a>. You shouldn't hurry to create all the threads joinable, however, because this has a disadvantage as well: you <b>must</b> <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a> for a joinable thread or the system resources used by it will never be freed, and you also must delete the corresponding <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object yourself if you did not create it on the stack. In contrast, detached threads are of the "fire-and-forget" kind: you only have to start a detached thread and it will terminate and destroy itself.</p>
<h2><a class="anchor" id="thread_deletion"></a>

wxThread Deletion</h2>
<p>Regardless of whether it has terminated or not, you should call <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a> on a <b>joinable</b> thread to release its memory, as outlined in <a class="el" href="classwx_thread.html#thread_types">Types of wxThreads</a>. If you created a joinable thread on the heap, remember to delete it manually with the <code>delete</code> operator or similar means as only detached threads handle this type of memory management.</p>
<p>Since <b>detached</b> threads delete themselves when they are finished processing, you should take care when calling a routine on one. If you are certain the thread is still running and would like to end it, you may call <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> to gracefully end it (which implies that the thread will be deleted after that call to <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a>). It should be implied that you should <b>never</b> attempt to delete a detached thread with the <code>delete</code> operator or similar means.</p>
<p>As mentioned, <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a> or <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> functions attempt to gracefully terminate a joinable and a detached thread, respectively. They do this by waiting until the thread in question calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> or ends processing (i.e. returns from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">wxThread::Entry</a>).</p>
<p>Obviously, if the thread does call <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> and does not end, the thread which called <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a> or <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> will come to halt. This is why it's important to call <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> in the <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> routine of your threads as often as possible and immediately exit when it returns <span class="literal">true</span>.</p>
<p>As a last resort you can end the thread immediately through <a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a>. It is strongly recommended that you do not do this, however, as it does not free the resources associated with the object (although the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object of detached threads will still be deleted) and could leave the C runtime library in an undefined state.</p>
<h2><a class="anchor" id="thread_secondary"></a>

wxWidgets Calls in Secondary Threads</h2>
<p>All threads other than the "main application thread" (the one running <a class="el" href="classwx_app_console.html#a99953775a2fd83fa2456e390779afe15" title="This must be provided by the application, and will usually create the application's main window...">wxApp::OnInit()</a> or the one your main function runs in, for example) are considered "secondary threads". These include all threads created by <a class="el" href="classwx_thread.html#a88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a> or the corresponding constructors.</p>
<p>GUI calls, such as those to a <a class="el" href="classwx_window.html" title="wxWindow はすべてのウィンドウの基底クラスであり、画面上に表示されるすべての可視オブジェクトを表しています。">wxWindow</a> or <a class="el" href="classwx_bitmap.html" title="This class encapsulates the concept of a platform-dependent bitmap, either monochrome or colour or co...">wxBitmap</a> are explicitly not safe at all in secondary threads and could end your application prematurely. This is due to several reasons, including the underlying native API and the fact that <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> does not run a GUI event loop similar to other APIs as MFC.</p>
<p>A workaround for some wxWidgets ports is calling wxMutexGUIEnter() before any GUI calls and then calling wxMutexGUILeave() afterwords. However, the recommended way is to simply process the GUI calls in the main thread through an event that is posted by <a class="el" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="特定のオブジェクトで処理するためにイベントをキューへ追加します。">wxQueueEvent()</a>. This does not imply that calls to these classes are thread-safe, however, as most wxWidgets classes are not thread-safe, including <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a>.</p>
<h2><a class="anchor" id="thread_poll"></a>

Don't Poll a wxThread</h2>
<p>A common problem users experience with <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> is that in their main thread they will check the thread every now and then to see if it has ended through <a class="el" href="classwx_thread.html#a0230733ffdc8f7603082dd2ca86b8cdd" title="Returns true if the thread is running.">IsRunning()</a>, only to find that their application has run into problems because the thread is using the default behaviour (i.e. it's <b>detached</b>) and has already deleted itself. Naturally, they instead attempt to use joinable threads in place of the previous behaviour. However, polling a <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> for when it has ended is in general a bad idea - in fact calling a routine on any running <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> should be avoided if possible. Instead, find a way to notify yourself when the thread has ended.</p>
<p>Usually you only need to notify the main thread, in which case you can post an event to it via <a class="el" href="group__group__funcmacro__events.html#gae921d7bd0e52fedbf3f253d2c408bce1" title="特定のオブジェクトで処理するためにイベントをキューへ追加します。">wxQueueEvent()</a>. In the case of secondary threads you can call a routine of another class when the thread is about to complete processing and/or set the value of a variable, possibly using mutexes (see <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>) and/or other synchronization means if necessary.</p>
<h2></h2>
<div><span class="lib">Library:</span>&nbsp;&nbsp;<span class="lib_text"><a class="el" href="page_libs.html#page_libs_wxbase">wxBase</a></span></div><div><span class="category">Category:</span>&nbsp;&nbsp;<span class="category_text"><a class="el" href="group__group__class__threading.html">Threading</a></span></div><dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classwx_thread_helper.html" title="The wxThreadHelper class is a mix-in class that manages a single background thread, either detached or joinable (see wxThread for the differences).">wxThreadHelper</a>, <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>, <a class="el" href="classwx_condition.html" title="wxCondition variables correspond to pthread conditions or to Win32 event objects.">wxCondition</a>, <a class="el" href="classwx_critical_section.html" title="A critical section object is used for exactly the same purpose as a wxMutex.">wxCriticalSection</a>, <a class="el" href="overview_thread.html">Multithreading Overview</a> </dd></dl>
</div><table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>

Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The return type for the thread functions.    <a href="#ade9497fa072fe19481086e6486dcc028"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>

Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#aafdb64801bd4d595ad0956f71d5791f0">wxThread</a> (<a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a> kind=wxTHREAD_DETACHED)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This constructor creates a new detached (default) or joinable C++ thread object.    <a href="#aafdb64801bd4d595ad0956f71d5791f0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a48c37f3555eb99cca9d9f3594fed5793">~wxThread</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The destructor frees the resources associated with the thread.    <a href="#a48c37f3555eb99cca9d9f3594fed5793"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a88051a33aa3fa9ca9392ac7d47b43cf4">Create</a> (unsigned int stackSize=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a new thread.    <a href="#a88051a33aa3fa9ca9392ac7d47b43cf4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4">Delete</a> (<a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> *rc=NULL, <a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a> waitMode=wxTHREAD_WAIT_BLOCK)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Calling <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> gracefully terminates a <b>detached</b> thread, either when the thread calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> or when it finishes processing.    <a href="#a66796042bf5f3eb33a0ad3db85f686d4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">wxThreadIdType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a2c9db3ca1d37d8ed921e78c31acd9bb4">GetId</a> () const  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e.    <a href="#a2c9db3ca1d37d8ed921e78c31acd9bb4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a1fc5fa753cf2bc0ec63ff16825a144b2">GetKind</a> () const  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the thread kind as it was given in the ctor.    <a href="#a1fc5fa753cf2bc0ec63ff16825a144b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a785ac6add565d789481f8a9dfde5c229">GetPriority</a> () const  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the priority of the thread, between zero and 100.    <a href="#a785ac6add565d789481f8a9dfde5c229"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#adc6cf71c426b1da03c6ca4b7f7da8aab">IsAlive</a> () const  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is alive (i.e.    <a href="#adc6cf71c426b1da03c6ca4b7f7da8aab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a315c2abb553ba7e17ab2d5b2a0728e73">IsDetached</a> () const  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is of the detached kind, <span class="literal">false</span> if it is a joinable one.    <a href="#a315c2abb553ba7e17ab2d5b2a0728e73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a34328ecb720a1066971fb5e48cd84b6f">IsPaused</a> () const  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is paused.    <a href="#a34328ecb720a1066971fb5e48cd84b6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a0230733ffdc8f7603082dd2ca86b8cdd">IsRunning</a> () const  </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the thread is running.    <a href="#a0230733ffdc8f7603082dd2ca86b8cdd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4">Kill</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Immediately terminates the target thread.    <a href="#a2cbff8b3b0a93ab82f212c02f38a1ef4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba">Pause</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Suspends the thread.    <a href="#a8c6d835578dde71dd2c241c38336a4ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#afe81d37cd6cb6d5eb142773fb2c94562">Resume</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resumes a thread suspended by the call to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a>.    <a href="#afe81d37cd6cb6d5eb142773fb2c94562"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0">Run</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the thread execution.    <a href="#a5d894750ffaac8fc42ee85aeff8bb4c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a6236828fe98e81103219a519fbd7091d">SetPriority</a> (unsigned int priority)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the priority of the thread, between 0 and 100.    <a href="#a6236828fe98e81103219a519fbd7091d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac">TestDestroy</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function should be called periodically by the thread to ensure that calls to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> and <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> will work.    <a href="#a9a3acec44b06b2a2430c5659991a3eac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e">Wait</a> (<a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a> flags=wxTHREAD_WAIT_BLOCK)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Waits for a <b>joinable</b> thread to terminate and returns the value the thread returned from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> or <code>"(ExitCode)-1"</code> on error.    <a href="#a62ee778033013d3a4754b71b8cf2902e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>

Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a21ccbc2f91bed8d65aeada49a7f8335d">GetCPUCount</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of system CPUs or -1 if the value is unknown.    <a href="#a21ccbc2f91bed8d65aeada49a7f8335d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static wxThreadIdType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a414fecfb855a7e12088bb0fa54ebd330">GetCurrentId</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the platform specific thread ID of the current thread as a long.    <a href="#a414fecfb855a7e12088bb0fa54ebd330"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static wxThreadIdType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a0023e6e671b016f06c452f34dd6ce8f4">GetMainId</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the thread ID of the main thread.    <a href="#a0023e6e671b016f06c452f34dd6ce8f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a1ee917ef87f986ba3b2ee26e620378e4">IsMain</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns <span class="literal">true</span> if the calling thread is the main application thread.    <a href="#a1ee917ef87f986ba3b2ee26e620378e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a09dfe3800bbfad53be303a4608d52959">SetConcurrency</a> (size_t level)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the thread concurrency level for this process.    <a href="#a09dfe3800bbfad53be303a4608d52959"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6">Sleep</a> (unsigned long milliseconds)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Pauses the thread execution for the given amount of time.    <a href="#a9ae47b39270c54dba5534af31f885ec6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classwx_thread.html">wxThread</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a7077fa46ffef0fd1d023628776598335">This</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the thread object for the calling thread.    <a href="#a7077fa46ffef0fd1d023628776598335"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6">Yield</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Give the rest of the thread's time-slice to the system allowing the other threads to run.    <a href="#a7a36099bab2d4be9d72cfd4cf76e8aa6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-methods"></a>

Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d">Entry</a> ()=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is the entry point of the thread.    <a href="#af50fa7d3ac55002e367e79989b9cbc5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwx_thread.html#a888b9b94f64a2b61bd4740de1149e6e2">Exit</a> (<a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> exitcode=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is a protected function of the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class and thus can only be called from a derived class.    <a href="#a888b9b94f64a2b61bd4740de1149e6e2"></a><br/></td></tr>
</table>

<p><a href="classwx_thread-members.html">List of all members.</a></p>
<hr/><h2>Member Typedef Documentation</h2><!-- doxytag: member="wxThread::ExitCode" ref="ade9497fa072fe19481086e6486dcc028" args="" -->
<a class="anchor" id="ade9497fa072fe19481086e6486dcc028"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">wxThread::ExitCode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The return type for the thread functions.  </p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2><!-- doxytag: member="wxThread::wxThread" ref="aafdb64801bd4d595ad0956f71d5791f0" args="(wxThreadKind kind=wxTHREAD_DETACHED)" -->
<a class="anchor" id="aafdb64801bd4d595ad0956f71d5791f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThread::wxThread  </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a>&nbsp;</td>
          <td class="paramname"><em>kind</em> = <code>wxTHREAD_DETACHED</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This constructor creates a new detached (default) or joinable C++ thread object.  </p>
<p>It does not create or start execution of the real thread - for this you should use the <a class="el" href="classwx_thread.html#a88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a> and <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> methods.</p>
<p>The possible values for <em>kind</em> parameters are:</p>
<ul>
<li><b>wxTHREAD_DETACHED</b> - Creates a detached thread.</li>
<li><b>wxTHREAD_JOINABLE</b> - Creates a joinable thread.  </li>
</ul>

</div>
</div><!-- doxytag: member="wxThread::~wxThread" ref="a48c37f3555eb99cca9d9f3594fed5793" args="()" -->
<a class="anchor" id="a48c37f3555eb99cca9d9f3594fed5793"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual wxThread::~wxThread  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The destructor frees the resources associated with the thread.  </p>
<p>Notice that you should never delete a detached thread -- you may only call <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> on it or wait until it terminates (and auto destructs) itself.</p>
<p>Because the detached threads delete themselves, they can only be allocated on the heap. Joinable threads should be deleted explicitly. The <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> and <a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a> functions will not delete the C++ thread object. It is also safe to allocate them on stack.  </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2><!-- doxytag: member="wxThread::Create" ref="a88051a33aa3fa9ca9392ac7d47b43cf4" args="(unsigned int stackSize=0)" -->
<a class="anchor" id="a88051a33aa3fa9ca9392ac7d47b43cf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Create  </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"><em>stackSize</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Creates a new thread.  </p>
<p>The thread object is created in the suspended state, and you should call <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> to start running it. You may optionally specify the stack size to be allocated to it (Ignored on platforms that don't support setting it explicitly, eg. Unix system without <code>pthread_attr_setstacksize</code>).</p>
<p>If you do not specify the stack size,the system's default value is used.</p>
<dl class="warning"><dt><b>Warning:</b></dt><dd>It is a good idea to explicitly specify a value as systems' default values vary from just a couple of KB on some systems (BSD and OS/2 systems) to one or several MB (Windows, Solaris, Linux). So, if you have a thread that requires more than just a few KB of memory, you will have mysterious problems on some platforms but not on the common ones. On the other hand, just indicating a large stack size by default will give you performance issues on those systems with small default stack since those typically use fully committed memory for the stack. On the contrary, if you use a lot of threads (say several hundred), virtual address space can get tight unless you explicitly specify a smaller amount of thread stack space for each thread.</dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>One of:<ul>
<li><b>wxTHREAD_NO_ERROR</b> - No error.</li>
<li><b>wxTHREAD_NO_RESOURCE</b> - There were insufficient resources to create the thread.</li>
<li><b>wxTHREAD_NO_RUNNING</b> - The thread is already running  </li>
</ul>
</dd></dl>

</div>
</div><!-- doxytag: member="wxThread::Delete" ref="a66796042bf5f3eb33a0ad3db85f686d4" args="(ExitCode *rc=NULL, wxThreadWait waitMode=wxTHREAD_WAIT_BLOCK)" -->
<a class="anchor" id="a66796042bf5f3eb33a0ad3db85f686d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Delete  </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> *&nbsp;</td>
          <td class="paramname"><em>rc</em> = <code>NULL</code>,  </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a>&nbsp;</td>
          <td class="paramname"><em>waitMode</em> = <code>wxTHREAD_WAIT_BLOCK</code>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calling <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> gracefully terminates a <b>detached</b> thread, either when the thread calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> or when it finishes processing.  </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">rc</td><td>The thread exit code, if rc is not NULL.</td></tr>
    <tr><td class="paramname">waitMode</td><td>As described in wxThreadWait documentation, wxTHREAD_WAIT_BLOCK should be used as the wait mode even although currently wxTHREAD_WAIT_YIELD is for compatibility reasons. This parameter is new in wxWidgets 2.9.2.</td></tr>
  </table>
  </dd>
</dl>
<dl class="note"><dt><b>注:</b></dt><dd>This function works on a joinable thread but in that case makes the <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> function of the thread return <span class="literal">true</span> and then waits for its completion (i.e. it differs from <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a> because it asks the thread to terminate before waiting).</dd></dl>
<p>See <a class="el" href="classwx_thread.html#thread_deletion">wxThread Deletion</a> for a broader explanation of this routine.  </p>

</div>
</div><!-- doxytag: member="wxThread::Entry" ref="af50fa7d3ac55002e367e79989b9cbc5d" args="()=0" -->
<a class="anchor" id="af50fa7d3ac55002e367e79989b9cbc5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> wxThread::Entry  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [protected, pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the entry point of the thread.  </p>
<p>This function is pure virtual and must be implemented by any derived class. The thread execution will start here.</p>
<p>The returned value is the thread exit code which is only useful for joinable threads and is the value returned by <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a>. This function is called by wxWidgets itself and should never be called directly.  </p>

</div>
</div><!-- doxytag: member="wxThread::Exit" ref="a888b9b94f64a2b61bd4740de1149e6e2" args="(ExitCode exitcode=0)" -->
<a class="anchor" id="a888b9b94f64a2b61bd4740de1149e6e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::Exit  </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a>&nbsp;</td>
          <td class="paramname"><em>exitcode</em> = <code>0</code></td><td>)</td>
          <td><code>  [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is a protected function of the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class and thus can only be called from a derived class.  </p>
<p>It also can only be called in the context of this thread, i.e. a thread can only exit from itself, not from another thread.</p>
<p>This function will terminate the OS thread (i.e. stop the associated path of execution) and also delete the associated C++ object for detached threads. OnExit() will be called just before exiting.  </p>

</div>
</div><!-- doxytag: member="wxThread::GetCPUCount" ref="a21ccbc2f91bed8d65aeada49a7f8335d" args="()" -->
<a class="anchor" id="a21ccbc2f91bed8d65aeada49a7f8335d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int wxThread::GetCPUCount  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of system CPUs or -1 if the value is unknown.  </p>
<p>For multi-core systems the returned value is typically the total number of <em>cores</em>, since the OS usually abstract a single N-core CPU as N different cores.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classwx_thread.html#a09dfe3800bbfad53be303a4608d52959" title="Sets the thread concurrency level for this process.">SetConcurrency()</a> </dd></dl>

</div>
</div><!-- doxytag: member="wxThread::GetCurrentId" ref="a414fecfb855a7e12088bb0fa54ebd330" args="()" -->
<a class="anchor" id="a414fecfb855a7e12088bb0fa54ebd330"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static wxThreadIdType wxThread::GetCurrentId  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the platform specific thread ID of the current thread as a long.  </p>
<p>This can be used to uniquely identify threads, even if they are not wxThreads.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classwx_thread.html#a0023e6e671b016f06c452f34dd6ce8f4" title="Returns the thread ID of the main thread.">GetMainId()</a> </dd></dl>

</div>
</div><!-- doxytag: member="wxThread::GetId" ref="a2c9db3ca1d37d8ed921e78c31acd9bb4" args="() const " -->
<a class="anchor" id="a2c9db3ca1d37d8ed921e78c31acd9bb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">wxThreadIdType wxThread::GetId  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the thread identifier: this is a platform dependent number that uniquely identifies the thread throughout the system during its existence (i.e.  </p>
<p>the thread identifiers may be reused).  </p>

</div>
</div><!-- doxytag: member="wxThread::GetKind" ref="a1fc5fa753cf2bc0ec63ff16825a144b2" args="() const " -->
<a class="anchor" id="a1fc5fa753cf2bc0ec63ff16825a144b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a0dc9a167e8d084946512da99b37b5fd0">wxThreadKind</a> wxThread::GetKind  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the thread kind as it was given in the ctor.  </p>
<dl class="since"><dt><b>Since:</b></dt><dd>2.9.0  </dd></dl>

</div>
</div><!-- doxytag: member="wxThread::GetMainId" ref="a0023e6e671b016f06c452f34dd6ce8f4" args="()" -->
<a class="anchor" id="a0023e6e671b016f06c452f34dd6ce8f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static wxThreadIdType wxThread::GetMainId  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the thread ID of the main thread.  </p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classwx_thread.html#a1ee917ef87f986ba3b2ee26e620378e4" title="Returns true if the calling thread is the main application thread.">IsMain()</a></dd></dl>
<dl class="since"><dt><b>Since:</b></dt><dd>2.9.1  </dd></dl>

</div>
</div><!-- doxytag: member="wxThread::GetPriority" ref="a785ac6add565d789481f8a9dfde5c229" args="() const " -->
<a class="anchor" id="a785ac6add565d789481f8a9dfde5c229"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int wxThread::GetPriority  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the priority of the thread, between zero and 100.  </p>
<p>The following priorities are defined:</p>
<ul>
<li><b>WXTHREAD_MIN_PRIORITY:</b> 0</li>
<li><b>WXTHREAD_DEFAULT_PRIORITY:</b> 50</li>
<li><b>WXTHREAD_MAX_PRIORITY:</b> 100  </li>
</ul>

</div>
</div><!-- doxytag: member="wxThread::IsAlive" ref="adc6cf71c426b1da03c6ca4b7f7da8aab" args="() const " -->
<a class="anchor" id="adc6cf71c426b1da03c6ca4b7f7da8aab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsAlive  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is alive (i.e.  </p>
<p>started and not terminating).</p>
<p>Note that this function can only safely be used with joinable threads, not detached ones as the latter delete themselves and so when the real thread is no longer alive, it is not possible to call this function because the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object no longer exists.  </p>

</div>
</div><!-- doxytag: member="wxThread::IsDetached" ref="a315c2abb553ba7e17ab2d5b2a0728e73" args="() const " -->
<a class="anchor" id="a315c2abb553ba7e17ab2d5b2a0728e73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsDetached  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is of the detached kind, <span class="literal">false</span> if it is a joinable one.  </p>

</div>
</div><!-- doxytag: member="wxThread::IsMain" ref="a1ee917ef87f986ba3b2ee26e620378e4" args="()" -->
<a class="anchor" id="a1ee917ef87f986ba3b2ee26e620378e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::IsMain  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <span class="literal">true</span> if the calling thread is the main application thread.  </p>
<p>Main thread in the context of wxWidgets is the one which initialized the library.</p>
<dl class="see"><dt><b>参照:</b></dt><dd><a class="el" href="classwx_thread.html#a0023e6e671b016f06c452f34dd6ce8f4" title="Returns the thread ID of the main thread.">GetMainId()</a>, <a class="el" href="classwx_thread.html#a414fecfb855a7e12088bb0fa54ebd330" title="Returns the platform specific thread ID of the current thread as a long.">GetCurrentId()</a> </dd></dl>

</div>
</div><!-- doxytag: member="wxThread::IsPaused" ref="a34328ecb720a1066971fb5e48cd84b6f" args="() const " -->
<a class="anchor" id="a34328ecb720a1066971fb5e48cd84b6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsPaused  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is paused.  </p>

</div>
</div><!-- doxytag: member="wxThread::IsRunning" ref="a0230733ffdc8f7603082dd2ca86b8cdd" args="() const " -->
<a class="anchor" id="a0230733ffdc8f7603082dd2ca86b8cdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wxThread::IsRunning  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td>  const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns <span class="literal">true</span> if the thread is running.  </p>
<p>This method may only be safely used for joinable threads, see the remark in <a class="el" href="classwx_thread.html#adc6cf71c426b1da03c6ca4b7f7da8aab" title="Returns true if the thread is alive (i.e.">IsAlive()</a>.  </p>

</div>
</div><!-- doxytag: member="wxThread::Kill" ref="a2cbff8b3b0a93ab82f212c02f38a1ef4" args="()" -->
<a class="anchor" id="a2cbff8b3b0a93ab82f212c02f38a1ef4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Kill  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Immediately terminates the target thread.  </p>
<p><b>"This function is dangerous and should be used with extreme care"</b> (and not used at all whenever possible)! The resources allocated to the thread will not be freed and the state of the C runtime library may become inconsistent. Use <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> for detached threads or <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a> for joinable threads instead.</p>
<p>For detached threads <a class="el" href="classwx_thread.html#a2cbff8b3b0a93ab82f212c02f38a1ef4" title="Immediately terminates the target thread.">Kill()</a> will also delete the associated C++ object. However this will not happen for joinable threads and this means that you will still have to delete the <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> object yourself to avoid memory leaks.</p>
<p>In neither case OnExit() of the dying thread will be called, so no thread-specific cleanup will be performed. This function can only be called from another thread context, i.e. a thread cannot kill itself.</p>
<p>It is also an error to call this function for a thread which is not running or paused (in the latter case, the thread will be resumed first) -- if you do it, a <b>wxTHREAD_NOT_RUNNING</b> error will be returned.  </p>

</div>
</div><!-- doxytag: member="wxThread::Pause" ref="a8c6d835578dde71dd2c241c38336a4ba" args="()" -->
<a class="anchor" id="a8c6d835578dde71dd2c241c38336a4ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Pause  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Suspends the thread.  </p>
<p>Under some implementations (Win32), the thread is suspended immediately, under others it will only be suspended when it calls <a class="el" href="classwx_thread.html#a9a3acec44b06b2a2430c5659991a3eac" title="This function should be called periodically by the thread to ensure that calls to Pause() and Delete(...">TestDestroy()</a> for the next time (hence, if the thread doesn't call it at all, it won't be suspended).</p>
<p>This function can only be called from another thread context.  </p>

</div>
</div><!-- doxytag: member="wxThread::Resume" ref="afe81d37cd6cb6d5eb142773fb2c94562" args="()" -->
<a class="anchor" id="afe81d37cd6cb6d5eb142773fb2c94562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Resume  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resumes a thread suspended by the call to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a>.  </p>
<p>This function can only be called from another thread context.  </p>

</div>
</div><!-- doxytag: member="wxThread::Run" ref="a5d894750ffaac8fc42ee85aeff8bb4c0" args="()" -->
<a class="anchor" id="a5d894750ffaac8fc42ee85aeff8bb4c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="interface_2wx_2thread_8h.html#a9e4ba0577f752fee0ba2133035f75ac2">wxThreadError</a> wxThread::Run  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Starts the thread execution.  </p>
<p>Should be called after <a class="el" href="classwx_thread.html#a88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a>.</p>
<p>Note that once you <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> a <b>detached</b> thread, <em>any</em> function call you do on the thread pointer (you must allocate it on the heap) is <em>"unsafe"</em>; i.e. the thread may have terminated at any moment after <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> and your pointer may be dangling. See <a class="el" href="classwx_thread.html#thread_types">Types of wxThreads</a> for an example of safe manipulation of detached threads.</p>
<p>This function can only be called from another thread context.</p>
<p>Finally, note that once a thread has completed and its <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> function returns, you cannot call <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a> on it again (an assert will fail in debug builds or <code>wxTHREAD_RUNNING</code> will be returned in release builds).  </p>

</div>
</div><!-- doxytag: member="wxThread::SetConcurrency" ref="a09dfe3800bbfad53be303a4608d52959" args="(size_t level)" -->
<a class="anchor" id="a09dfe3800bbfad53be303a4608d52959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool wxThread::SetConcurrency  </td>
          <td>(</td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the thread concurrency level for this process.  </p>
<p>This is, roughly, the number of threads that the system tries to schedule to run in parallel. The value of 0 for <em>level</em> may be used to set the default one.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd><span class="literal">true</span> on success or <span class="literal">false</span> otherwise (for example, if this function is not implemented for this platform -- currently everything except Solaris).  </dd></dl>

</div>
</div><!-- doxytag: member="wxThread::SetPriority" ref="a6236828fe98e81103219a519fbd7091d" args="(unsigned int priority)" -->
<a class="anchor" id="a6236828fe98e81103219a519fbd7091d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wxThread::SetPriority  </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"><em>priority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the priority of the thread, between 0 and 100.  </p>
<p>It can only be set after calling <a class="el" href="classwx_thread.html#a88051a33aa3fa9ca9392ac7d47b43cf4" title="Creates a new thread.">Create()</a> but before calling <a class="el" href="classwx_thread.html#a5d894750ffaac8fc42ee85aeff8bb4c0" title="Starts the thread execution.">Run()</a>.</p>
<p>The following priorities are defined:</p>
<ul>
<li><b>WXTHREAD_MIN_PRIORITY:</b> 0</li>
<li><b>WXTHREAD_DEFAULT_PRIORITY:</b> 50</li>
<li><b>WXTHREAD_MAX_PRIORITY:</b> 100  </li>
</ul>

</div>
</div><!-- doxytag: member="wxThread::Sleep" ref="a9ae47b39270c54dba5534af31f885ec6" args="(unsigned long milliseconds)" -->
<a class="anchor" id="a9ae47b39270c54dba5534af31f885ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void wxThread::Sleep  </td>
          <td>(</td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"><em>milliseconds</em></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Pauses the thread execution for the given amount of time.  </p>
<p>This is the same as <a class="el" href="group__group__funcmacro__time.html#ga66778879349f76fd833902d3767006fa" title="Sleeps for the specified number of milliseconds.">wxMilliSleep()</a>.  </p>

</div>
</div><!-- doxytag: member="wxThread::TestDestroy" ref="a9a3acec44b06b2a2430c5659991a3eac" args="()" -->
<a class="anchor" id="a9a3acec44b06b2a2430c5659991a3eac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool wxThread::TestDestroy  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This function should be called periodically by the thread to ensure that calls to <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> and <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a> will work.  </p>
<p>If it returns <span class="literal">true</span>, the thread should exit as soon as possible. Notice that under some platforms (POSIX), implementation of <a class="el" href="classwx_thread.html#a8c6d835578dde71dd2c241c38336a4ba" title="Suspends the thread.">Pause()</a> also relies on this function being called, so not calling it would prevent both stopping and suspending thread from working.  </p>

</div>
</div><!-- doxytag: member="wxThread::This" ref="a7077fa46ffef0fd1d023628776598335" args="()" -->
<a class="anchor" id="a7077fa46ffef0fd1d023628776598335"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classwx_thread.html">wxThread</a>* wxThread::This  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the thread object for the calling thread.  </p>
<p><span class="literal">NULL</span> is returned if the calling thread is the main (GUI) thread, but <a class="el" href="classwx_thread.html#a1ee917ef87f986ba3b2ee26e620378e4" title="Returns true if the calling thread is the main application thread.">IsMain()</a> should be used to test whether the thread is really the main one because <span class="literal">NULL</span> may also be returned for the thread not created with <a class="el" href="classwx_thread.html" title="A thread is basically a path of execution through a program.">wxThread</a> class. Generally speaking, the return value for such a thread is undefined.  </p>

</div>
</div><!-- doxytag: member="wxThread::Wait" ref="a62ee778033013d3a4754b71b8cf2902e" args="(wxThreadWait flags=wxTHREAD_WAIT_BLOCK)" -->
<a class="anchor" id="a62ee778033013d3a4754b71b8cf2902e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwx_thread.html#ade9497fa072fe19481086e6486dcc028">ExitCode</a> wxThread::Wait  </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="interface_2wx_2thread_8h.html#a180bd0d42ba227657c3ad00194371a87">wxThreadWait</a>&nbsp;</td>
          <td class="paramname"><em>flags</em> = <code>wxTHREAD_WAIT_BLOCK</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Waits for a <b>joinable</b> thread to terminate and returns the value the thread returned from <a class="el" href="classwx_thread.html#af50fa7d3ac55002e367e79989b9cbc5d" title="This is the entry point of the thread.">Entry()</a> or <code>"(ExitCode)-1"</code> on error.  </p>
<p>Notice that, unlike <a class="el" href="classwx_thread.html#a66796042bf5f3eb33a0ad3db85f686d4" title="Calling Delete() gracefully terminates a detached thread, either when the thread calls TestDestroy() ...">Delete()</a>, this function doesn't cancel the thread in any way so the caller waits for as long as it takes to the thread to exit.</p>
<p>You can only <a class="el" href="classwx_thread.html#a62ee778033013d3a4754b71b8cf2902e" title='Waits for a joinable thread to terminate and returns the value the thread returned from Entry() or "(...'>Wait()</a> for <b>joinable</b> (not detached) threads.</p>
<p>This function can only be called from another thread context.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">waitMode</td><td>As described in wxThreadWait documentation, wxTHREAD_WAIT_BLOCK should be used as the wait mode even although currently wxTHREAD_WAIT_YIELD is for compatibility reasons. This parameter is new in wxWidgets 2.9.2.</td></tr>
  </table>
  </dd>
</dl>
<p>See <a class="el" href="classwx_thread.html#thread_deletion">wxThread Deletion</a> for a broader explanation of this routine.  </p>

</div>
</div><!-- doxytag: member="wxThread::Yield" ref="a7a36099bab2d4be9d72cfd4cf76e8aa6" args="()" -->
<a class="anchor" id="a7a36099bab2d4be9d72cfd4cf76e8aa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void wxThread::Yield  </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code>  [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Give the rest of the thread's time-slice to the system allowing the other threads to run.  </p>
<p>Note that using this function is <b>strongly</b> discouraged, since in many cases it indicates a design weakness of your threading model (as does using <a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a> functions).</p>
<p>Threads should use the CPU in an efficient manner, i.e. they should do their current work efficiently, then as soon as the work is done block on a wakeup event (<a class="el" href="classwx_condition.html" title="wxCondition variables correspond to pthread conditions or to Win32 event objects.">wxCondition</a>, <a class="el" href="classwx_mutex.html" title="A mutex object is a synchronization object whose state is set to signaled when it is not owned by any...">wxMutex</a>, select(), poll(), ...) which will get signalled e.g. by other threads or a user device once further thread work is available. Using <a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread's time-slice to the system allowing the other threads to run...">Yield()</a> or <a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a> indicates polling-type behaviour, since we're fuzzily giving up our timeslice and wait until sometime later we'll get reactivated, at which time we realize that there isn't really much to do and <a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread's time-slice to the system allowing the other threads to run...">Yield()</a> again...</p>
<p>The most critical characteristic of <a class="el" href="classwx_thread.html#a7a36099bab2d4be9d72cfd4cf76e8aa6" title="Give the rest of the thread's time-slice to the system allowing the other threads to run...">Yield()</a> is that it's operating system specific: there may be scheduler changes which cause your thread to not wake up relatively soon again, but instead many seconds later, causing huge performance issues for your application.</p>
<p><b> With a well-behaving, CPU-efficient thread the operating system is likely to properly care for its reactivation the moment it needs it, whereas with non-deterministic, Yield-using threads all bets are off and the system scheduler is free to penalize them drastically</b>, and this effect gets worse with increasing system load due to less free CPU resources available. You may refer to various Linux kernel <code>sched_yield</code> discussions for more information.</p>
<p>See also <a class="el" href="classwx_thread.html#a9ae47b39270c54dba5534af31f885ec6" title="Pauses the thread execution for the given amount of time.">Sleep()</a>.  </p>

</div>
</div>
</div><!-- window showing the filter options -->

<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div><!-- iframe showing the search results (closed by default) -->


<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/>
<address class="footer">
	<small>
		
		Page generated on Mon Jul 9 2012 15:04:32 by  <!--[Doxygen 1.7.6+] $generatedby -->
		<a href="http://www.doxygen.org/index.html" target="_new">Doxygen</a> 1.7.4
	
	</small>
</address>


<script src="wxwidgets.js" type="text/javascript"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body>
</html>
