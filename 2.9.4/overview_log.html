<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>wxWidgets: wxWidgets: wxLog クラスの概要</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery-1.3.2.min.js"></script>

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr>
  
  <td id="projectlogo"><a href="http://www.wxwidgets.org/" target="_new"><img alt="Logo" src="logo.png"/></a></td>
  
  <td style="padding: 0.5em; text-align: right;">
   <span id="projectnumber">Version: 2.9.4</span>
  </td>
  
 </tr>
 </tbody>
</table>
</div><!-- Generated by Doxygen 1.7.4 -->


<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li class="current"><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>カテゴリ</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li><a href="dirs.html"><span>ディレクトリ</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">ドキュメント</a>      </li>
      <li class="navelem"><a class="el" href="page_topics.html">トピックスの概要</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> クラスの概要 </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>クラス: <a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a>, <a class="el" href="classwx_log_stderr.html" title="このクラスはログメッセージを C のファイルストリーム (C++ のストリームと混同しないでください) へリダイレクトするのに使用できます。">wxLogStderr</a>, <a class="el" href="classwx_log_stream.html" title="このクラスはログメッセージを C++ のストリームへリダイレクトするのに使用できます。">wxLogStream</a>, <a class="el" href="classwx_log_text_ctrl.html" title="これらのターゲットを使用してログメッセージをテキストコントロールへリダイレクトできます。">wxLogTextCtrl</a>, <a class="el" href="classwx_log_window.html" title="このクラスはバックグラウンドで動作するログウィンドウを表します。正確に言うと、このログウィンドウではログフレーム内のすべてのメッセージを収集するとともに、このクラスオブジェクトの生成時に有効だったログターゲットへ収集したメッセージを引き渡します。">wxLogWindow</a>, <a class="el" href="classwx_log_gui.html" title="これは GUI wxWidgets アプリケーションのデフォルトのログターゲットです。">wxLogGui</a>, <a class="el" href="classwx_log_null.html" title="このクラスを用いて一時的にロギングを中断することができます。">wxLogNull</a>, <a class="el" href="classwx_log_buffer.html" title="wxLogBuffer はログ出力先の非常に単純な実装で、すべてのログメッセージを単純に文字列へ集めます。 (ただし、デバッグメッセージは除きます。なぜなら、普通、デバッグメッセージはただちに出力されるので、後で集めることにおそらく関心がないためです)">wxLogBuffer</a>, <a class="el" href="classwx_log_chain.html" title="この単純なクラスを用いることでログ出力先を連鎖させることが可能になります。つまり、wxLog::SetActiveTarget のようにログ出力先を置き換える代わりに、新しい出力先を設定しつつ、 古い出力先にもログメッセージを渡すことが可能になります。">wxLogChain</a>, <a class="el" href="classwx_log_interposer.html" title="wxLogChain の特別版で、自分自身を新しいログターゲットとして使用します。">wxLogInterposer</a>, <a class="el" href="classwx_log_interposer_temp.html" title="wxLogChain の特別版で、自分自身を新しいログターゲットとして使用します。">wxLogInterposerTemp</a>, <a class="el" href="classwx_stream_to_text_redirector.html" title="このクラスは (一時的に) C++ ostream オブジェクトへ送信されたすべての出力を代わりに wxTextCtrl へリダイレクトするのに使用できます。 ">wxStreamToTextRedirector</a>, <a class="el" href="classwx_log_formatter.html" title="wxLogFormatter クラスはログメッセージをフォーマットするのに使用されます。">wxLogFormatter</a></p>
<p>目次: </p>
<ul>
<li><a class="el" href="overview_log.html#overview_log_introduction">イントロダクション</a> </li>
<li><a class="el" href="overview_log.html#overview_log_enable">ログメッセージの選択</a> </li>
<li><a class="el" href="overview_log.html#overview_log_targets">ログターゲット</a> </li>
<li><a class="el" href="overview_log.html#overview_log_mt">マルチスレッドアプリケーションでのロギング</a> </li>
<li><a class="el" href="overview_log.html#overview_log_customize">ロギングのカスタマイズ</a> </li>
<li><a class="el" href="overview_log.html#overview_log_tracemasks">トレースマスクの使用</a> <hr/>
</li>
</ul>
<h2><a class="anchor" id="overview_log_introduction"></a>
イントロダクション</h2>
<p>これは wxWidgets の提供するロギングクラス全般の概要です。ここでのロギングという言葉は広い意味を持っており、非対話形式のメッセージに限らず、プログラムの出力すべてを含んでいます。wxWidgets のロギング機能では <em>ログ</em> ターゲットに対する標準的なインタフェースを定義する基底 <a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> クラスや、いくつかのログクラスの標準的な実装とそれを使用する関数群を提供しています。</p>
<p>まず最初に、<a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> クラス郡を使用するのにその知識は必要とされません。そのため、<a class="el" href="group__group__funcmacro__log.html">wxLogXXX() 関数</a> についてのみ、知っておく必要があります。これらの関数はすべて <em>printf()</em> や <em>vprintf()</em> と同じ構文を持ちます。つまり、第一引数にフォーマット文字列を取り、続けて可変引数か可変引数リストのポインタを取ります。以下にすべての関数を示します:</p>
<ul>
<li><a class="el" href="group__group__funcmacro__log.html#ga4ae39c06cbeaa5461cd1b5c293a31403" title="wxLogError() と似ていますが、リターンコード 3 でプログラムを終了させます。">wxLogFatalError</a> は <a class="el" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="エラーメッセージ用の関数です。">wxLogError</a> と似ていますが、(<em>abort()</em> 標準関数を使用して) リターンコード 3 でプログラムを終了させます。他のすべてのロギング関数と異なり、この関数はログターゲットによってオーバーライドすることができません。 </li>
<li><a class="el" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="エラーメッセージ用の関数です。">wxLogError</a> はエラーメッセージ (ユーザに通知しなければならないメッセージ) 用の関数です。デフォルトの処理ではメッセージボックスをポップアップして通知します。 </li>
<li><a class="el" href="group__group__funcmacro__log.html#ga0c2b19580ef6721508e6d69534b10e90" title="警告メッセージ (通常はユーザに通知されますが、プログラムの動作を妨げないメッセージ) 用。">wxLogWarning()</a> は警告メッセージ用です。警告メッセージは普通、ユーザに通知されますが、プログラムの動作を妨げません。 </li>
<li><a class="el" href="group__group__funcmacro__log.html#ga249358701f3c2d410088ddf7a61d8564" title="すべての通常 (通知) メッセージ用。">wxLogMessage</a> はすべての通常 (通知) メッセージ用の関数です。この関数もデフォルトでメッセージボックスを表示します。 (ただし、この振る舞いは変更可能です。以下を参照してください) </li>
<li><a class="el" href="group__group__funcmacro__log.html#gaf57b7e28ab76bacf10b3be044e8bd634" title="詳細な出力用。">wxLogVerbose</a> は詳細な出力用の関数です。通常は出力されませんが、ユーザがプログラムの進捗状況についてより詳しく知りたい場合に有効化されるかもしれません。 (名前の紛らわしい同じ機能の関数として wxLogInfo があります) </li>
<li><a class="el" href="group__group__funcmacro__log.html#gac241ed1e5d13c7a552f58307c7f16691" title="この関数でロギングされたメッセージはデフォルトでフレームまたはトップレベルウィンドウのステータスバーに表示されます。">wxLogStatus()</a> はステータスメッセージ用です。これらのメッセージはアクティブまたは第一引数で指定された <a class="el" href="classwx_frame.html" title="フレームは (通常は) ユーザがサイズや位置を変更可能なウィンドウです。">wxFrame</a> がステータスバーを持つ場合に、ステータスバーへ出力されます。 </li>
<li><a class="el" href="group__group__funcmacro__log.html#ga28f01715af5aaf37caffdc5bc00fde3f" title="主に wxWidgets 自身で使用されますが、システムコール (API 関数) の失敗後のエラーログを記録するのに便利かもしれません。">wxLogSysError</a> は主に wxWidgets 自身で使用されますが、システムコール (API 関数) の失敗後のエラーログを記録するのに便利かもしれません。この関数は指定したメッセージとあわせて、最後のシステムエラーコード  (プラットフォームに応じて <em>errno</em> または Windows の <em>::GetLastError()</em> ) とそれに対応するエラーメッセージを出力します。この関数の 2 番目の形式では第一引数として明示的にエラーコードを指定できます。 </li>
<li><a class="el" href="group__group__funcmacro__log.html#ga9c530ae20eb423744f90874d2c97d02b" title="デバッグ出力に適切な関数です。">wxLogDebug</a> は <b>まさに</b> デバッグ出力に適切な関数です。デバッグモードの場合 (プリプロセッサシンボル <code>__WXDEBUG__</code> が定義されている場合) のみ処理を行い、リリースモードの場合 (それ以外の場合) では空文字列に展開されます。Windows でデバッグ出力を確認するためにはデバッガーを使用するか、DbgView (<a href="http://www.microsoft.com/technet/sysinternals/Miscellaneous/DebugView.mspx">http://www.microsoft.com/technet/sysinternals/Miscellaneous/DebugView.mspx</a>) のようなサードパーティーのプログラムを使用する必要がある点に注意してください。 </li>
<li><a class="el" href="group__group__funcmacro__log.html#ga947e317db477914c12b13c4534867ec9" title="wxLOG_Trace ログレベル (wxLogLevelValues enum 参照) のメッセージを記録します。">wxLogTrace</a> も <a class="el" href="group__group__funcmacro__log.html#ga9c530ae20eb423744f90874d2c97d02b" title="デバッグ出力に適切な関数です。">wxLogDebug</a> と同じようにデバッグビルド時のみ動作します。これを別の関数とした理由は、通常、トレースメッセージを大量に出力するため、同じように大量に出力する他のデバッグ出力と区別することに意味があるはずだからです。くわえて、2 番目の形式では第一引数としてトレースマスクを指定できるため、生成されるメッセージの量をさらに制限することができます。</li>
</ul>
<p>これらの関数の用途はかなり明確ですが、なぜ C の標準入出力関数や C++ のストリームといった他のロギング機能を使用しないのか疑問に思うかもしれません。簡単に答えれば、それらの関数やストリームは確かに優れた汎用的な仕組みを持っていますが、本当に wxWidgets に適しているとは言えないためです。wxWidgets のログ関数を使用するいくつかの利点は以下の通りです:</p>
<ul>
<li><b>移植性 :</b> デバッグ情報や他の情報の出力に <em>printf()</em> や cout/cerr などの C++ ストリームを使用するのはごく普通のことです。ただし、これは Unix では正常に動作しますが、GUI プログラムの標準出力がどこにも割り当てられない Windows では厳密にどこにも出力されません. したがって、<a class="el" href="group__group__funcmacro__log.html#ga249358701f3c2d410088ddf7a61d8564" title="すべての通常 (通知) メッセージ用。">wxLogMessage()</a> を <em> printf()</em> の単純な代替として考えてください。以下のように書くことで <em>wxLogXXX</em> 呼び出しを <em>cout</em> へリダイレクトすることもできます: <div class="fragment"><pre class="fragment">    <a class="code" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a>* logger = <span class="keyword">new</span> <a class="code" href="classwx_log_stream.html" title="このクラスはログメッセージを C++ のストリームへリダイレクトするのに使用できます。">wxLogStream</a>(&amp;cout);
    <a class="code" href="classwx_log.html#ac7ea85f71c8d3ecd4247f412be410505" title="指定されたログターゲットを有効なログターゲットとして設定します。">wxLog::SetActiveTarget</a>(logger);
</pre></div> 最後に、<a class="el" href="classwx_stream_to_text_redirector.html" title="このクラスは (一時的に) C++ ostream オブジェクトへ送信されたすべての出力を代わりに wxTextCtrl へリダイレクトするのに使用できます。 ">wxStreamToTextRedirector</a> クラスを使用することで <em>cout</em> へ出力した内容を <a class="el" href="classwx_text_ctrl.html" title="テキストの表示と編集が可能なテキストコントロール。">wxTextCtrl</a> にリダイレクトすることもできます。 </li>
<li><b>柔軟性 :</b> <a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> 関数の出力はその重要度に応じてリダイレクトしたり抑制したりできます。これは従来の関数では不可能、もしくは困難なことです。例えば、すべての通知メッセージをフィルタリングして、エラーメッセージのみ、もしくはエラーメッセージと警告メッセージのみを記録しても構いません。 </li>
<li><b>完全性 :</b> 通常、処理が失敗した場合にはエラーメッセージが表示されるべきです。非常に単純で、よくあるファイルエラーの場合を考えてみましょう: データをディスク上のファイルに書き込もうとして充分な空き容量がなかったときを想像してください。実際のエラーは wxWidgets コード (<a class="el" href="classwx_file.html#a0974a92a5c8793629fd9ee0f1735657c" title="ファイル (ディスクリプタ) へデータを書き込みます。">wxFile::Write</a>) 内で検知されるため、呼び出し元の関数では失敗の正確な原因を実際に知ることはできず、ディスクへの書き込みに失敗したことしか分かりません。しかし、このような状況で <a class="el" href="group__group__funcmacro__log.html#ga0dd3c633f990f794e76065c9a7af4c87" title="エラーメッセージ用の関数です。">wxLogError()</a> を使用すれば、書き込みに失敗したファイルに関する "高レベル" なメッセージとともに正確なエラーコード (と対応するエラーメッセージ) が表示されます。</li>
</ul>
<h2><a class="anchor" id="overview_log_enable"></a>
ログメッセージの選択</h2>
<p>デフォルトでは大半のログメッセージが有効化されています。特に、wxWidgets 自身の記録するエラー (何らかの処理の失敗時、例えば、<a class="el" href="classwx_file.html#a70f2abe0e310dcf77ea6aeaac60df25b" title="ファイルをオープンします。オープンに成功したら true を返却します。">wxFile::Open()</a> はファイルのオープンに失敗した場合にエラーを記録します) がユーザに通知されることを意味します。完全にロギングを無効化するためには <a class="el" href="classwx_log.html#a58bbfc0831eb47f0d88c9350d1f6e02d" title="ロギングをグローバルに有効化、または無効化します。">wxLog::EnableLogging()</a> か、普通は一時的にロギングを無効化し、オブジェクトが破棄される時に元の設定を復元する <a class="el" href="classwx_log_null.html" title="このクラスを用いて一時的にロギングを中断することができます。">wxLogNull</a> クラスを使用します。</p>
<p>重要なメッセージのみを記録するためには <a class="el" href="classwx_log.html#a4ea68379469ca27f645d5f91c2d42b3b" title="(数値的に) logLevel より大きいログレベルを持つメッセージを無視し、有効なログターゲットに送信されないようにします。">wxLog::SetLogLevel()</a> に wxLOG_Warning などを指定します。こうすることで、重要度が警告未満であるすべてのメッセージのロギングが無効になり、<a class="el" href="group__group__funcmacro__log.html#ga249358701f3c2d410088ddf7a61d8564" title="すべての通常 (通知) メッセージ用。">wxLogMessage()</a> の出力はもはやユーザに通知されなくなります。</p>
<p>さらに、異なるログコンポーネント間で別々にログレベルを設定することも可能です。これがどれほど役立つか説明する前に、ログコンポーネントについて説明しましょう: ログコンポーネントとは単純に、メッセージを生成するコンポーネントやモジュールを識別する任意の文字列のことです。ログコンポーネントは "foo/bar/baz" コンポーネントが "foo" コンポーネントの子として扱われるという意味では階層的です。そして、すべてのコンポーネントは無名のルートコンポーネントの子になります。</p>
<p>デフォルトでは wxWidgets によって記録されるすべてのメッセージは "wx" コンポーネントかそのサブコンポーネント ("wx/net/ftp" など) に割り当てられており、あなた自身のコードによって記録されるメッセージは空のログコンポーネントに割り当てられています。これを変更するためには、 <code>wxLOG_COMPONENT</code> として各コンポーネントを一意に識別する文字列を定義する必要があります。この文字列は例えばデフォルトで "MyProgram" を指定し、データベースを利用するモジュールでは "MyProgram/DB" に、さらにトランザクションを扱う部分では "MyProgram/DB/Trans" に再定義する、というようにします。そして、以下のように <a class="el" href="classwx_log.html#a7ae244e71dff20efd3a37b3718841a39" title="指定されたコンポーネントのログレベルを設定します。">wxLog::SetComponentLevel()</a> を使用します: </p>
<div class="fragment"><pre class="fragment">        <span class="comment">// 絶対にデータベースが失敗しないことを誰もが知っているため、</span>
        <span class="comment">// データベースのすべてのエラーメッセージを無効化する</span>
        <a class="code" href="classwx_log.html#a7ae244e71dff20efd3a37b3718841a39" title="指定されたコンポーネントのログレベルを設定します。">wxLog::SetComponentLevel</a>(<span class="stringliteral">"MyProgram/DB"</span>, <a class="code" href="interface_2wx_2log_8h.html#aacf1e0ade132ca66e9414ee658c94887a84fba9c5b2a134eef33710303503bc5b" title="プログラムを継続できないため、ただちに中断します">wxLOG_FatalError</a>);

        <span class="comment">// しかし、どういうわけか時たま変更のコミットに失敗するため、</span>
        <span class="comment">// トランザクションのトレースは有効化する</span>
        <a class="code" href="classwx_log.html#a7ae244e71dff20efd3a37b3718841a39" title="指定されたコンポーネントのログレベルを設定します。">wxLog::SetComponentLevel</a>(<span class="stringliteral">"MyProgram/DB/Trans"</span>, <a class="code" href="interface_2wx_2log_8h.html#aacf1e0ade132ca66e9414ee658c94887a897a7912d3d8eb59e913b1b45af94455" title="トレースメッセージもデバッグモード時のみ有効化されます">wxLOG_Trace</a>);

        <span class="comment">// また、wxWidgets の動的モジュールロード機能の</span>
        <span class="comment">// トレースメッセージも有効化する</span>
        <a class="code" href="classwx_log.html#a7ae244e71dff20efd3a37b3718841a39" title="指定されたコンポーネントのログレベルを設定します。">wxLog::SetComponentLevel</a>(<span class="stringliteral">"wx/base/module"</span>, <a class="code" href="interface_2wx_2log_8h.html#aacf1e0ade132ca66e9414ee658c94887a897a7912d3d8eb59e913b1b45af94455" title="トレースメッセージもデバッグモード時のみ有効化されます">wxLOG_Trace</a>);
</pre></div><p> トランザクションコードで明示的に設定されたログレベルは親コンポーネントのログレベルを上書きしますが、データベースコードの他のサブコンポーネントはすべて親コンポーネントの値を継承するため、ログメッセージはまったく生成されません。</p>
<h2><a class="anchor" id="overview_log_targets"></a>
ログターゲット</h2>
<p>メッセージのロギングに通常使用するすべての関数と、それらを使用する理由について列挙したので、これらの動作方法について説明します。</p>
<p>wxWidgets では <em>ログターゲット</em> という考え方があります: これは単純に <a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> を継承したクラスです。そのため、メッセージのロギング時に呼ばれる基底クラスの仮想関数を実装ています。いつでも <em>有効な</em> ログターゲットはひとつだけで、これが <a class="el" href="group__group__funcmacro__log.html">wxLogXXX()</a> 関数によって使用されます。ログオブジェクト (つまり、<a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> を継承したクラスのオブジェクト) の通常の使用方法は <em>SetActiveTarget()</em> を使用して有効なターゲットとして設定することで、それ以降に呼び出された <a class="el" href="group__group__funcmacro__log.html">wxLogXXX() 関数</a>で自動的に使用されるようになります。</p>
<p>新しいログターゲットクラスを作成する場合、<a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> を継承し、<a class="el" href="classwx_log.html#aede0ff7812690d487de845b7f3095dfd" title="新しいレコードを記録するために呼ばれます。">wxLog::DoLogRecord()</a>、<a class="el" href="classwx_log.html#a3fafbd3b87ff2d08dfdd1378d35013bb" title="指定されたレベルで与えられた文字列を記録するために呼ばれます。">wxLog::DoLogTextAtLevel()</a>、<a class="el" href="classwx_log.html#a18c877e0038afe284757512b866b0aac" title="指定された文字列を記録するために呼ばれます。">wxLog::DoLogText()</a> のいずれか (または複数) をオーバーライドするだけです。最初の関数はもっとも柔軟で、メッセージ形式の変更、メッセージの動的なフィルタリングやリダイレクトなどを行なうことができます。<a class="el" href="group__group__funcmacro__log.html#ga4ae39c06cbeaa5461cd1b5c293a31403" title="wxLogError() と似ていますが、リターンコード 3 でプログラムを終了させます。">wxLogFatalError()</a> で生成されたメッセージを除いて、すべてのメッセージがこの関数に引き渡されます。メッセージの形式を変更することなく、ログメッセージを単純に他の場所へリダイレクトしたいだけの場合、<a class="el" href="classwx_log.html#a3fafbd3b87ff2d08dfdd1378d35013bb" title="指定されたレベルで与えられた文字列を記録するために呼ばれます。">wxLog::DoLogTextAtLevel()</a> をオーバーライドします。最後に、メッセージのログレベルに関係なく、ログメッセージをリダイレクトしたいだけの場合、<a class="el" href="classwx_log.html#a18c877e0038afe284757512b866b0aac" title="指定された文字列を記録するために呼ばれます。">wxLog::DoLogText()</a> をオーバーライドすれば充分です。</p>
<p><a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> を継承したクラスがいくつか事前に定義されており、新しいログターゲットクラスを作成する際の参考になると思います。もちろん、そのまま使用することも可能です。以下にその一覧を示します:</p>
<ul>
<li><a class="el" href="classwx_log_stderr.html" title="このクラスはログメッセージを C のファイルストリーム (C++ のストリームと混同しないでください) へリダイレクトするのに使用できます。">wxLogStderr</a>: このクラスはメッセージを <code>FILE *</code> へ出力します。その名の通り、デフォルトでは stderr へ出力します。 </li>
<li><a class="el" href="classwx_log_stream.html" title="このクラスはログメッセージを C++ のストリームへリダイレクトするのに使用できます。">wxLogStream</a>: このクラスは <a class="el" href="classwx_log_stderr.html" title="このクラスはログメッセージを C のファイルストリーム (C++ のストリームと混同しないでください) へリダイレクトするのに使用できます。">wxLogStderr</a> と同じ機能を持ちますが、<code>FILE *</code> と stderr の代わりに <em>ostream</em> と cerr を使用します。 </li>
<li><a class="el" href="classwx_log_gui.html" title="これは GUI wxWidgets アプリケーションのデフォルトのログターゲットです。">wxLogGui</a>: これは wxWidgets アプリケーションの標準ログターゲット (何もしない場合にデフォルトで使用されます) で、指定されたプラットフォームについて、メッセージのすべての型に対してもっとも合理的な処理を行います。 </li>
<li><a class="el" href="classwx_log_window.html" title="このクラスはバックグラウンドで動作するログウィンドウを表します。正確に言うと、このログウィンドウではログフレーム内のすべてのメッセージを収集するとともに、このクラスオブジェクトの生成時に有効だったログターゲットへ収集したメッセージを引き渡します。">wxLogWindow</a>: このログターゲットはアプリケーションの生成するすべてのメッセージを収集する "ログコンソール" を提供するとともに、前に有効だったログターゲットに収集したメッセージを引き渡します。ログウィンドウフレームはメニューを持ち、ログの消去、終了、メッセージの保存を選択することができます。 </li>
<li><a class="el" href="classwx_log_buffer.html" title="wxLogBuffer はログ出力先の非常に単純な実装で、すべてのログメッセージを単純に文字列へ集めます。 (ただし、デバッグメッセージは除きます。なぜなら、普通、デバッグメッセージはただちに出力されるので、後で集めることにおそらく関心がないためです)">wxLogBuffer</a>: このターゲットはすべてのログメッセージを内部バッファに収集し、後で一括してユーザに通知できるようにします。 </li>
<li><a class="el" href="classwx_log_null.html" title="このクラスを用いて一時的にロギングを中断することができます。">wxLogNull</a>: 最後のログクラスは極めて特殊です: これは何も行いません。このクラスのオブジェクトは <em>wxLogXXX()</em> 関数の出力を (一時的に) 抑制する場合にインスタンス化されます。例として、存在しないファイルを開こうとすると通常はエラーメッセージが表示されますが、何らかの理由でそれを望まない場合、次のようにするだけです: <div class="fragment"><pre class="fragment">    <a class="code" href="classwx_file.html" title="wxFile は低レベルファイル入出力を行います。">wxFile</a> file;

    <span class="comment">// 通常はファイルを開けなかった場合に wxFile.Open() がエラーメッセージを出力するが、そうさせたくない</span>
    {
        <a class="code" href="classwx_log_null.html" title="このクラスを用いて一時的にロギングを中断することができます。">wxLogNull</a> logNo;
        <span class="keywordflow">if</span> ( !file.<a class="code" href="classwx_file.html#a70f2abe0e310dcf77ea6aeaac60df25b" title="ファイルをオープンします。オープンに成功したら true を返却します。">Open</a>(<span class="stringliteral">"bar"</span>) )
        {
            <span class="comment">// ... 自分自身でエラー処理を行なう ...</span>
        }
    } <span class="comment">// ~wxLogNull が呼ばれ、古いログ出力先が元に戻される</span>

    <a class="code" href="group__group__funcmacro__log.html#ga249358701f3c2d410088ddf7a61d8564" title="すべての通常 (通知) メッセージ用。">wxLogMessage</a>(<span class="stringliteral">"..."</span>); <span class="comment">// ok</span>
</pre></div></li>
</ul>
<p>ログターゲットは組み合わせて使用することもできます: 例えば、メッセージを他の場所 (例えばログファイルなど) にリダイレクトしつつ、通常通りの方法でも処理したいとします。このために <a class="el" href="classwx_log_chain.html" title="この単純なクラスを用いることでログ出力先を連鎖させることが可能になります。つまり、wxLog::SetActiveTarget のようにログ出力先を置き換える代わりに、新しい出力先を設定しつつ、 古い出力先にもログメッセージを渡すことが可能になります。">wxLogChain</a>、<a class="el" href="classwx_log_interposer.html" title="wxLogChain の特別版で、自分自身を新しいログターゲットとして使用します。">wxLogInterposer</a>、<a class="el" href="classwx_log_interposer_temp.html" title="wxLogChain の特別版で、自分自身を新しいログターゲットとして使用します。">wxLogInterposerTemp</a> を使用できます。</p>
<h2><a class="anchor" id="overview_log_mt"></a>
マルチスレッドアプリケーションでのロギング</h2>
<p>wxWidgets 2.9.1 から、どのスレッドからでも安全にロギング関数を呼べるようになりました。メインスレッド以外のスレッドで記録されたメッセージはメインスレッドで <a class="el" href="classwx_log.html#a21f8a2a7d83bd17a0e89bbe7dd7e6feb" title="いくつかの wxLog の実装、特に標準の wxLogGui クラスではメッセージを (例えば無数のメッセージダイアログが次々と表示されるのを防止するために) バッファリングします。">wxLog::Flush()</a> が呼ばれるまで (通常はアイドル時、つまり、未処理のイベントがすべて処理された後に呼ばれます) バッファリングされ、<a class="el" href="classwx_log.html#a21f8a2a7d83bd17a0e89bbe7dd7e6feb" title="いくつかの wxLog の実装、特に標準の wxLogGui クラスではメッセージを (例えば無数のメッセージダイアログが次々と表示されるのを防止するために) バッファリングします。">wxLog::Flush()</a> が呼ばれたときに初めて実際に出力されます。デフォルトの GUI ロガーはフラッシュされるときに初めてメッセージを出力するようにすでになっているため、他スレッドのメッセージは通常どおり、ほぼ同時に表示されます。しかし、カスタムログターゲットを定義している場合、メッセージの記録される順がバラバラになる可能性があります。例えば、より後のタイムスタンプを持つメインスレッドのメッセージがより早いタイムスタンプを持つ他のスレッドのメッセージの前に表示されることがあります。ただし、<a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> は各スレッドで記録されたメッセージは記録された順に表示されることを保証しています。</p>
<p>また、<a class="el" href="classwx_log.html#a58bbfc0831eb47f0d88c9350d1f6e02d" title="ロギングをグローバルに有効化、または無効化します。">wxLog::EnableLogging()</a> と <a class="el" href="classwx_log_null.html" title="このクラスを用いて一時的にロギングを中断することができます。">wxLogNull</a> クラスは現在のスレッドにのみ影響することに注意してください。つまり、<code>EnableLogging(false)</code> を呼んだ後でも他のスレッドでは依然としてログメッセージが生成されます。</p>
<h2><a class="anchor" id="overview_log_customize"></a>
ロギングのカスタマイズ</h2>
<p>ロギングの振る舞いを完全に変更するためにはカスタムログターゲットを定義します。例えば、モーダルメッセージボックスでユーザの操作を妨げないようにするため、メインウィンドウの一部にすべてのログメッセージを表示するように <a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> を継承したクラスを定義することができます。</p>
<p>作成したカスタムログターゲットを使用するためには、カスタムログターゲットのオブジェクトを指定して <a class="el" href="classwx_log.html#ac7ea85f71c8d3ecd4247f412be410505" title="指定されたログターゲットを有効なログターゲットとして設定します。">wxLog::SetActiveTarget()</a> を呼ぶか、wxAppTraits を継承したクラスを作成して <a class="el" href="classwx_app_traits.html#aae9e62a6b5364fb9a230888a637eb378" title="エラーを記録するためにアプリケーション用の wxLog クラスを作成します。">wxAppTraits::CreateLogTarget()</a> 仮想関数をオーバーライドし、自作の特性オブジェクトのインスタンスを返却するように <a class="el" href="classwx_app_console.html#ab2811644bfee7a93d0564a09397c4408" title="最初に GetTraits() が必要とした時に wxAppTraits オブジェクトを作成します。">wxApp::CreateTraits()</a> をオーバーライドします。後者の場合、例えばプログラムの起動時に早くメッセージのロギングの準備をする必要があり、プログラムの終了時にはメインウィンドウの存在に依存してはいけない点に注意してください。しかし、ログターゲットを使用するときに (すでに/まだ) GUI が存在すると安全に仮定することができます。なぜなら、 GUI が存在しない場合は <a class="el" href="classwx_log_stderr.html" title="このクラスはログメッセージを C のファイルストリーム (C++ のストリームと混同しないでください) へリダイレクトするのに使用できます。">wxLogStderr</a> を使用するように wxWidgets がログターゲットを自動的に切り替えるためです。</p>
<p>ログメッセージの処理方法をカスタマイズするためには継承クラスでいくつかの関数をオーバーライドします: <a class="el" href="classwx_log.html#aede0ff7812690d487de845b7f3095dfd" title="新しいレコードを記録するために呼ばれます。">wxLog::DoLogRecord()</a>、 <a class="el" href="classwx_log.html#a3fafbd3b87ff2d08dfdd1378d35013bb" title="指定されたレベルで与えられた文字列を記録するために呼ばれます。">wxLog::DoLogTextAtLevel()</a>、<a class="el" href="classwx_log.html#a18c877e0038afe284757512b866b0aac" title="指定された文字列を記録するために呼ばれます。">wxLog::DoLogText()</a>。</p>
<p>最後の関数が一番単純です: メッセージのログレベルを考慮せず、単純にログ出力を他の場所へリダイレクトしたい場合はこの関数をオーバーライドします。異なるレベルのメッセージを別々に処理したい場合、<a class="el" href="classwx_log.html#a3fafbd3b87ff2d08dfdd1378d35013bb" title="指定されたレベルで与えられた文字列を記録するために呼ばれます。">wxLog::DoLogTextAtLevel()</a> をオーバーライドしてください。</p>
<p>加えて、ログメッセージを (タイムスタンプ、ソースファイルの情報、スレッドID などの) 部品から構築する方法を完全にカスタマイズすることもできます。これは <a class="el" href="classwx_log_formatter.html" title="wxLogFormatter クラスはログメッセージをフォーマットするのに使用されます。">wxLogFormatter</a> クラスによって行われるため、このクラスを継承し、望む方法でログメッセージを構築するように Fortmat() 関数をオーバーライドする必要があります。ただし、タイムスタンプの形式を変更 (または出力を抑制) したいだけの場合、FormatTime() をオーバーライドするだけで充分です。</p>
<p>最後に、出力形式をさらに制御する必要がある場合、DoLogRecord() をオーバーライドすることでログレベルに応じてカスタムメッセージを構築したり、メッセージの重要度に応じてまったく別のことを行なうことさえできます。(例えば警告とエラー以外のメッセージを破棄し、警告は画面に表示して、エラーメッセージはユーザ (もしくはプログラマ) の携帯電話へ転送するなどです。ただ、これは現在のタイムゾーンにおいて昼か夜かがタイムスタンプで分かるかどうかによりますが)</p>
<p><em>ダイアログ</em> サンプルでは <a class="el" href="classwx_log_gui.html" title="これは GUI wxWidgets アプリケーションのデフォルトのログターゲットです。">wxLogGui</a> でダイアログを使用するようにカスタマイズしたカスタムログターゲットを定義する例を解説しています。</p>
<h2><a class="anchor" id="overview_log_tracemasks"></a>
トレースマスクの使用</h2>
<p>現在の wxWidgets では、もはやトレースマスクを使用する必要性がほとんどないことに注意してください。なぜなら、異なるログ文に対して異なるログコンポーネントを使用することで同じ事を実現できるためです。ログコンポーネントについての詳細は <a class="el" href="overview_log.html#overview_log_enable">ログメッセージの選択</a> を参照してください。</p>
<p>以下の関数は新しいログターゲットを作成することなく、<a class="el" href="classwx_log.html" title="wxLog クラスは wxWidgets のロギング関数で使用されるログターゲットのインタフェースを定義するクラスです。 詳細は wxLog クラスの概要を参照してください、">wxLog</a> の振る舞いを限定的に変更することができます。詳細メッセージとはリリースモードでも無効化されないトレースメッセージのことで、<a class="el" href="group__group__funcmacro__log.html#gaf57b7e28ab76bacf10b3be044e8bd634" title="詳細な出力用。">wxLogVerbose()</a> によって生成されます。ユーザがこれらのメッセージに関心を示すことがないため、通常はユーザに通知されません。しかし、ユーザがプログラムの問題を見つける際の手助けとして有効化されます。</p>
<p>(本当の) トレースメッセージについては、現在有効になっているトレースマスクに応じて処理が行われます: 指定されたメッセージのマスクに対して <a class="el" href="classwx_log.html#a4c11ee23ce5264b6c5921a17610cda13" title="wxLogTrace() の許可マスクのリストへマスクを追加します。">wxLog::AddTraceMask()</a> が呼ばれている場合はメッセージが記録されますが、そうでない場合は何も起こりません。</p>
<p>以下に例を示します。 </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__log.html#ga947e317db477914c12b13c4534867ec9" title="wxLOG_Trace ログレベル (wxLogLevelValues enum 参照) のメッセージを記録します。">wxLogTrace</a>( wxTRACE_OleCalls, <span class="stringliteral">"IFoo::Bar() called"</span> );
</pre></div><p>このメッセージは先に以下の処理を行なっている場合に記録されます:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="classwx_log.html#a4c11ee23ce5264b6c5921a17610cda13" title="wxLogTrace() の許可マスクのリストへマスクを追加します。">wxLog::AddTraceMask</a>( wxTRACE_OleCalls );
</pre></div><p>標準のトレースマスクは <a class="el" href="group__group__funcmacro__log.html#ga947e317db477914c12b13c4534867ec9" title="wxLOG_Trace ログレベル (wxLogLevelValues enum 参照) のメッセージを記録します。">wxLogTrace()</a> のドキュメントに記載しています。 </p>
</div></div><!-- window showing the filter options -->

<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div><!-- iframe showing the search results (closed by default) -->


<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/>
<address class="footer">
	<small>
		
		Page generated on Mon Jul 9 2012 15:04:15 by  <!--[Doxygen 1.7.6+] $generatedby -->
		<a href="http://www.doxygen.org/index.html" target="_new">Doxygen</a> 1.7.4
	
	</small>
</address>


<script src="wxwidgets.js" type="text/javascript"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body>
</html>
