<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>wxWidgets: wxWidgets: wxString の概要</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery-1.3.2.min.js"></script>

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr>
  
  <td id="projectlogo"><a href="http://www.wxwidgets.org/" target="_new"><img alt="Logo" src="logo.png"/></a></td>
  
  <td style="padding: 0.5em; text-align: right;">
   <span id="projectnumber">Version: 2.9.4</span>
  </td>
  
 </tr>
 </tbody>
</table>
</div><!-- Generated by Doxygen 1.7.4 -->


<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li class="current"><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>カテゴリ</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li><a href="dirs.html"><span>ディレクトリ</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">ドキュメント</a>      </li>
      <li class="navelem"><a class="el" href="page_topics.html">トピックスの概要</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の概要 </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>クラス: <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a>, <a class="el" href="classwx_array_string.html" title="wxArrayString は wxString オブジェクトを効率的に格納するためのコンテナです。">wxArrayString</a>, <a class="el" href="classwx_string_tokenizer.html" title="wxStringTokenizer は文字列を複数のトークンに分割することを支援します。">wxStringTokenizer</a></p>
<ul>
<li><a class="el" href="overview_string.html#overview_string_intro">イントロダクション</a> </li>
<li><a class="el" href="overview_string.html#overview_string_internal">wxString の内部エンコーディング</a> </li>
<li><a class="el" href="overview_string.html#overview_string_binary">wxString を使用したバイナリデータの格納</a> </li>
<li><a class="el" href="overview_string.html#overview_string_comparison">他の文字列クラスとの比較</a> </li>
<li><a class="el" href="overview_string.html#overview_string_advice">wxStringを使用するにあたってのアドバイス</a> </li>
<li><a class="el" href="overview_string.html#overview_string_related">文字列に関する他の関数やクラス</a> </li>
<li><a class="el" href="overview_string.html#overview_string_tuning">wxString のチューニング</a> </li>
<li><a class="el" href="overview_string.html#overview_string_settings">wxString に関するコンパイル設定</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="overview_string_intro"></a>
イントロダクション</h2>
<p><a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は任意の長さで、任意の Unicode 文字を含む Unicode 文字列を表すクラスです。</p>
<p>このクラスは文字列クラスに含まれていると考えるであろうすべての標準的な文字列操作機能を持っています: 動的なメモリ管理 (新しい文字にあわせて文字列を拡張します)、他の文字列や C 文字列からの構築、代入演算子、各文字へのアクセス、文字列の結合と比較、部分文字列の抽出、大文字小文字の変換、トリムと (スペースによる) パディング、検索と置換、C 言語風の <code>printf</code> (<a class="el" href="classwx_string.html#a9588b7f2684b9a6a924dc3746a2b2f8d" title="標準の sprintf() 関数と似ています。">wxString::Printf</a> ) やストリーム風の挿入関数などです。すべての関数の一覧は <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を参照してください。</p>
<p><a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> クラスは wxWidgets 3.0 では完全に書き直されますが、ANSI リテラル文字列を使用する既存のコードを以前のバージョンと同じように動作させるために様々なことを行っています。</p>
<h2><a class="anchor" id="overview_string_internal"></a>
wxString の内部エンコーディング</h2>
<p>wxWidgets 3.0 から <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の内部エンコーディングとして Windows では  (Unicode コード単位を <code>wchar_t</code> に格納する) <b>UTF-16</b> を、Unix、Linux、Mac OS X では (Unicode コード単位を <code>char</code> に格納する) <b>UTF-8</b> を使用します。</p>
<p><em>コード単位</em> と <em>コードポイント</em> の定義については <a class="el" href="overview_unicode.html#overview_unicode_encodings">Unicode 表現と用語</a> の段落を参照してください。</p>
<p>実装を単純にするため、<code>wxUSE_UNICODE_WCHAR==1</code> のとき (例えば Windows) の <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> では <em>コードポイントごとのインデックス</em> の代わりに <em>コード単位ごとのインデックス</em> を使用し、サロゲートペアについては考慮しません; つまり、コードポイントは常に 1 コード単位に格納されているものと仮定するということですが、これは <em>BMP</em> (基本多言語面) の文字にしか当てはまりません。したがって、Windows で <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> に格納された UTF-16 文字列を走査するときには、自分で <em>サロゲートペア</em> を考慮する必要があります。(ただ、画面への文字列の描画など、Windows は元々 UTF-16 のサロゲートペアに対応しています)</p>
<dl class="remark"><dt><b>注意:</b></dt><dd><code>wxUSE_UNICODE_WCHAR==1</code> のときの <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の振る舞いは UCS-2 エンコーディングに似ていますが、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を完全に UCS-2 エンコーディングとみなすことはできません。なぜなら、<em>BMP</em> 以外のコードポイントをふたつのコードポイントとして (つまり、サロゲートペアとして; ただし、すでに述べたように <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> はそれらを異なるふたつのコードポイントとして扱います) <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> に格納することができるためです。</dd></dl>
<p>代わりに <code>wxUSE_UNICODE_UTF8==1</code> (例えば、Linux、Mac OS X) とした場合、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は BMP 以外の文字でも (<em>コードポイントごとのインデックス</em> として実装されているため) UTF8 マルチバイトシーケンスとして扱います。そのため、完全に透過的な方法で UTF8 を使用することができます。</p>
<p>例: </p>
<div class="fragment"><pre class="fragment">    <span class="comment">// 最初のテストでは Unicode BMP 外の文字を使用する:</span>

    <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> test = <a class="code" href="classwx_string.html#a2ddc1b7c8e1eb9adbf5874dead5b180b" title="UTF-8 で符号化された C 文字列を UTF-8 に変換します。">wxString::FromUTF8</a>(<span class="stringliteral">"\xF0\x90\x8C\x80"</span>);
        <span class="comment">// U+10300 は "OLD ITALIC LETTER A" で、Unicode Plane 1 の一部である</span>
        <span class="comment">// UTF8 では 0xF0 0x90 0x8C 0x80 として符号化される</span>

    <span class="comment">// これは単一の Unicode コードポイントとして次のように符号化される:</span>
    <span class="comment">// - Windows では UTF16 サロゲートペア</span>
    <span class="comment">// - Linux では UTF8 マルチバイトシーケンス</span>
    <span class="comment">// (ただし終端の NULL は除く)</span>

    wxPrintf(<span class="stringliteral">"wxString reports a length of %d character(s)"</span>, test.<a class="code" href="classwx_string.html#af63f200410b56436a830550905e20539">length</a>());
        <span class="comment">// Linux では "wxString reports a length of 1 character(s)" と表示される</span>
        <span class="comment">// Windows では "wxString reports a length of 2 character(s)" と表示される</span>
        <span class="comment">// これは Windows の wxString はサロゲートペアに対応していないからだ!</span>


    <span class="comment">// ふたつ目のテストでは Unicode BMP の文字を使用する:</span>

    <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> test2 = <a class="code" href="classwx_string.html#a2ddc1b7c8e1eb9adbf5874dead5b180b" title="UTF-8 で符号化された C 文字列を UTF-8 に変換します。">wxString::FromUTF8</a>(<span class="stringliteral">"\x41\xC3\xA0\xE2\x82\xAC"</span>);
        <span class="comment">// これは大文字の A、'グレーブ付きの小文字の a'、</span>
        <span class="comment">// 'ユーロ記号' を UTF8 で符号化したもので、</span>

    <span class="comment">// 3 個の Unicode コードポイントは次のように符号化される:</span>
    <span class="comment">// - Windows では 3 個の UTF16 コード単位</span>
    <span class="comment">// - Linux では 6 個の UTF8 コード単位</span>
    <span class="comment">// (ただし終端の NULL は除く)</span>

    wxPrintf(<span class="stringliteral">"wxString reports a length of %d character(s)"</span>, test2.length());
        <span class="comment">// Linux では "wxString reports a length of 3 character(s)" と表示される</span>
        <span class="comment">// Windows では "wxString reports a length of 3 character(s)" と表示される</span>
</pre></div><p>上で述べたことをきちんと説明するために、上記の例のふたつ目の文字列に注目してください; この文字列は 3 個の文字と終端の <code>NULL</code> で構成されています: </p>
<div class="image">
<img src="overview_wxstring_encoding.png" alt="overview_wxstring_encoding.png"/>
</div>
<p>見て分かるように、UTF16 は (<em>BMP</em> の文字については) そのまま符号化しており、この例の UTF16 <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> では 8 バイトを消費します。UTF8 の符号化はより複雑で、この例では 7 バイトを消費します。</p>
<p>一般に、主にラテン文字を含む文字列について、UTF8 は必要なメモリ消費量において UTF16 よりも大きな利点がありますが、文字列長の計算などの共通操作を行なうために、より多くの計算を必要とします。</p>
<p>最後に、Unicode コード単位を格納するために <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> で使用される型 (<code>wchar_t</code> または <code>char</code>) は常に <a class="el" href="group__group__funcmacro__string.html#gaf558f1d34fbf3cf5e3258e42a40875fd" title="wxStringCharType は次のいずれかの型に定義されます:">wxStringCharType</a> として <code>typedef</code> されます。</p>
<h2><a class="anchor" id="overview_string_binary"></a>
wxString を使用したバイナリデータの格納</h2>
<p><a class="el" href="classwx_string.html#afa91a632574bcbba1bf35b54f2c5562a" title="文字列を ISO-8859-1 の 8 ビット文字列に変換し、wxCharBuffer として返却します。 (Unicode ビルド時のみ) ">wxString::To8BitData</a> 関数と <a class="el" href="classwx_string.html#a5aedc23e9cc2774237d99148d0622661" title="与えられたバイナリデータを 8 ビット文字列から wxString に変換します。">wxString::From8BitData</a> 関数を使用して、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> にバイナリデータ (<code>NUL</code> を含むこともできます) を格納することができます。</p>
<p><code>NUL</code> 文字も格納できるとは言え、現在の実装ではいくつかの関数が <code>NUL</code> 文字を含む場合にうまく動作しないことに注意してください。</p>
<p>ただし、<a class="el" href="classwx_memory_buffer.html" title="wxMemoryBuffer は任意のサイズのメモリブロックを格納するのに役立つデータ構造です。">wxMemoryBuffer</a> のように、このことを行なうためのより適切なクラスが他に存在します。バイナリデータを扱うために <a class="el" href="classwx_stream_buffer.html" title="wxStreamBuffer は wxStreamBase 用のキャッシュマネージャです: このクラスはストリームに関連付けられたストリームバッファを管理します。">wxStreamBuffer</a>、<a class="el" href="classwx_memory_output_stream.html" title="このクラスを使用することで、メモリ内へデータを書き込むために wxOutputStream のすべての関数を使用できます。 ">wxMemoryOutputStream</a>、<a class="el" href="classwx_memory_input_stream.html" title="このクラスを使用することで、メモリ内のデータを読み込むために wxInputStream のすべての関数を使用できます。 ">wxMemoryInputStream</a> についても参照したいと思うことでしょう。</p>
<h2><a class="anchor" id="overview_string_comparison"></a>
他の文字列クラスとの比較</h2>
<p>C 文字列を直接使用する代わりに特別な文字列クラスを使用する利点は、多くの文字列クラスが存在することから明らかと言えます。もっとも重要な利点は、C 文字列の場合、メモリの割り当てと解放を忘れずに行なう必要がある点です; また、固定サイズのバッファを使用すると大抵バッファオーバーランを引き起こします。最後に、C++ では標準の文字列クラス (<code>std::string</code>) が用意されています。それなのになぜ <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> が必要なのでしょうか?これにはいくつかの利点があります:</p>
<ul>
<li><b>効率性:</b> wxWidgets 3.0 の <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> ではデフォルトで <code>std::string</code> (Linux、Unix、OS X の UTF8 モード時) または <code>std::wstring</code> (Windows の UTF16 モード時) を内部的に使用します。したがって、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> はその性能上の特徴を <code>std::string</code> から引き継ぐことになります。 </li>
<li><b>互換性</b> このクラスは wxWidgets 1.xx の <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> クラス、および昔懐かしい MFC の CString クラスとほぼ完全に互換性があり、<code>std::string</code> クラスの機能の 90% と互換性があります。 </li>
<li><b>豊富な関数群</b> <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> に存在するいくつかの関数はとても便利ですが、他の文字列クラスの大半には存在しません: 例えば、<a class="el" href="classwx_string.html#a1605126b7bbf5f60a6fca7f393a58f1d" title="ch が最初に登場した位置以降のすべての文字列を取得します。">AfterFirst</a>、<a class="el" href="classwx_string.html#a9b6f088a6ef2faadf922a521df0fae3a" title="ch が最後に登場した位置以前のすべての文字列を取得します。">BeforeLast</a>、<a class="el" href="classwx_string.html#a9588b7f2684b9a6a924dc3746a2b2f8d" title="標準の sprintf() 関数と似ています。">Printf</a> などです。もちろん、標準的な文字列操作にも対応しています。 </li>
<li><b>Unicode との親和性:</b> <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は簡単に ANSI 文字列や Unicode 文字列と相互に変換できます (詳細は <a class="el" href="overview_unicode.html">wxWidgets における Unicode 対応</a> を参照してください) し、透過的に <code>std::wstring</code> へマッピングされます。 </li>
<li><b>wxWidgets での使用</b> もちろん、このクラスは wxWidgets 内部のあらゆるところで使用されています。そのため、wxWidgets が内部的に (<code>std::string</code> を含む) 他の文字列クラスを <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> へ変換することによる性能劣化が発生しません。</li>
</ul>
<p>しかし、同様にいくつかの問題も存在します。もっとも重要な問題はおそらく、まったく同じことを行なう関数が複数存在することです: 例えば、文字列の長さを取得するために <a class="el" href="classwx_string.html#af63f200410b56436a830550905e20539">wxString::length()</a>、<a class="el" href="classwx_string.html#ab20a87ca731a52c36ec674dae2213ad8" title="文字列の長さを返却します。">wxString::Len()</a>、<a class="el" href="classwx_string.html#a8895cca03120099236c002c0577b4d1c" title="文字列の長さを返却します (Len と同じです)。">wxString::Length()</a> のどれでも使用できます。他の小文字の関数のほとんどがそうであるように、最初の関数は <code>std::string</code> と互換性があります。二番目の関数は <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> "ネイティブ" の関数で、最後の関数は wxWidgets 1.xx の形式です。</p>
<p>そのため、どれを使うのが良いのでしょう? <code>std::string</code> 互換の関数を使用することを強く推奨します! そうすることで、(<code>std::string</code> に関する知識はあっても <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> のことは知らないであろう) 他の C++ プログラマにとってより馴染みのあるコードにできますし、(wxWidgets 外でコードを使用するときは <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を <code>std::string</code> として typedef することで) wxWidgets とそれ以外のプログラムで同じコードを再利用することもできます。また、wxWidgets の将来のバージョンとの互換性も保てます。なぜなら、遅かれ早かれ、おそらく wxWidgets で <code>std::string</code> を使用し始めるためです。</p>
<p><code>std::string</code> に対応する関数が存在しない場合は新しい <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> 関数を使用するようにし、wxWidgets 1.xx 版を使用しないようにしてください。これらの関数は非推奨であり、将来のバージョンでは削除されるかもしれません。</p>
<h2><a class="anchor" id="overview_string_advice"></a>
wxStringを使用するにあたってのアドバイス</h2>
<h3><a class="anchor" id="overview_string_implicitconv"></a>
暗黙の変換</h3>
<p>おそらく、このクラスを使用する際の一番の罠は <code>const char *</code> への暗黙の型変換演算子です。変換を行なうタイミングを明確にするために、代わりに <a class="el" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">wxString::c_str()</a> を使用するようにしてください。暗黙の型変換の具体的な危険性は以下のコードで分かると思います:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// この関数は入力された文字列を大文字に変換し、画面に表示した上で</span>
<span class="comment">// 結果を返却する</span>
<span class="keyword">const</span> <span class="keywordtype">char</span> *SayHELLO(<span class="keyword">const</span> <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a>&amp; input)
{
    <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> output = input.<a class="code" href="classwx_string.html#ab84d4b6e9f38ba939d61f3382d2a009b" title="大文字へ変換した文字列を返却します。">Upper</a>();
    printf(<span class="stringliteral">"Hello, %s!\n"</span>, output);
    <span class="keywordflow">return</span> output;
}
</pre></div><p>この 3 行の中にふたつの分かりにくいバグが含まれています。最初のバグは <code>printf()</code> 関数の呼び出し部分に存在します。次のような場合であれば、コンパイラによって自動的に C 文字列への暗黙的な変換が行われます。</p>
<div class="fragment"><pre class="fragment">puts(output);
</pre></div><p>なぜなら、<code>puts()</code> の引数が <code>const char *</code> 型であることが分かっているためです。これは (引数が不明な型になる) 可変数引数を受け取る <code>printf()</code> では <b>行われません</b> 。そのため、この関数呼び出しの結果は (文字列が正しく表示されることも含めて) 不定になりますが、一番起こりうるのはプログラムのクラッシュでしょう。この解決方法は <a class="el" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">wxString::c_str()</a> を使用することです。この行を単純に次のように置き換えてください:</p>
<div class="fragment"><pre class="fragment">printf(<span class="stringliteral">"Hello, %s!\n"</span>, output.<a class="code" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">c_str</a>());
</pre></div><p>ふたつ目のバグは <code>output</code> を正しく返却できないことです。暗黙的な変換が再度行われるため、コードはコンパイルできますが、返却されるポインタはローカル変数のバッファを指すことになります。そして、このローカル変数は関数を抜けるとすぐに破棄されるため、その内容は完全に不定になります。この問題の解決方法も簡単で、C 文字列の代わりに <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を返却するようにするだけです。</p>
<p>このことから、次のような一般的なアドバイスが可能です: 文字列を引数として受け取るすべての関数は <code>const <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a>&amp;</code> を受け取るべきで (こうすることで内部文字列への代入が早くなります)、文字列を返却するすべての関数は <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を返却するべきです (これにより、安全にローカル変数を返却することができます)。</p>
<p>最後に、C リテラル文字列を Unicode へ変換するために <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> では現在のロケールを使用します。同じことが <code>std::string</code> との変換と、c_str() の戻り値に対しても行われます。この変換では <em>wxConvLibc</em> クラスのインスタンスが使用されます。<a class="el" href="classwx_c_s_conv.html" title="このクラスはシステムでサポートされている任意の文字コードと Unicode とを相互変換します。">wxCSConv</a> と <a class="el" href="classwx_m_b_conv.html" title="このクラスはマルチバイト (SBCS や DBCS) エンコーディングと Unicode との変換を行なうクラスの基底クラスです。">wxMBConv</a> を参照してください。</p>
<h3><a class="anchor" id="overview_string_iterating"></a>
wxString の文字の走査</h3>
<p>前に述べたように、<code>wxUSE_UNICODE_UTF8==1</code> の場合に <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は可変長の UTF-8 エンコーディングを内部的に使用します。インデックスによる UTF-8 文字列へのアクセスは非常に <b>非効率的</b> です。なぜなら、1 文字が可変バイトで表されるため、該当する文字を見つけるために文字列全体を解析する必要があるためです。インデックスによる文字列の走査はよく使われるプログラミングテクニックであり、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> では operator[]() を使用することを推奨していたため、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は最後に使用したインデックスをキャッシュするように実装されています。これにより、UTF-8 モードであっても文字列全体の走査を線形時間で行なうことができます。</p>
<p>とはいえ、(インデックスによるアクセスの代わりに) このように <b>イテレータ</b> を使用することを推奨します:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> s = <span class="stringliteral">"hello"</span>;
wxString::const_iterator i;
<span class="keywordflow">for</span> (i = s.<a class="code" href="classwx_string.html#ad59ca2dd208720b3cce07d90bcb90093">begin</a>(); i != s.<a class="code" href="classwx_string.html#a6a0f235fff88df5e6b16b5f0e1e719cc">end</a>(); ++i)
{
    <a class="code" href="classwx_uni_char.html" title="このクラスはひとつの Unicode 文字を表します。">wxUniChar</a> uni_ch = *i;
    <span class="comment">// なんらかの処理</span>
}
</pre></div><h2><a class="anchor" id="overview_string_related"></a>
文字列に関する他の関数やクラス</h2>
<p>多くのプログラムで文字列が使用されていますが、標準 C ライブラリではそれらのプログラムで使用できる関数をほんの少ししか提供していません。残念なことに、いくつかの関数は直感的でない振る舞いをします (例えば <code>strncpy()</code> は結果の文字列を常に <span class="literal">NULL</span> で終端させるとは限りません) し、一般的にあまり安全ではありません。（それらの関数に <span class="literal">NULL</span> を渡すとおそらくプログラムがクラッシュするでしょう) その上、いくつかの非常に便利な関数は標準関数ではありません。これが <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の関数に加えて若干のグローバル文字列関数が存在する理由です: <a class="el" href="group__group__funcmacro__crt.html#ga4d749baaa27c4c97d579733b0ac6a495">wxIsEmpty()</a> は文字列が空かどうかを確かめます。(<span class="literal">NULL</span> ポインタに対しては <span class="literal">true</span> を返却します) <a class="el" href="group__group__funcmacro__crt.html#ga8ee0fe62cfc16ac60a217e825dcf4ba5">wxStrlen()</a> も <span class="literal">NULL</span> を正しく取り扱うことができ、<span class="literal">NULL</span> の場合は 0 を返却します。 wxStricmp() は単なるプラットフォーム非依存の大文字小文字を区別しない文字列比較関数で、プラットフォームによっては <code>stricmp()</code> や <code>strcasecmp()</code> として知られています。</p>
<p>また、<code>&lt;<a class="el" href="interface_2wx_2string_8h.html">wx/string.h</a>&gt;</code> ヘッダでは ::wxSnprintf 関数と ::wxVsnprintf 関数も定義しています。潜在的に危険な標準の <code>sprintf()</code> の代わりにこれらの関数を使用するべきであり、これらの関数ではバッファサイズのチェックを行なう <code> snprintf()</code> をできるだけ使用しています。もちろん、<a class="el" href="classwx_string.html#a9588b7f2684b9a6a924dc3746a2b2f8d" title="標準の sprintf() 関数と似ています。">wxString::Printf</a> も安全なので使用しても構いません。</p>
<p>他にも <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> と一緒に使用すると便利なクラスがあります: それが <a class="el" href="classwx_string_tokenizer.html" title="wxStringTokenizer は文字列を複数のトークンに分割することを支援します。">wxStringTokenizer</a> です。このクラスは文字列をトークンに分解する必要があるときに便利で、標準 C ライブラリの <code>strtok()</code> 関数の代わりになります。</p>
<p>そして、文字列に関する最後のクラスが <a class="el" href="classwx_array_string.html" title="wxArrayString は wxString オブジェクトを効率的に格納するためのコンテナです。">wxArrayString</a> です: これは単なる "テンプレート" 動的配列クラスの一種で、文字列に対して使用するように特殊化されています。このクラスは (<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の内部構造に関する知識を用いて) 文字列の格納に特化して最適化されています。そのため、wxObjectArray に wxString を格納するより性能面で優れています。</p>
<h2><a class="anchor" id="overview_string_tuning"></a>
wxString のチューニング</h2>
<dl class="note"><dt><b>注:</b></dt><dd>この章では性能に関する問題のみを取り扱っており、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> クラスを使用するだけであれば読む必要はまったくありません。プロファイラやその関連ツールについて詳しくないのであればこの章を読み飛ばしてください。</dd></dl>
<p>性能上の理由から、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は各文字列で必要とされる量ちょうどのメモリを割り当てません。代わりに、各割り当て済みブロックに少しだけメモリを追加します。割り当て済みブロックを用いることで、例えば以下のように一度に一文字ずつ連結して文字列を構築する場合などに、頻繁にメモリの再割り当てを行わなくても良くなります:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// 文字列から母音をすべて削除する</span>
<a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> DeleteAllVowels(<span class="keyword">const</span> <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a>&amp; original)
{
    <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> vowels( <span class="stringliteral">"aeuioAEIOU"</span> );
    <a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> result;
    wxString::const_iterator i;
    <span class="keywordflow">for</span> ( i = original.<a class="code" href="classwx_string.html#ad59ca2dd208720b3cce07d90bcb90093">begin</a>(); i != original.<a class="code" href="classwx_string.html#a6a0f235fff88df5e6b16b5f0e1e719cc">end</a>(); ++i )
    {
        <span class="keywordflow">if</span> (vowels.Find( *i ) == <a class="code" href="defs_8h.html#a89de5e6353fc7812991b085e12263e98">wxNOT_FOUND</a>)
            result += *i;
    }

    <span class="keywordflow">return</span> result;
}
</pre></div><p>これは非常によくある状況であり、余分なメモリを割り当てない場合、著しい性能劣化を引き起こします。これは元の文字列に含まれる文字数分、メモリの (再) 割り当てが行われるためです。この場合では余分なメモリを割り当てることで処理速度が改善されましたが、通常のプログラムでは非常に多くの <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> が使用されるため、メモリ消費量も大きく増加します。</p>
<p>この例での最適な解決方法は <a class="el" href="classwx_string.html#a87e614d9924a1b5524334aac3fc96d38" title="nLen 文字を格納するために必要なメモリを wxString に事前に割り当てる。">wxString::Alloc()</a> 関数を用いて、最初に例えば len バイトほど割り当てておくことです。これにより、メモリの割り当てが確実に 1 回だけ行われます。(なぜなら、変換結果の文字列の長さは最大でも元の文字列と同じだからです)</p>
<p>しかし、<a class="el" href="classwx_string.html#a87e614d9924a1b5524334aac3fc96d38" title="nLen 文字を格納するために必要なメモリを wxString に事前に割り当てる。">wxString::Alloc()</a> を使用するのは手間がかかるため、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> ではできるだけのことをしています。デフォルトのアルゴリズムでは少なくとも 16 バイト単位でメモリの割り当てが行われると仮定している (これは広く使われているほぼすべてのプラットフォームで当てはまります) ため、メモリの割り当て量が 16 の倍数に切り上げられたとしても何も無駄になりません。このように、メモリが無駄になることはありませんし、上記の例では 16 回の繰り返しのうち、15 回はメモリの割り当てが行われず、割り当て済みのプールが使用されます。</p>
<p>このデフォルトのやり方は非常に保守的です。より多くのメモリを割り当てることで、(相対的に) とても長い文字列を使用するプログラムでは性能が大きく向上することでしょう。割り当てられるメモリの量は string.cpp ファイルの <code> EXTRA_ALLOC</code> を変更することでコンパイル時に設定することができます。(値を変更する前に、なぜデフォルト値がその値になっているのかをよく理解するようにしてください!) この値を大きく (ここでは nLen の倍にしたとしましょう) したり、(性能の劣化具合を確認するために) 0 に設定したりしてプログラムに与える影響を分析しようとするかもしれません。これを行なう場合、<code>WXSTRING_STATISTICS</code> シンボルも定義すると便利なことにおそらく気がつくでしょう。これを定義すると <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> クラスで性能統計を収集し、プログラムの終了時に標準エラー出力へ出力させることができます。これにより、プログラムで使用する文字列の平均長、平均初期サイズ、および文字列を連結する際にメモリを割り当てず、割り当て済みのメモリを使用した回数の割合 (デフォルトの設定では約 98% のはずですが、これが 90% を下回る場合には <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> のチューニングを本当に検討するべきです) が分かります。</p>
<p>言うまでもないことですが、<code>EXTRA_ALLOC</code> を変更したときの正確な違いを計測するためにプロファイラを使用するべきです。</p>
<h2><a class="anchor" id="overview_string_settings"></a>
wxString に関するコンパイル設定</h2>
<p>ANSI リテラル文字列を使用する既存のコードを 3.0 以前のバージョンと同じように動作させるために様々なことを行っています。</p>
<p>Unix や Linux でも <code>wchar_t</code> を使用する <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> が必要な場合、コマンドラインで <code>configure</code> <code>--disable-utf8</code> スイッチを指定するか、代わりに <a class="el" href="classwx_u_string.html" title="wxUString は各文字が 32 ビット値に格納される Unicode 文字列を表したクラスです。">wxUString</a> もしくは <code>std::wstring</code> を使用することができます。</p>
<p>Unicode に対応していることを表すため、現在ではデフォルトで <code>wxUSE_UNICODE</code> が <code>1</code> に定義されています。<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の内部領域に UTF-8 を使用する場合、あわせて <code>wxUSE_UNICODE_UTF8</code> が定義されます。そうでない場合は <code>wxUSE_UNICODE_WCHAR</code> が定義されます。<a class="el" href="page_wxusedef.html#page_wxusedef_important">もっとも重要な wxUSE シンボル</a> も参照してください。 </p>
</div></div><!-- window showing the filter options -->

<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div><!-- iframe showing the search results (closed by default) -->


<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/>
<address class="footer">
	<small>
		
		Page generated on Mon Jul 9 2012 15:04:16 by  <!--[Doxygen 1.7.6+] $generatedby -->
		<a href="http://www.doxygen.org/index.html" target="_new">Doxygen</a> 1.7.4
	
	</small>
</address>


<script src="wxwidgets.js" type="text/javascript"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body>
</html>
