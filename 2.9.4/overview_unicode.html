<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>wxWidgets: wxWidgets: wxWidgets における Unicode 対応</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="custom_stylesheet.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery-1.3.2.min.js"></script>

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr>
  
  <td id="projectlogo"><a href="http://www.wxwidgets.org/" target="_new"><img alt="Logo" src="logo.png"/></a></td>
  
  <td style="padding: 0.5em; text-align: right;">
   <span id="projectnumber">Version: 2.9.4</span>
  </td>
  
 </tr>
 </tbody>
</table>
</div><!-- Generated by Doxygen 1.7.4 -->


<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>メインページ</span></a></li>
      <li class="current"><a href="pages.html"><span>関連ページ</span></a></li>
      <li><a href="modules.html"><span>カテゴリ</span></a></li>
      <li><a href="annotated.html"><span>クラス</span></a></li>
      <li><a href="files.html"><span>ファイル</span></a></li>
      <li><a href="dirs.html"><span>ディレクトリ</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="検索" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="index.html">ドキュメント</a>      </li>
      <li class="navelem"><a class="el" href="page_topics.html">トピックスの概要</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">wxWidgets における Unicode 対応 </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>この章では wxWidgets による Unicode 対応方法とプログラムへの影響について述べます。</p>
<p>wxWidgets 3.0 では Unicode の対応方法が大きく変わるため、以前のバージョンに関連する多くのことが、もはや正しくなくなることに注意してください。変更の詳細は <a class="el" href="overview_changes_since28.html#overview_changes_unicode">Unicode に関連する変更</a> を参照してください。</p>
<p>すでに Unicode について詳しい場合、最初の 2 つの章は飛ばして、直接ライブラリの対応内容の詳細に飛んでください。 </p>
<ul>
<li><a class="el" href="overview_unicode.html#overview_unicode_what">Unicode とは?</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_encodings">Unicode の表現方法と用語</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_supportin">wxWidgets における Unicode 対応</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_pitfalls">Unicode の潜在的な落とし穴</a> </li>
<li><a class="el" href="overview_unicode.html#overview_unicode_supportout">Unicode と外部の世界</a></li>
</ul>
<hr/>
<h2><a class="anchor" id="overview_unicode_what"></a>
Unicode とは?</h2>
<p>Unicode とは、 1 文字あたり 8、 16、 32 ビットを使用することで、これまでの標準的な文字コード (例えば ASCII) の欠点に対処した文字コードの標準規格のことです。これにより、 世界中の言語を一度に表現するのに十分な量のコードポイント (定義は以下を参照) が得られます。Unicode についての詳細は <a href="http://www.unicode.org/.">http://www.unicode.org/</a> にあります。</p>
<p>実用的な観点から見ると、世界中の人に向けてアプリケーションを書く時には Unicode の使用がほぼ必須と言えます。さらに、アプリケーション外で作成されたファイルを読み込んだり、ネットワーク経由で他のサービスからデータを読み込んだりするアプリケーションは Unicode を取り扱う準備をしておくべきです。</p>
<h2><a class="anchor" id="overview_unicode_encodings"></a>
Unicode の表現方法と用語</h2>
<p>Unicode を使用するときは、いくつかの言葉を定義しておくことが重要です。</p>
<p><b><em>グリフ</em></b> とは、文字、あるいは文字の一部を表現する特定のイメージです。 (通常はフォントの一部です) どの文字も 1 つまたは複数のグリフと関連付けられています; 例えば、大文字の 'A' であれば以下のようなグリフが関連付けられているかもしれません</p>
<div class="image">
<img src="overview_unicode_glyphs.png" alt="overview_unicode_glyphs.png"/>
</div>
<p>Unicode では、存在するほぼすべての文字を <b><em>コードポイント</em></b> と呼ばれる番号に割り当てています; 一般的に、マニュアルや Unicode のウェブサイトでは <code>U+xxxx</code> (<code>xxxx</code> は 16 進数です) という形で表現されます。</p>
<p>通常、ひとつの文字は厳密にひとつのコードポイントに割り当てられますが、なかには例外もあります; いわゆる <em>合成済み文字</em> (<a href="http://en.wikipedia.org/wiki/Precomposed_character">http://en.wikipedia.org/wiki/Precomposed_character</a> 参照) や <em>合字 (リガチャ)</em> のことです。これらの場合、ひとつの "文字" が複数のコードポイントにマッピングされたり、逆に複数の文字がひとつのコードポイントにマッピングされたりします。</p>
<p>Unicode 標準規格では取りうるすべてのコードポイントを <b><em>面</em></b> に分割しています; 面とは、連続する 65,536 (1000016) 個の Unicode コードポイントのことです。面は 0 から 16 までの番号が振られており、最初の面が <em>BMP</em> (基本多言語面) です。BMP にはすべての現代語の文字と、多くの特殊文字が含まれています。実際のところ、他の面は主に歴史上の文字や特殊用途の文字用か、もしくは使用されていません。</p>
<p>コードポイントはメモリ上ではひとつ以上の <b><em>コード単位</em></b> の並びとして表現されます。コード単位とは 8、16、32 ビットといったメモリの単位のことです。より正確に言うと、コード単位とは、テキスト処理または交換のために符号化された文字を表現可能な最小のビットの組み合わせです。</p>
<p><b><em>UTF</em></b> (Unicode Transformation Format) は Unicode コードポイントをコード単位の並びにマッピングするためのアルゴリズムです。もっとも単純なものは <b>UTF-32</b> です。これは各コード単位が 32 ビット (4 バイト) から成り、各コードポイントは常にひとつのコード単位で表現される固定長エンコーディングです。 (UTF-32 であっても、リトルエンディアンとビッグエンディアンではバイト列へのマッピングが異なるため、完全に自明とはまだ言えないことに注意してください。) 一般に、UTF-32 は Unix システムにおける Unicode 文字列の内部表現に使用されています。</p>
<p>非常に広く使われている別の規格として、Microsoft Windows で使われている <b>UTF-16</b> があります。これは最初の約 64,000 個の Unicode コードポイント (基本多言語面) を 16 ビット (2 バイト) のコード単位で符号化し、それ以降の文字は 16 ビットのコード単位の組で符号化します。これらのコード単位の組のことを <em>サロゲート</em> と呼びます。したがって、UTF16 は各コードポイントを符号化するために可変数のコード単位を使用します。</p>
<p>最後に、Unicode を外部記憶装置 (ファイルやネットワークプロトコルなど) へ格納する際に一番広く使われているのが <b>UTF-8</b> です。これはバイト指向のエンコーディングであるため、 UTF-16 や UTF-32 のようにエンディアンの曖昧さがありません。UTF-8 は 8 ビット (1 バイト) のコード単位を使用します; 普通のアルファベット以外のコードポイントは可変バイトで表現されるため、内部表現としては UTF-32 よりも若干効率が落ちます。</p>
<p>今までに述べたコンセプトの違いを理解するため、同じコードポイントにおける UTF の表現方法の違いを見てください。</p>
<div class="image">
<img src="overview_unicode_codes.png" alt="overview_unicode_codes.png"/>
</div>
<p>この場合では、UTF8 は UTF16 よりも多くの領域が必要となります。 (2 バイトではなく 3 バイト)</p>
<p>C/C++ プログラマの観点からすれば、状況はもっと複雑です。というのも、C/C++ で Unicode ( "ワイド" ) 文字列を表現するためによく使われる <code>wchar_t</code> 型は、すべてのプラットフォームで同じサイズとは限らないためです。Unix システムでは UTF-32 を使用してきた慣習にあわせて 4 バイトですが、Windows では UTF-16 を使用する OS との互換性のため、2 バイトとなっています。</p>
<p>一般的に、UTF8 を使用するときはコード単位を <code>char</code> に格納します。なぜなら、ほぼすべてのシステムで <code>char</code> 型は 8 ビットの大きさを持つためです; そして、一般的に UTF-16 を使用するときはコード単位を <code>wchar_t</code> 型に格納します。 <code>wchar_t</code> はすべてのプラットフォームで少なくとも 16 ビットだからです。これは <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> で採用されている方法でもあります。詳しくは <a class="el" href="overview_string.html">wxString の概要</a> を参照してください。</p>
<p>上で述べた用語の正式な定義は <a href="http://unicode.org/glossary/">http://unicode.org/glossary/</a> を参照してください。</p>
<h2><a class="anchor" id="overview_unicode_supportin"></a>
wxWidgets における Unicode 対応</h2>
<h3><a class="anchor" id="overview_unicode_support_default"></a>
デフォルトで Unicode が常に使用されます</h3>
<p>wxWidgets 3.0 からは Unicode が常に有効になります。Unicode を使用せずにライブラリをビルドすることはまだ可能ですが、もはや非推奨であり、近い将来、サポートされなくなります。これはつまり、内部的には Unicode 文字列のみが使用され、Microsoft Windows では Unicode 版のシステム API が使用されることを意味します。そしてこれは Windows 95/98/ME で wxWidgets プログラムを実行する際に Microsoft Layer for Unicode が必要となることを意味します。</p>
<p>しかし、wxWidgets の以前のバージョンにおける Unicode ビルドモードとは異なり、この対応はほとんど透過的です： <b>ワイド</b> 文字列 (UTF16 で符号化された <code>wchar_t*</code> か、UTF8 で符号化された <code>char*</code> のことです) がサポートされていても、引き続き  <b>ナロー</b> 文字列 (現在のロケールで符号化された <code>char*</code> のことです) を使用することができます。 どの wxWidgets 関数も引数を暗黙的に <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> へ変換するため、どちらの型でも受け付けます。 </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#ga193c64ed4802e379799cdb42de252647" title="汎用的なメッセージダイアログを表示します。">wxMessageBox</a>(<span class="stringliteral">"Hello, world!"</span>);
</pre></div><p> そして、若干、一般的ではないですが、 </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#ga193c64ed4802e379799cdb42de252647" title="汎用的なメッセージダイアログを表示します。">wxMessageBox</a>(L<span class="stringliteral">"Salut \u00E0 toi!"</span>); <span class="comment">// U+00E0 は "グレイヴ付きのラテン小文字の a" です</span>
</pre></div><p> これは期待した通りに動作します。</p>
<p>wxWidgets で使用されるナロー文字列は <em>常に</em> 現在のロケールで符号化されていると仮定されます。 </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#ga193c64ed4802e379799cdb42de252647" title="汎用的なメッセージダイアログを表示します。">wxMessageBox</a>(<span class="stringliteral">"Salut à toi!"</span>);
</pre></div><p> これはユーザのシステムが ISO-8859-1 と互換性がない場合 (gcc の場合、別のロケールでコンパイルされたとしても) 、うまく動作しません。特に、最近の Unix システムで最もよく使われているエンコーディングは UTF-8 であり、上記の文字列は正しい UTF-8 バイト列ではないため、この場合は何も表示されないでしょう。したがって、<b>プログラムソース内で (7 ビット文字の代わりに) 8 ビット文字列を直接しない</b> ことが重要であり、ワイド文字列を使用するか、代わりに以下のように書いてください: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="group__group__funcmacro__dialog.html#ga193c64ed4802e379799cdb42de252647" title="汎用的なメッセージダイアログを表示します。">wxMessageBox</a>(<a class="code" href="classwx_string.html#a2ddc1b7c8e1eb9adbf5874dead5b180b" title="UTF-8 で符号化された C 文字列を UTF-8 に変換します。">wxString::FromUTF8</a>(<span class="stringliteral">"Salut \xC3\xA0 toi!"</span>));
    <span class="comment">// UTF-8 では U+00E0 は 0xC3A0 と符号化される</span>
</pre></div><p>同様に、<code>wchar_t</code> と <code>char</code> のどちらででも <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の保持する文字列にアクセスできます。もちろん、文字列が現在のロケールのエンコーディングで表現可能である場合のみ、後者の型で正しくアクセスできます。文字列がナロー文字列か 7 ビット ASCII データで初期化されているのであれば、常にこの場合に当てはまりますが、それ以外の場合ではこの変換が常に成功することは保証されません。また、上の <a class="el" href="classwx_string.html#a2ddc1b7c8e1eb9adbf5874dead5b180b" title="UTF-8 で符号化された C 文字列を UTF-8 に変換します。">wxString::FromUTF8()</a> を使ったサンプルのように、UTF-8 で符号化された文字列を取得するために常に <a class="el" href="classwx_string.html#ac923e0bcfda57ec5064dcade9808db94" title="utf8_str() と同じです。">wxString::ToUTF8()</a> を使うことができます。この方法は、現在のロケールを使用して <code>char*</code> に変換する方法と比較して、変換に失敗することがありません。</p>
<p><a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の挙動についての詳細は <a class="el" href="overview_string.html">wxString の概要</a> を参照してください。</p>
<p>まとめると、wxWidgets による Unicode 対応はアプリケーションにとってほとんど <b>透過的</b> であり、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> オブジェクトを使ってすべての文字データを格納するのであれば、特別なことをなにもする必要がありません。しかし、次の章で触れる、潜在的な問題については注意すべきです。</p>
<h3><a class="anchor" id="overview_unicode_support_utf"></a>
Unicode 表現の選択</h3>
<p>すべてのシステムにおいて、wxWidgets はデフォルトで <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の実装に <code>wchar_t</code> を使用します。したがって、Microsoft Windows では <code>wchar_t</code>  が 2 バイトであるため、UCS-2 (サロゲート文字をサポートしない、UTF-16 の簡略化版です) が使用されます。Mac OS X を含む Unix システムでは、デフォルトで (UTF-32 としても知られる) UCS-4 が使用されますが、設定に <code>--enable-utf8</code> オプションを渡すことで内部に UTF-8 を使用するように wxWidgets をビルドすることも可能です。</p>
<p><a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の提供するインタフェースはその内部フォーマットによらず、同一です。しかし、各フォーマットにはそれぞれ利点と欠点があります。特に、Unix のグラフィカルツールキット ( GTK+ など) は普通、UTF-8 文字列を使用しており、wxWidgets でも同じ符号化方式を使用することで、UI に文字列を表示するときや逆に文字列を取得するときに毎回 UTF-32 から UTF-8 に変換する必要がなくなります。この変換にかかるオーバーヘッドは小さな文字列であれば無視できるものですが、いくつかのプログラムでは重要になるかもしれません。もしあなたのアプリケーションで UTF-8 が好都合だと思うのなら、上で説明したように UTF-8 を使用するように wxWidgets をビルドし直してください。 (今のところ、Microsoft Windows ではこれに対応しておらず、Windows 自身は UTF-8 ではなく UTF-16 を使用しているため、明らかにあまり意味がないことに注意してください) ただし、これを行う前に <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> で UTF-8 を使用することによる性能への影響 (<a class="el" href="overview_unicode.html#overview_unicode_performance">UTF-8 を使用することによる性能への影響</a> 参照) を必ず意識するようにしてください!</p>
<p>一般的に言うと、リソースが限られており、変換にかかるオーバーヘッド (と、ヨーロッパ言語において UTF-32 の代わりに UTF-8 を使用することによるメモリ消費量の削減) が重要となる、といった特殊な状況下でのみ、非標準の UTF-8 ビルドを使用するべきです。(そのような状況では、よくこの場合に当てはまりますが) もしプログラムの実行される環境を制御できるのであれば、システムが常に UTF-8 ロケールを使用するようにし、<code>--enable-utf8only</code> オプションを使用して他のロケールのサポートを無効にすることを考慮してみてください。これはコードサイズをさらに削減させるとともに、より多くの場合で変換が不要になります。</p>
<h3><a class="anchor" id="overview_unicode_settings"></a>
Unicode 関連のプリプロセッサシンボル</h3>
<p>Unicode に対応しているため、現在、 <code>wxUSE_UNICODE</code> は 1 として定義されています。MSW では <code>setup.h</code> 内で明示的に 0 にセットするか、Unix では <code>--disable-unicode</code> を使用することができますが、これは推奨しません。デフォルトでは <code>wxUSE_UNICODE_WCHAR</code> も 1 に定義されていますが、(前の章で述べた) UTF-8 ビルドでは 0 に設定されており、通常は 0 に設定されている <code>wxUSE_UNICODE_UTF8</code> が代わりに 1 に設定されています。UTF-8 ビルドを行う場合、すべての文字列が UTF-8 であることを表すために <code>wxUSE_UTF8_LOCALE_ONLY</code> も 1 に設定することができます。</p>
<h2><a class="anchor" id="overview_unicode_pitfalls"></a>
Unicode の潜在的な落とし穴</h2>
<p>発生しうる問題は大まかに 3 種類に分類することができます:</p>
<h3><a class="anchor" id="overview_unicode_compilation_errors"></a>
Unicode 関連のコンパイルエラー</h3>
<p><code>char</code> と <code>wchar_t</code> の暗黙的な相互変換をサポートする必要があるため、 <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の実装はかなり複雑で、演算子の多くは (返却されるものと) 単純に予想される型を実際には返却しません。例えば、[] <code>演算子</code> が返却する型は <code>char</code> でも<code>wchar_t</code> でもなく、どちらの型にも変換可能なヘルパークラスである <a class="el" href="classwx_uni_char.html" title="このクラスはひとつの Unicode 文字を表します。">wxUniChar</a> か <a class="el" href="classwx_uni_char_ref.html" title="wxString 内の文字列の書き込み可能な参照です。">wxUniCharRef</a> です。これらの変換は裏側で行われるため、通常はこのことを気にする必要はありませんが、いくつかの場合ではうまく動作しないことがあります。その例を以下に示します。この例では <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> オブジェクト <code>s</code> と、ある整数 <code>n</code> を使用しています: </p>
<ul>
<li>次のように書くと <div class="fragment"><pre class="fragment"> <span class="keywordflow">switch</span> ( s[n] ) 
</pre></div> うまく動作しません。なぜなら、switch 文の引数は整数式でなければならないためです。そのため、<code>s</code>[n] を次のように置き換える必要があります。 <div class="fragment"><pre class="fragment"> s[n].GetValue() 
</pre></div> もしくは、明示的なキャストを用いて強制的に <code>char</code> か <code>wchar_t</code> へ変換することもできますが、 char 型への変換は現在のロケールに対して行われ、変換に失敗した場合は 0 が返却されることに注意してください。最後の注意点として、次のように書くと <div class="fragment"><pre class="fragment"> (<a class="code" href="group__group__funcmacro__string.html#gad42f64d8c82f1ce4ae58773a89b2d6a7" title="wxChar は次のように定義されます。">wxChar</a>)s[n] 
</pre></div> wxWidgets 3.0 と以前のバージョンの両方で動作します。そのため、2.8 と 3.0 で互換性のあるコードを書かなければならない場合はこのように書くべきです。</li>
</ul>
<ul>
<li>同様に、 <div class="fragment"><pre class="fragment"> &amp;s[n] 
</pre></div> では char 型のポインタを得ることはできないため、これを <code>char*</code> または <code>wchar_t*</code> を受け取る関数に渡すことはできません。可能であれば代わりに文字列のイテレータを使用するようにするか、次のように置き換えてください。 <div class="fragment"><pre class="fragment"> s.<a class="code" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">c_str</a>() + n 
</pre></div>  </li>
</ul>
<p>発生しうる別の問題は <code>c_str()</code> 自身の返却する値もまたバッファのポインタではなく、暗黙的にナロー文字列やワイド文字列へ変換可能なヘルパークラス wxCStrData であることに関連しています。これはほとんど目立ちませんが、いくつかの問題を引き起こすことがあります:</p>
<ul>
<li><code>c_str()</code> の戻り値を標準 <code>printf()</code> などの可変引数関数へ渡してはいけません。いくつかのコンパイラ (特に g++) では警告が出ますし、仮に警告が出ないとしても <div class="fragment"><pre class="fragment"> printf(<span class="stringliteral">"Hello, %s"</span>, s.<a class="code" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">c_str</a>()) 
</pre></div> これは正常に動作しないでしょう。下記のいずれかの方法でこれを修正することができます:</li>
</ul>
<ul>
<li>推奨: <div class="fragment"><pre class="fragment"> wxPrintf(<span class="stringliteral">"Hello, %s"</span>, s) 
</pre></div> (<code>c_str()</code> を使用していないことに注目してください。wxWidgets の関数にはそれは必要ありません)</li>
<li>wxWidgets 2.8 互換: <div class="fragment"><pre class="fragment"> wxPrintf(<span class="stringliteral">"Hello, %s"</span>, s.<a class="code" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">c_str</a>()) 
</pre></div></li>
<li>ナロー (マルチバイト) 文字列への明示的な変換: <div class="fragment"><pre class="fragment"> printf(<span class="stringliteral">"Hello, %s"</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)s.<a class="code" href="classwx_string.html#adcfd12e6d0765b1d74bccc3d63d02e98" title="wxMBConv::cWC2MB 関数を使用して文字列をマルチバイト (C 形式) 表現方法に変換し、wxCharBuffer として返却します。">mb_str</a>()) 
</pre></div></li>
<li>型を決定させるためのキャスト (これはリストの網羅性のために上げているだけです): <div class="fragment"><pre class="fragment"> printf(<span class="stringliteral">"Hello, %s"</span>, (<span class="keyword">const</span> <span class="keywordtype">char</span> *)s.<a class="code" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">c_str</a>()) 
</pre></div></li>
</ul>
<ul>
<li><code>c_str()</code> の戻り値は <code>char*</code> にはキャストできず、<code>const</code> <code><code>char*</code></code> にのみキャスト可能です。もちろん、この関数の戻り値のポインタを通して文字列を変更することはできませんが、残念なことに、正しく const を受け取らない関数へ値を渡すために <code>const_cast</code> を使用するときに役立ちます。これは新しい <a class="el" href="classwx_string.html#aedcaea87fc347a940263a533bd56846f" title="暗黙的に char* ポインタへ変換可能な文字列データを持つオブジェクトを返却します。">wxString::char_str()</a> (や、これに対応する wchar_str()) 関数か、2 重キャストを用いることで実現できます: <div class="fragment"><pre class="fragment"> (<span class="keywordtype">char</span> *)(<span class="keyword">const</span> <span class="keywordtype">char</span> *)s.<a class="code" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">c_str</a>() 
</pre></div></li>
</ul>
<ul>
<li><code>c_str()</code> を使用せずに <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を <code>wxPrintf()</code> へ渡せるようにした不幸な結果のひとつとして、無名 enum の要素を <code>wxPrintf()</code> や類似の可変長関数へ渡せなくなりました。 <div class="fragment"><pre class="fragment">        <span class="keyword">enum</span> { Red, Green, Blue };
        wxPrintf(<span class="stringliteral">"Red is %d"</span>, Red);
</pre></div> これはコンパイルすることができません。もっとも簡単な回避方法としては enum に名前をつけることです。</li>
</ul>
<p>他にも予期しないコンパイルエラーが発生することがありますが、発生頻度が上で挙げたものより少なく、解決方法も非常に単純です: コンパイラが <a class="el" href="classwx_uni_char.html" title="このクラスはひとつの Unicode 文字を表します。">wxUniChar</a> と wxCStrDatajust のどちらを使用すれば良いか判断できない場合には、暗黙的な変換に頼るのではなく、明示的にそれらの関数を使用するだけです。</p>
<h3><a class="anchor" id="overview_unicode_data_loss"></a>
Unicode の変換エラーによるデータ喪失</h3>
<p><a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> API は内部の Unicode 文字列からナロー (char) 文字列への暗黙的な変換を行います。この変換機能は非常に便利であり、wxWidgets を使った既存コードとの後方互換性のためには絶対に欠かすことができません。しかし、これは非常に危険な操作で、文字列の内容が現在のロケールに変換できない場合は予期しない結果を簡単に引き起こします。</p>
<p>正確に言うと、最初にナロー文字列から文字列が作られたのであれば、変換は常に成功します。また、Unicode 文字列はすべて UTF-8 で表現することが可能なため、現在のエンコーディングが UTF-8 である場合も常に成功します。しかし、<a class="el" href="classwx_string.html#a2ddc1b7c8e1eb9adbf5874dead5b180b" title="UTF-8 で符号化された C 文字列を UTF-8 に変換します。">wxString::FromUTF8()</a> 関数で初期化した文字列に対して、<a class="el" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">wxString::c_str()</a> 関数を使って char 文字列のようにアクセスしようとするのは災いのもとです。そのプログラムは UTF-8 ロケールを使用している Unix システムでテストしている間は完璧に動作するでしょうが、UTF-8 ロケールを使用していない Windows では <a class="el" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">wxString::c_str()</a> が空文字列を返すかもしれないため、全く動作しなくなるでしょう。</p>
<p>これが起きないようにする一番単純な方法は、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を使った <code>char*</code> への変換を避けることです。しかし、内部で絶対に 8 ビット文字列を操作しないというのであれば、<code>char*</code> ポインターを使用しても安全です。そのため、wxWidgets 3.0 にアップグレードするときは既存のコードを見直す必要があるとともに、新しいコードではこのことを意識しつつ、理想的には <code>char*</code> への暗黙的な変換を避けるようにするべきです。.</p>
<h3><a class="anchor" id="overview_unicode_performance"></a>
UTF-8 を使用することによる性能への影響</h3>
<p>上で述べたように、Unix システムでは <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> クラスの内部表現に可変長の UTF-8 を使用することができます。その場合、文字列中のN 番目の要素へ定数時間でアクセスできることはもはや保証されません。なぜなら、その要素の位置を見つけるためにはその前の文字列をすべて調べる必要があるためです。大半のアルゴリズムでは文字列を逐次的に調べますし、<a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は文字列にインデックスでアクセスするためのキャッシュを持つため、通常はこのことがそれほど問題になることはありません。しかし、文字列にランダムアクセスするアルゴリズムにとっては、一般的に計算時間が O(N) から O(N^2) になる (N は文字列長です) ため、深刻な影響があります。</p>
<p>インデックスのキャッシュを持つとはいえ、インデックスアクセスはイテレータを使った逐次アクセスに置き換えるべきです。例えば典型的なループである、 </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> s(<span class="stringliteral">"hello"</span>);
<span class="keywordflow">for</span> ( <span class="keywordtype">size_t</span> i = 0; i &lt; s.<a class="code" href="classwx_string.html#af63f200410b56436a830550905e20539">length</a>(); i++ )
{
    <span class="keywordtype">wchar_t</span> ch = s[i];

    <span class="comment">// なんらかの処理</span>
}
</pre></div><p> これは以下のように書き換えるべきです。 </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> s(<span class="stringliteral">"hello"</span>);
<span class="keywordflow">for</span> ( wxString::const_iterator i = s.<a class="code" href="classwx_string.html#ad59ca2dd208720b3cce07d90bcb90093">begin</a>(); i != s.<a class="code" href="classwx_string.html#a6a0f235fff88df5e6b16b5f0e1e719cc">end</a>(); ++i )
{
    <span class="keywordtype">wchar_t</span> ch = *i

    <span class="comment">// なんらかの処理</span>
}
</pre></div><p>別の方法としては、ポインタ計算を使う方法があります: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> s(<span class="stringliteral">"hello"</span>);
<span class="keywordflow">for</span> ( <span class="keyword">const</span> <span class="keywordtype">wchar_t</span> *p = s.<a class="code" href="classwx_string.html#a6cd4782263a3ed4064eca915eb6e27e6" title="文字列をワイド文字表現に変換したものを一時的な wxWCharBuffer オブジェクト (Unix と OS X の場合)、またはワイド文字列である内部文字列のポインタ (Windows の場合) として返却します。">wc_str</a>(); *p; p++ )
{
    <span class="keywordtype">wchar_t</span> ch = *i

    <span class="comment">// これを使って何かする</span>
}
</pre></div><p> ただし、これは文字列中に <code>NUL</code> 文字が含まれる場合には正しく動作しません。生ポインタと違い、イテレータを使うといくつかの実行時チェックが (少なくともデバッグビルドでは) 行われるため、一般的にはこちらの方が望ましいです。それでもポインタを使用する場合、前のセクションで述べたような変換に伴うデータ喪失の問題を避けるために <code>char</code> ポインタよりも <code>wchar_t</code> ポインタを使うようにした方が良いです。</p>
<h2><a class="anchor" id="overview_unicode_supportout"></a>
Unicode と外部の世界</h2>
<p>wxWidgets が常に内部で Unicode を使うとはいえ、他のすべてのライブラリやプログラムが Unicode を使っているとは限りませんし、Unicode を使っていたとしても、別のエンコーディングを使用しているかもしれません。そのため、データを様々な表現方法へ変換できる必要がありますが、そのための <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> の関数として <a class="el" href="classwx_string.html#a2fec30dc8959d4fd3a56cd148bf1e57a" title="wxCharBuffer (Unicode ビルドのみ) もしくは C 文字列 (ANSI ビルド) の形式で文字列を ASCII 7 ビット文字列に変換する。">wxString::ToAscii()</a>、<a class="el" href="classwx_string.html#ac923e0bcfda57ec5064dcade9808db94" title="utf8_str() と同じです。">wxString::ToUTF8()</a> (またはそのシノニムの <a class="el" href="classwx_string.html#ad71e3ded85939db8af9eeadfa02719ac" title="文字列を UTF-8 に変換したものを一時的な wxWCharBuffer オブジェクト、または内部文字列のポインタ (UTF-8 ビルド時) として返却します。">wxString::utf8_str()</a>)、<a class="el" href="classwx_string.html#adcfd12e6d0765b1d74bccc3d63d02e98" title="wxMBConv::cWC2MB 関数を使用して文字列をマルチバイト (C 形式) 表現方法に変換し、wxCharBuffer として返却します。">wxString::mb_str()</a>、<a class="el" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">wxString::c_str()</a>、<a class="el" href="classwx_string.html#a6cd4782263a3ed4064eca915eb6e27e6" title="文字列をワイド文字表現に変換したものを一時的な wxWCharBuffer オブジェクト (Unix と OS X の場合)、またはワイド文字列である内部文字列のポインタ (Windows の場合) として返却します。">wxString::wc_str()</a> を使用できます。</p>
<p>最初の関数は文字列に 7 ビット ASCII 文字のみが含まれる場合にだけ使用してください。ASCII 文字以外の文字はなんらかの置換文字に置き換えられます。<a class="el" href="classwx_string.html#adcfd12e6d0765b1d74bccc3d63d02e98" title="wxMBConv::cWC2MB 関数を使用して文字列をマルチバイト (C 形式) 表現方法に変換し、wxCharBuffer として返却します。">wxString::mb_str()</a> は文字列を現在のロケールで使用されているエンコーディングに変換します。そのため、<a class="el" href="overview_unicode.html#overview_unicode_data_loss">Unicode の変換エラーによるデータ喪失</a> で述べたように、変換先のエンコーディングで表現できない文字が含まれている場合に空文字列を返却します。戻り値をナロー文字列として扱う場合には、<a class="el" href="classwx_string.html#a6418ec90c6d4ffe0b05702be1b35df4f" title="暗黙的に const char* や const wchar_t* へ変換可能な軽量の中間クラスを返却します。">wxString::c_str()</a> についても同じことが言えます。最後に、<a class="el" href="classwx_string.html#ac923e0bcfda57ec5064dcade9808db94" title="utf8_str() と同じです。">wxString::ToUTF8()</a> 関数と <a class="el" href="classwx_string.html#a6cd4782263a3ed4064eca915eb6e27e6" title="文字列をワイド文字表現に変換したものを一時的な wxWCharBuffer オブジェクト (Unix と OS X の場合)、またはワイド文字列である内部文字列のポインタ (Windows の場合) として返却します。">wxString::wc_str()</a> 関数は絶対に失敗せず、UTF-8 で表現された char 文字列や <code>wchar_t</code> 文字列のポインタを常に返却します。</p>
<p><a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> はさらに 2 つの便利な関数を提供しています: <a class="el" href="classwx_string.html#a5aedc23e9cc2774237d99148d0622661" title="与えられたバイナリデータを 8 ビット文字列から wxString に変換します。">wxString::From8BitData()</a> と <a class="el" href="classwx_string.html#afa91a632574bcbba1bf35b54f2c5562a" title="文字列を ISO-8859-1 の 8 ビット文字列に変換し、wxCharBuffer として返却します。 (Unicode ビルド時のみ) ">wxString::To8BitData()</a> です。これらの関数は任意のバイナリデータをもとに <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> を作成しますが、その際にバイナリデータが現在のロケールのエンコーディングで符号化されていると仮定しません。そして、なんらかの変換や <a class="el" href="classwx_string.html#a5aedc23e9cc2774237d99148d0622661" title="与えられたバイナリデータを 8 ビット文字列から wxString に変換します。">wxString::From8BitData()</a> で行われた変換の逆変換を行うことなく、元のバイナリデータを取得することができます。このため、<a class="el" href="classwx_string.html#a5aedc23e9cc2774237d99148d0622661" title="与えられたバイナリデータを 8 ビット文字列から wxString に変換します。">wxString::From8BitData()</a> は <a class="el" href="classwx_string.html#afa91a632574bcbba1bf35b54f2c5562a" title="文字列を ISO-8859-1 の 8 ビット文字列に変換し、wxCharBuffer として返却します。 (Unicode ビルド時のみ) ">wxString::To8BitData()</a> によって作られた文字列に対してのみ、使用するべきです。また、これらの関数が存在しているにも関わらず、任意のバイナリデータを格納するのに <a class="el" href="classwx_string.html" title="wxString クラスは wxWidgets 3.0 では完全に書き直されます。そして、この変更が新しいバージョンを wxWidgets 3.0 と呼ぶ主な理由です。">wxString</a> は理想的なクラスとは言えないことに注意してください。なぜなら、必要とされる量の最大 4 倍の領域を消費する (ワイド文字が 4 バイトのシステムで内部表現に <code>wchar_t</code> を使用するときがこれに該当します) ためです。代わりに <a class="el" href="classwx_memory_buffer.html" title="wxMemoryBuffer は任意のサイズのメモリブロックを格納するのに役立つデータ構造です。">wxMemoryBuffer</a> を使用することを検討してください。</p>
<p>最後の注意点です: これらの関数の大半は内部文字列のポインタを直接返却するか、一時的な <a class="el" href="classwx_char_buffer.html" title="これは char 型による wxCharTypeBuffer&lt;T&gt; の特殊化です。">wxCharBuffer</a> または <a class="el" href="classwx_w_char_buffer.html" title="これは wchar_t 型による wxCharTypeBuffer&lt;T&gt; の特殊化です。">wxWCharBuffer</a> のオブジェクトを返却します。返却されたオブジェクトは暗黙的に <code>char</code> ポインタや <code>wchar_t</code> ポインタへそれぞれ変換されます。そのため、例えば <a class="el" href="classwx_string.html#ac923e0bcfda57ec5064dcade9808db94" title="utf8_str() と同じです。">wxString::ToUTF8()</a> の戻り値を <code>const char*</code> を受け取る関数へ常に渡すことができます。. しかし、以下のようなコードは </p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <span class="keywordtype">char</span> *p = s.<a class="code" href="classwx_string.html#ac923e0bcfda57ec5064dcade9808db94" title="utf8_str() と同じです。">ToUTF8</a>();
...
puts(p); <span class="comment">// または const char * を受け取る他の関数の呼び出し</span>
</pre></div><p> 動作 <b>しません</b>。これは、<a class="el" href="classwx_string.html#ac923e0bcfda57ec5064dcade9808db94" title="utf8_str() と同じです。">wxString::ToUTF8()</a> の返却した一時バッファが破棄され、<code>p</code> が存在しないアドレスを指したままになるためです。これを正しく動作させるためには、以下のようにする必要があります。 </p>
<div class="fragment"><pre class="fragment"><span class="keyword">const</span> <a class="code" href="classwx_scoped_char_type_buffer.html">wxScopedCharBuffer</a> p(s.<a class="code" href="classwx_string.html#ac923e0bcfda57ec5064dcade9808db94" title="utf8_str() と同じです。">ToUTF8</a>());
puts(p);
</pre></div><p> これは正常に動作します。</p>
<p>同様に、<a class="el" href="classwx_string.html#a6cd4782263a3ed4064eca915eb6e27e6" title="文字列をワイド文字表現に変換したものを一時的な wxWCharBuffer オブジェクト (Unix と OS X の場合)、またはワイド文字列である内部文字列のポインタ (Windows の場合) として返却します。">wxString::wc_str()</a> の戻り値の型として wxWX2WCbuf を使用できます。しかし、実際には上記の関数の戻り値を別の関数へ直接渡すだけで、この謎めいた型を使用する必要がなくなります。 </p>
</div></div><!-- window showing the filter options -->

<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Defines</a></div><!-- iframe showing the search results (closed by default) -->


<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/>
<address class="footer">
	<small>
		
		Page generated on Mon Jul 9 2012 15:04:16 by  <!--[Doxygen 1.7.6+] $generatedby -->
		<a href="http://www.doxygen.org/index.html" target="_new">Doxygen</a> 1.7.4
	
	</small>
</address>


<script src="wxwidgets.js" type="text/javascript"></script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-40693840-1', 'murank.github.io');
  ga('send', 'pageview');

</script>
</body>
</html>
